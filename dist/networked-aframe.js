/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar AwaitQueue = /*#__PURE__*/function () {\n  function AwaitQueue() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      ClosedErrorClass: Error,\n      StoppedErrorClass: Error\n    },\n        ClosedErrorClass = _ref.ClosedErrorClass,\n        StoppedErrorClass = _ref.StoppedErrorClass;\n\n    _classCallCheck(this, AwaitQueue);\n\n    // Closed flag.\n    this._closed = false; // Queue of pending tasks.\n\n    this._pendingTasks = []; // Error class used when rejecting a task due to AwaitQueue being closed.\n\n    this._ClosedErrorClass = Error; // Error class used when rejecting a task due to AwaitQueue being stopped.\n\n    this._StoppedErrorClass = Error;\n    this._ClosedErrorClass = ClosedErrorClass;\n    this._StoppedErrorClass = StoppedErrorClass;\n  }\n  /**\n   * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n   * error.\n   */\n\n\n  _createClass(AwaitQueue, [{\n    key: \"close\",\n    value: function close() {\n      this._closed = true;\n    }\n    /**\n     * Accepts a task as argument and enqueues it after pending tasks. Once\n     * processed, the push() method resolves (or rejects) with the result\n     * returned by the given task.\n     *\n     * The given task must return a Promise or directly a value.\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(task) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(typeof task !== 'function')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new TypeError('given task is not a function');\n\n              case 2:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var pendingTask = {\n                    execute: task,\n                    resolve: resolve,\n                    reject: reject,\n                    stopped: false\n                  }; // Append task to the queue.\n\n                  _this._pendingTasks.push(pendingTask); // And run it if this is the only task in the queue.\n\n\n                  if (_this._pendingTasks.length === 1) _this._next();\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _iterator = _createForOfIteratorHelper(this._pendingTasks),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pendingTask = _step.value;\n          pendingTask.stopped = true;\n          pendingTask.reject(new this._StoppedErrorClass('AwaitQueue stopped'));\n        } // Enpty the pending tasks array.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._pendingTasks.length = 0;\n    }\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var pendingTask;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Take the first pending task.\n                pendingTask = this._pendingTasks[0];\n\n                if (pendingTask) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                _context2.next = 5;\n                return this._executeTask(pendingTask);\n\n              case 5:\n                // Remove the first pending task (the completed one) from the queue.\n                this._pendingTasks.shift(); // And continue.\n\n\n                this._next();\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"_executeTask\",\n    value: function _executeTask(pendingTask) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var result;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._closed) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                if (!pendingTask.stopped) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 5:\n                _context3.prev = 5;\n                _context3.next = 8;\n                return pendingTask.execute();\n\n              case 8:\n                result = _context3.sent;\n\n                if (!this._closed) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                return _context3.abrupt(\"return\");\n\n              case 12:\n                if (!pendingTask.stopped) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 14:\n                // Resolve the task with the returned result (if any).\n                pendingTask.resolve(result);\n                _context3.next = 25;\n                break;\n\n              case 17:\n                _context3.prev = 17;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                if (!this._closed) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                pendingTask.reject(new this._ClosedErrorClass('AwaitQueue closed'));\n                return _context3.abrupt(\"return\");\n\n              case 22:\n                if (!pendingTask.stopped) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 24:\n                // Reject the task with its own error.\n                pendingTask.reject(_context3.t0);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 17]]);\n      }));\n    }\n  }]);\n\n  return AwaitQueue;\n}();\n\nexports.AwaitQueue = AwaitQueue;\n\n//# sourceURL=webpack:///./node_modules/awaitqueue/lib/index.js?");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!function (e, t) {\n  \"object\" == ( false ? undefined : _typeof(exports)) && \"object\" == ( false ? undefined : _typeof(module)) ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(void 0, function () {\n  return function (e) {\n    var t = {};\n\n    function r(n) {\n      if (t[n]) return t[n].exports;\n      var i = t[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;\n    }\n\n    return r.m = e, r.c = t, r.d = function (e, t, n) {\n      r.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: n\n      });\n    }, r.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, r.t = function (e, t) {\n      if (1 & t && (e = r(e)), 8 & t) return e;\n      if (4 & t && \"object\" == _typeof(e) && e && e.__esModule) return e;\n      var n = Object.create(null);\n      if (r.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var i in e) {\n        r.d(n, i, function (t) {\n          return e[t];\n        }.bind(null, i));\n      }\n      return n;\n    }, r.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e[\"default\"];\n      } : function () {\n        return e;\n      };\n      return r.d(t, \"a\", t), t;\n    }, r.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, r.p = \"\", r(r.s = 90);\n  }({\n    17: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n\n      var n = r(18),\n          i = function () {\n        function e() {}\n\n        return e.getFirstMatch = function (e, t) {\n          var r = t.match(e);\n          return r && r.length > 0 && r[1] || \"\";\n        }, e.getSecondMatch = function (e, t) {\n          var r = t.match(e);\n          return r && r.length > 1 && r[2] || \"\";\n        }, e.matchAndReturnConst = function (e, t, r) {\n          if (e.test(t)) return r;\n        }, e.getWindowsVersionName = function (e) {\n          switch (e) {\n            case \"NT\":\n              return \"NT\";\n\n            case \"XP\":\n              return \"XP\";\n\n            case \"NT 5.0\":\n              return \"2000\";\n\n            case \"NT 5.1\":\n              return \"XP\";\n\n            case \"NT 5.2\":\n              return \"2003\";\n\n            case \"NT 6.0\":\n              return \"Vista\";\n\n            case \"NT 6.1\":\n              return \"7\";\n\n            case \"NT 6.2\":\n              return \"8\";\n\n            case \"NT 6.3\":\n              return \"8.1\";\n\n            case \"NT 10.0\":\n              return \"10\";\n\n            default:\n              return;\n          }\n        }, e.getMacOSVersionName = function (e) {\n          var t = e.split(\".\").splice(0, 2).map(function (e) {\n            return parseInt(e, 10) || 0;\n          });\n          if (t.push(0), 10 === t[0]) switch (t[1]) {\n            case 5:\n              return \"Leopard\";\n\n            case 6:\n              return \"Snow Leopard\";\n\n            case 7:\n              return \"Lion\";\n\n            case 8:\n              return \"Mountain Lion\";\n\n            case 9:\n              return \"Mavericks\";\n\n            case 10:\n              return \"Yosemite\";\n\n            case 11:\n              return \"El Capitan\";\n\n            case 12:\n              return \"Sierra\";\n\n            case 13:\n              return \"High Sierra\";\n\n            case 14:\n              return \"Mojave\";\n\n            case 15:\n              return \"Catalina\";\n\n            default:\n              return;\n          }\n        }, e.getAndroidVersionName = function (e) {\n          var t = e.split(\".\").splice(0, 2).map(function (e) {\n            return parseInt(e, 10) || 0;\n          });\n          if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? \"Cupcake\" : 1 === t[0] && t[1] >= 6 ? \"Donut\" : 2 === t[0] && t[1] < 2 ? \"Eclair\" : 2 === t[0] && 2 === t[1] ? \"Froyo\" : 2 === t[0] && t[1] > 2 ? \"Gingerbread\" : 3 === t[0] ? \"Honeycomb\" : 4 === t[0] && t[1] < 1 ? \"Ice Cream Sandwich\" : 4 === t[0] && t[1] < 4 ? \"Jelly Bean\" : 4 === t[0] && t[1] >= 4 ? \"KitKat\" : 5 === t[0] ? \"Lollipop\" : 6 === t[0] ? \"Marshmallow\" : 7 === t[0] ? \"Nougat\" : 8 === t[0] ? \"Oreo\" : 9 === t[0] ? \"Pie\" : void 0;\n        }, e.getVersionPrecision = function (e) {\n          return e.split(\".\").length;\n        }, e.compareVersions = function (t, r, n) {\n          void 0 === n && (n = !1);\n          var i = e.getVersionPrecision(t),\n              s = e.getVersionPrecision(r),\n              o = Math.max(i, s),\n              a = 0,\n              u = e.map([t, r], function (t) {\n            var r = o - e.getVersionPrecision(t),\n                n = t + new Array(r + 1).join(\".0\");\n            return e.map(n.split(\".\"), function (e) {\n              return new Array(20 - e.length).join(\"0\") + e;\n            }).reverse();\n          });\n\n          for (n && (a = o - Math.min(i, s)), o -= 1; o >= a;) {\n            if (u[0][o] > u[1][o]) return 1;\n\n            if (u[0][o] === u[1][o]) {\n              if (o === a) return 0;\n              o -= 1;\n            } else if (u[0][o] < u[1][o]) return -1;\n          }\n        }, e.map = function (e, t) {\n          var r,\n              n = [];\n          if (Array.prototype.map) return Array.prototype.map.call(e, t);\n\n          for (r = 0; r < e.length; r += 1) {\n            n.push(t(e[r]));\n          }\n\n          return n;\n        }, e.find = function (e, t) {\n          var r, n;\n          if (Array.prototype.find) return Array.prototype.find.call(e, t);\n\n          for (r = 0, n = e.length; r < n; r += 1) {\n            var i = e[r];\n            if (t(i, r)) return i;\n          }\n        }, e.assign = function (e) {\n          for (var t, r, n = e, i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) {\n            s[o - 1] = arguments[o];\n          }\n\n          if (Object.assign) return Object.assign.apply(Object, [e].concat(s));\n\n          var a = function a() {\n            var e = s[t];\n            \"object\" == _typeof(e) && null !== e && Object.keys(e).forEach(function (t) {\n              n[t] = e[t];\n            });\n          };\n\n          for (t = 0, r = s.length; t < r; t += 1) {\n            a();\n          }\n\n          return e;\n        }, e.getBrowserAlias = function (e) {\n          return n.BROWSER_ALIASES_MAP[e];\n        }, e.getBrowserTypeByAlias = function (e) {\n          return n.BROWSER_MAP[e] || \"\";\n        }, e;\n      }();\n\n      t[\"default\"] = i, e.exports = t[\"default\"];\n    },\n    18: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;\n      t.BROWSER_ALIASES_MAP = {\n        \"Amazon Silk\": \"amazon_silk\",\n        \"Android Browser\": \"android\",\n        Bada: \"bada\",\n        BlackBerry: \"blackberry\",\n        Chrome: \"chrome\",\n        Chromium: \"chromium\",\n        Electron: \"electron\",\n        Epiphany: \"epiphany\",\n        Firefox: \"firefox\",\n        Focus: \"focus\",\n        Generic: \"generic\",\n        \"Google Search\": \"google_search\",\n        Googlebot: \"googlebot\",\n        \"Internet Explorer\": \"ie\",\n        \"K-Meleon\": \"k_meleon\",\n        Maxthon: \"maxthon\",\n        \"Microsoft Edge\": \"edge\",\n        \"MZ Browser\": \"mz\",\n        \"NAVER Whale Browser\": \"naver\",\n        Opera: \"opera\",\n        \"Opera Coast\": \"opera_coast\",\n        PhantomJS: \"phantomjs\",\n        Puffin: \"puffin\",\n        QupZilla: \"qupzilla\",\n        QQ: \"qq\",\n        QQLite: \"qqlite\",\n        Safari: \"safari\",\n        Sailfish: \"sailfish\",\n        \"Samsung Internet for Android\": \"samsung_internet\",\n        SeaMonkey: \"seamonkey\",\n        Sleipnir: \"sleipnir\",\n        Swing: \"swing\",\n        Tizen: \"tizen\",\n        \"UC Browser\": \"uc\",\n        Vivaldi: \"vivaldi\",\n        \"WebOS Browser\": \"webos\",\n        WeChat: \"wechat\",\n        \"Yandex Browser\": \"yandex\",\n        Roku: \"roku\"\n      };\n      t.BROWSER_MAP = {\n        amazon_silk: \"Amazon Silk\",\n        android: \"Android Browser\",\n        bada: \"Bada\",\n        blackberry: \"BlackBerry\",\n        chrome: \"Chrome\",\n        chromium: \"Chromium\",\n        electron: \"Electron\",\n        epiphany: \"Epiphany\",\n        firefox: \"Firefox\",\n        focus: \"Focus\",\n        generic: \"Generic\",\n        googlebot: \"Googlebot\",\n        google_search: \"Google Search\",\n        ie: \"Internet Explorer\",\n        k_meleon: \"K-Meleon\",\n        maxthon: \"Maxthon\",\n        edge: \"Microsoft Edge\",\n        mz: \"MZ Browser\",\n        naver: \"NAVER Whale Browser\",\n        opera: \"Opera\",\n        opera_coast: \"Opera Coast\",\n        phantomjs: \"PhantomJS\",\n        puffin: \"Puffin\",\n        qupzilla: \"QupZilla\",\n        qq: \"QQ Browser\",\n        qqlite: \"QQ Browser Lite\",\n        safari: \"Safari\",\n        sailfish: \"Sailfish\",\n        samsung_internet: \"Samsung Internet for Android\",\n        seamonkey: \"SeaMonkey\",\n        sleipnir: \"Sleipnir\",\n        swing: \"Swing\",\n        tizen: \"Tizen\",\n        uc: \"UC Browser\",\n        vivaldi: \"Vivaldi\",\n        webos: \"WebOS Browser\",\n        wechat: \"WeChat\",\n        yandex: \"Yandex Browser\"\n      };\n      t.PLATFORMS_MAP = {\n        tablet: \"tablet\",\n        mobile: \"mobile\",\n        desktop: \"desktop\",\n        tv: \"tv\"\n      };\n      t.OS_MAP = {\n        WindowsPhone: \"Windows Phone\",\n        Windows: \"Windows\",\n        MacOS: \"macOS\",\n        iOS: \"iOS\",\n        Android: \"Android\",\n        WebOS: \"WebOS\",\n        BlackBerry: \"BlackBerry\",\n        Bada: \"Bada\",\n        Tizen: \"Tizen\",\n        Linux: \"Linux\",\n        ChromeOS: \"Chrome OS\",\n        PlayStation4: \"PlayStation 4\",\n        Roku: \"Roku\"\n      };\n      t.ENGINE_MAP = {\n        EdgeHTML: \"EdgeHTML\",\n        Blink: \"Blink\",\n        Trident: \"Trident\",\n        Presto: \"Presto\",\n        Gecko: \"Gecko\",\n        WebKit: \"WebKit\"\n      };\n    },\n    90: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n,\n          i = (n = r(91)) && n.__esModule ? n : {\n        \"default\": n\n      },\n          s = r(18);\n\n      function o(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      var a = function () {\n        function e() {}\n\n        var t, r, n;\n        return e.getParser = function (e, t) {\n          if (void 0 === t && (t = !1), \"string\" != typeof e) throw new Error(\"UserAgent should be a string\");\n          return new i[\"default\"](e, t);\n        }, e.parse = function (e) {\n          return new i[\"default\"](e).getResult();\n        }, t = e, n = [{\n          key: \"BROWSER_MAP\",\n          get: function get() {\n            return s.BROWSER_MAP;\n          }\n        }, {\n          key: \"ENGINE_MAP\",\n          get: function get() {\n            return s.ENGINE_MAP;\n          }\n        }, {\n          key: \"OS_MAP\",\n          get: function get() {\n            return s.OS_MAP;\n          }\n        }, {\n          key: \"PLATFORMS_MAP\",\n          get: function get() {\n            return s.PLATFORMS_MAP;\n          }\n        }], (r = null) && o(t.prototype, r), n && o(t, n), e;\n      }();\n\n      t[\"default\"] = a, e.exports = t[\"default\"];\n    },\n    91: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n = u(r(92)),\n          i = u(r(93)),\n          s = u(r(94)),\n          o = u(r(95)),\n          a = u(r(17));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      var d = function () {\n        function e(e, t) {\n          if (void 0 === t && (t = !1), null == e || \"\" === e) throw new Error(\"UserAgent parameter can't be empty\");\n          this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();\n        }\n\n        var t = e.prototype;\n        return t.getUA = function () {\n          return this._ua;\n        }, t.test = function (e) {\n          return e.test(this._ua);\n        }, t.parseBrowser = function () {\n          var e = this;\n          this.parsedResult.browser = {};\n          var t = a[\"default\"].find(n[\"default\"], function (t) {\n            if (\"function\" == typeof t.test) return t.test(e);\n            if (t.test instanceof Array) return t.test.some(function (t) {\n              return e.test(t);\n            });\n            throw new Error(\"Browser's test function is not valid\");\n          });\n          return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;\n        }, t.getBrowser = function () {\n          return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();\n        }, t.getBrowserName = function (e) {\n          return e ? String(this.getBrowser().name).toLowerCase() || \"\" : this.getBrowser().name || \"\";\n        }, t.getBrowserVersion = function () {\n          return this.getBrowser().version;\n        }, t.getOS = function () {\n          return this.parsedResult.os ? this.parsedResult.os : this.parseOS();\n        }, t.parseOS = function () {\n          var e = this;\n          this.parsedResult.os = {};\n          var t = a[\"default\"].find(i[\"default\"], function (t) {\n            if (\"function\" == typeof t.test) return t.test(e);\n            if (t.test instanceof Array) return t.test.some(function (t) {\n              return e.test(t);\n            });\n            throw new Error(\"Browser's test function is not valid\");\n          });\n          return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;\n        }, t.getOSName = function (e) {\n          var t = this.getOS().name;\n          return e ? String(t).toLowerCase() || \"\" : t || \"\";\n        }, t.getOSVersion = function () {\n          return this.getOS().version;\n        }, t.getPlatform = function () {\n          return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();\n        }, t.getPlatformType = function (e) {\n          void 0 === e && (e = !1);\n          var t = this.getPlatform().type;\n          return e ? String(t).toLowerCase() || \"\" : t || \"\";\n        }, t.parsePlatform = function () {\n          var e = this;\n          this.parsedResult.platform = {};\n          var t = a[\"default\"].find(s[\"default\"], function (t) {\n            if (\"function\" == typeof t.test) return t.test(e);\n            if (t.test instanceof Array) return t.test.some(function (t) {\n              return e.test(t);\n            });\n            throw new Error(\"Browser's test function is not valid\");\n          });\n          return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;\n        }, t.getEngine = function () {\n          return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();\n        }, t.getEngineName = function (e) {\n          return e ? String(this.getEngine().name).toLowerCase() || \"\" : this.getEngine().name || \"\";\n        }, t.parseEngine = function () {\n          var e = this;\n          this.parsedResult.engine = {};\n          var t = a[\"default\"].find(o[\"default\"], function (t) {\n            if (\"function\" == typeof t.test) return t.test(e);\n            if (t.test instanceof Array) return t.test.some(function (t) {\n              return e.test(t);\n            });\n            throw new Error(\"Browser's test function is not valid\");\n          });\n          return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;\n        }, t.parse = function () {\n          return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;\n        }, t.getResult = function () {\n          return a[\"default\"].assign({}, this.parsedResult);\n        }, t.satisfies = function (e) {\n          var t = this,\n              r = {},\n              n = 0,\n              i = {},\n              s = 0;\n\n          if (Object.keys(e).forEach(function (t) {\n            var o = e[t];\n            \"string\" == typeof o ? (i[t] = o, s += 1) : \"object\" == _typeof(o) && (r[t] = o, n += 1);\n          }), n > 0) {\n            var o = Object.keys(r),\n                u = a[\"default\"].find(o, function (e) {\n              return t.isOS(e);\n            });\n\n            if (u) {\n              var d = this.satisfies(r[u]);\n              if (void 0 !== d) return d;\n            }\n\n            var c = a[\"default\"].find(o, function (e) {\n              return t.isPlatform(e);\n            });\n\n            if (c) {\n              var f = this.satisfies(r[c]);\n              if (void 0 !== f) return f;\n            }\n          }\n\n          if (s > 0) {\n            var l = Object.keys(i),\n                h = a[\"default\"].find(l, function (e) {\n              return t.isBrowser(e, !0);\n            });\n            if (void 0 !== h) return this.compareVersion(i[h]);\n          }\n        }, t.isBrowser = function (e, t) {\n          void 0 === t && (t = !1);\n          var r = this.getBrowserName().toLowerCase(),\n              n = e.toLowerCase(),\n              i = a[\"default\"].getBrowserTypeByAlias(n);\n          return t && i && (n = i.toLowerCase()), n === r;\n        }, t.compareVersion = function (e) {\n          var t = [0],\n              r = e,\n              n = !1,\n              i = this.getBrowserVersion();\n          if (\"string\" == typeof i) return \">\" === e[0] || \"<\" === e[0] ? (r = e.substr(1), \"=\" === e[1] ? (n = !0, r = e.substr(2)) : t = [], \">\" === e[0] ? t.push(1) : t.push(-1)) : \"=\" === e[0] ? r = e.substr(1) : \"~\" === e[0] && (n = !0, r = e.substr(1)), t.indexOf(a[\"default\"].compareVersions(i, r, n)) > -1;\n        }, t.isOS = function (e) {\n          return this.getOSName(!0) === String(e).toLowerCase();\n        }, t.isPlatform = function (e) {\n          return this.getPlatformType(!0) === String(e).toLowerCase();\n        }, t.isEngine = function (e) {\n          return this.getEngineName(!0) === String(e).toLowerCase();\n        }, t.is = function (e) {\n          return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e);\n        }, t.some = function (e) {\n          var t = this;\n          return void 0 === e && (e = []), e.some(function (e) {\n            return t.is(e);\n          });\n        }, e;\n      }();\n\n      t[\"default\"] = d, e.exports = t[\"default\"];\n    },\n    92: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n,\n          i = (n = r(17)) && n.__esModule ? n : {\n        \"default\": n\n      };\n      var s = /version\\/(\\d+(\\.?_?\\d+)+)/i,\n          o = [{\n        test: [/googlebot/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Googlebot\"\n          },\n              r = i[\"default\"].getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/opera/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Opera\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/opr\\/|opios/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Opera\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/SamsungBrowser/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Samsung Internet for Android\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/Whale/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"NAVER Whale Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/MZBrowser/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"MZ Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/focus/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Focus\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/swing/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Swing\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/coast/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Opera Coast\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/yabrowser/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Yandex Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/ucbrowser/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"UC Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/Maxthon|mxios/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Maxthon\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/epiphany/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Epiphany\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/puffin/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Puffin\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/sleipnir/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Sleipnir\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/k-meleon/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"K-Meleon\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/micromessenger/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"WeChat\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/qqbrowser/i],\n        describe: function describe(e) {\n          var t = {\n            name: /qqbrowserlite/i.test(e) ? \"QQ Browser Lite\" : \"QQ Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/msie|trident/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Internet Explorer\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/\\sedg\\//i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Microsoft Edge\"\n          },\n              r = i[\"default\"].getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/edg([ea]|ios)/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Microsoft Edge\"\n          },\n              r = i[\"default\"].getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/vivaldi/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Vivaldi\"\n          },\n              r = i[\"default\"].getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/seamonkey/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"SeaMonkey\"\n          },\n              r = i[\"default\"].getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/sailfish/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Sailfish\"\n          },\n              r = i[\"default\"].getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/silk/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Amazon Silk\"\n          },\n              r = i[\"default\"].getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/phantom/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"PhantomJS\"\n          },\n              r = i[\"default\"].getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/slimerjs/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"SlimerJS\"\n          },\n              r = i[\"default\"].getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/blackberry|\\bbb\\d+/i, /rim\\stablet/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"BlackBerry\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/(web|hpw)[o0]s/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"WebOS Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e) || i[\"default\"].getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/bada/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Bada\"\n          },\n              r = i[\"default\"].getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/tizen/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Tizen\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/qupzilla/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"QupZilla\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/firefox|iceweasel|fxios/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Firefox\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/electron/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Electron\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/chromium/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Chromium\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/chrome|crios|crmo/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Chrome\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/GSA/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Google Search\"\n          },\n              r = i[\"default\"].getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: function test(e) {\n          var t = !e.test(/like android/i),\n              r = e.test(/android/i);\n          return t && r;\n        },\n        describe: function describe(e) {\n          var t = {\n            name: \"Android Browser\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/playstation 4/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"PlayStation 4\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/safari|applewebkit/i],\n        describe: function describe(e) {\n          var t = {\n            name: \"Safari\"\n          },\n              r = i[\"default\"].getFirstMatch(s, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/.*/i],\n        describe: function describe(e) {\n          var t = -1 !== e.search(\"\\\\(\") ? /^(.*)\\/(.*)[ \\t]\\((.*)/ : /^(.*)\\/(.*) /;\n          return {\n            name: i[\"default\"].getFirstMatch(t, e),\n            version: i[\"default\"].getSecondMatch(t, e)\n          };\n        }\n      }];\n      t[\"default\"] = o, e.exports = t[\"default\"];\n    },\n    93: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n,\n          i = (n = r(17)) && n.__esModule ? n : {\n        \"default\": n\n      },\n          s = r(18);\n      var o = [{\n        test: [/Roku\\/DVP/],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i, e);\n          return {\n            name: s.OS_MAP.Roku,\n            version: t\n          };\n        }\n      }, {\n        test: [/windows phone/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i, e);\n          return {\n            name: s.OS_MAP.WindowsPhone,\n            version: t\n          };\n        }\n      }, {\n        test: [/windows /i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i, e),\n              r = i[\"default\"].getWindowsVersionName(t);\n          return {\n            name: s.OS_MAP.Windows,\n            version: t,\n            versionName: r\n          };\n        }\n      }, {\n        test: [/Macintosh(.*?) FxiOS(.*?) Version\\//],\n        describe: function describe(e) {\n          var t = i[\"default\"].getSecondMatch(/(Version\\/)(\\d[\\d.]+)/, e);\n          return {\n            name: s.OS_MAP.iOS,\n            version: t\n          };\n        }\n      }, {\n        test: [/macintosh/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i, e).replace(/[_\\s]/g, \".\"),\n              r = i[\"default\"].getMacOSVersionName(t),\n              n = {\n            name: s.OS_MAP.MacOS,\n            version: t\n          };\n          return r && (n.versionName = r), n;\n        }\n      }, {\n        test: [/(ipod|iphone|ipad)/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i, e).replace(/[_\\s]/g, \".\");\n          return {\n            name: s.OS_MAP.iOS,\n            version: t\n          };\n        }\n      }, {\n        test: function test(e) {\n          var t = !e.test(/like android/i),\n              r = e.test(/android/i);\n          return t && r;\n        },\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i, e),\n              r = i[\"default\"].getAndroidVersionName(t),\n              n = {\n            name: s.OS_MAP.Android,\n            version: t\n          };\n          return r && (n.versionName = r), n;\n        }\n      }, {\n        test: [/(web|hpw)[o0]s/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i, e),\n              r = {\n            name: s.OS_MAP.WebOS\n          };\n          return t && t.length && (r.version = t), r;\n        }\n      }, {\n        test: [/blackberry|\\bbb\\d+/i, /rim\\stablet/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i, e) || i[\"default\"].getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i, e) || i[\"default\"].getFirstMatch(/\\bbb(\\d+)/i, e);\n          return {\n            name: s.OS_MAP.BlackBerry,\n            version: t\n          };\n        }\n      }, {\n        test: [/bada/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i, e);\n          return {\n            name: s.OS_MAP.Bada,\n            version: t\n          };\n        }\n      }, {\n        test: [/tizen/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i, e);\n          return {\n            name: s.OS_MAP.Tizen,\n            version: t\n          };\n        }\n      }, {\n        test: [/linux/i],\n        describe: function describe() {\n          return {\n            name: s.OS_MAP.Linux\n          };\n        }\n      }, {\n        test: [/CrOS/],\n        describe: function describe() {\n          return {\n            name: s.OS_MAP.ChromeOS\n          };\n        }\n      }, {\n        test: [/PlayStation 4/],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i, e);\n          return {\n            name: s.OS_MAP.PlayStation4,\n            version: t\n          };\n        }\n      }];\n      t[\"default\"] = o, e.exports = t[\"default\"];\n    },\n    94: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n,\n          i = (n = r(17)) && n.__esModule ? n : {\n        \"default\": n\n      },\n          s = r(18);\n      var o = [{\n        test: [/googlebot/i],\n        describe: function describe() {\n          return {\n            type: \"bot\",\n            vendor: \"Google\"\n          };\n        }\n      }, {\n        test: [/huawei/i],\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/(can-l01)/i, e) && \"Nova\",\n              r = {\n            type: s.PLATFORMS_MAP.mobile,\n            vendor: \"Huawei\"\n          };\n          return t && (r.model = t), r;\n        }\n      }, {\n        test: [/nexus\\s*(?:7|8|9|10).*/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet,\n            vendor: \"Nexus\"\n          };\n        }\n      }, {\n        test: [/ipad/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet,\n            vendor: \"Apple\",\n            model: \"iPad\"\n          };\n        }\n      }, {\n        test: [/Macintosh(.*?) FxiOS(.*?) Version\\//],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet,\n            vendor: \"Apple\",\n            model: \"iPad\"\n          };\n        }\n      }, {\n        test: [/kftt build/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet,\n            vendor: \"Amazon\",\n            model: \"Kindle Fire HD 7\"\n          };\n        }\n      }, {\n        test: [/silk/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet,\n            vendor: \"Amazon\"\n          };\n        }\n      }, {\n        test: [/tablet(?! pc)/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet\n          };\n        }\n      }, {\n        test: function test(e) {\n          var t = e.test(/ipod|iphone/i),\n              r = e.test(/like (ipod|iphone)/i);\n          return t && !r;\n        },\n        describe: function describe(e) {\n          var t = i[\"default\"].getFirstMatch(/(ipod|iphone)/i, e);\n          return {\n            type: s.PLATFORMS_MAP.mobile,\n            vendor: \"Apple\",\n            model: t\n          };\n        }\n      }, {\n        test: [/nexus\\s*[0-6].*/i, /galaxy nexus/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile,\n            vendor: \"Nexus\"\n          };\n        }\n      }, {\n        test: [/[^-]mobi/i],\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"blackberry\" === e.getBrowserName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile,\n            vendor: \"BlackBerry\"\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"bada\" === e.getBrowserName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"windows phone\" === e.getBrowserName();\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile,\n            vendor: \"Microsoft\"\n          };\n        }\n      }, {\n        test: function test(e) {\n          var t = Number(String(e.getOSVersion()).split(\".\")[0]);\n          return \"android\" === e.getOSName(!0) && t >= 3;\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tablet\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"android\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.mobile\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"macos\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.desktop,\n            vendor: \"Apple\"\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"windows\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.desktop\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"linux\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.desktop\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"playstation 4\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tv\n          };\n        }\n      }, {\n        test: function test(e) {\n          return \"roku\" === e.getOSName(!0);\n        },\n        describe: function describe() {\n          return {\n            type: s.PLATFORMS_MAP.tv\n          };\n        }\n      }];\n      t[\"default\"] = o, e.exports = t[\"default\"];\n    },\n    95: function _(e, t, r) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = void 0;\n      var n,\n          i = (n = r(17)) && n.__esModule ? n : {\n        \"default\": n\n      },\n          s = r(18);\n      var o = [{\n        test: function test(e) {\n          return \"microsoft edge\" === e.getBrowserName(!0);\n        },\n        describe: function describe(e) {\n          if (/\\sedg\\//i.test(e)) return {\n            name: s.ENGINE_MAP.Blink\n          };\n          var t = i[\"default\"].getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return {\n            name: s.ENGINE_MAP.EdgeHTML,\n            version: t\n          };\n        }\n      }, {\n        test: [/trident/i],\n        describe: function describe(e) {\n          var t = {\n            name: s.ENGINE_MAP.Trident\n          },\n              r = i[\"default\"].getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: function test(e) {\n          return e.test(/presto/i);\n        },\n        describe: function describe(e) {\n          var t = {\n            name: s.ENGINE_MAP.Presto\n          },\n              r = i[\"default\"].getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: function test(e) {\n          var t = e.test(/gecko/i),\n              r = e.test(/like gecko/i);\n          return t && !r;\n        },\n        describe: function describe(e) {\n          var t = {\n            name: s.ENGINE_MAP.Gecko\n          },\n              r = i[\"default\"].getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }, {\n        test: [/(apple)?webkit\\/537\\.36/i],\n        describe: function describe() {\n          return {\n            name: s.ENGINE_MAP.Blink\n          };\n        }\n      }, {\n        test: [/(apple)?webkit/i],\n        describe: function describe(e) {\n          var t = {\n            name: s.ENGINE_MAP.WebKit\n          },\n              r = i[\"default\"].getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i, e);\n          return r && (t.version = r), t;\n        }\n      }];\n      t[\"default\"] = o, e.exports = t[\"default\"];\n    }\n  });\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/bowser/es5.js?");

/***/ }),

/***/ "./node_modules/buffered-interpolation/dist/buffered-interpolation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/buffered-interpolation/dist/buffered-interpolation.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/* global THREE */\n\n\nvar INITIALIZING = 0;\nvar BUFFERING = 1;\nvar PLAYING = 2;\nvar MODE_LERP = 0;\nvar MODE_HERMITE = 1;\nvar vectorPool = [];\nvar quatPool = [];\nvar framePool = [];\n\nvar getPooledVector = function getPooledVector() {\n  return vectorPool.shift() || new THREE.Vector3();\n};\n\nvar getPooledQuaternion = function getPooledQuaternion() {\n  return quatPool.shift() || new THREE.Quaternion();\n};\n\nvar getPooledFrame = function getPooledFrame() {\n  var frame = framePool.pop();\n\n  if (!frame) {\n    frame = {\n      position: new THREE.Vector3(),\n      velocity: new THREE.Vector3(),\n      scale: new THREE.Vector3(),\n      quaternion: new THREE.Quaternion(),\n      time: 0\n    };\n  }\n\n  return frame;\n};\n\nvar freeFrame = function freeFrame(f) {\n  return framePool.push(f);\n};\n\nvar InterpolationBuffer = function () {\n  function InterpolationBuffer() {\n    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MODE_LERP;\n    var bufferTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;\n\n    _classCallCheck(this, InterpolationBuffer);\n\n    this.state = INITIALIZING;\n    this.buffer = [];\n    this.bufferTime = bufferTime * 1000;\n    this.time = 0;\n    this.mode = mode;\n    this.originFrame = getPooledFrame();\n    this.position = new THREE.Vector3();\n    this.quaternion = new THREE.Quaternion();\n    this.scale = new THREE.Vector3(1, 1, 1);\n  }\n\n  _createClass(InterpolationBuffer, [{\n    key: \"hermite\",\n    value: function hermite(target, t, p1, p2, v1, v2) {\n      var t2 = t * t;\n      var t3 = t * t * t;\n      var a = 2 * t3 - 3 * t2 + 1;\n      var b = -2 * t3 + 3 * t2;\n      var c = t3 - 2 * t2 + t;\n      var d = t3 - t2;\n      target.copy(p1.multiplyScalar(a));\n      target.add(p2.multiplyScalar(b));\n      target.add(v1.multiplyScalar(c));\n      target.add(v2.multiplyScalar(d));\n    }\n  }, {\n    key: \"lerp\",\n    value: function lerp(target, v1, v2, alpha) {\n      target.lerpVectors(v1, v2, alpha);\n    }\n  }, {\n    key: \"slerp\",\n    value: function slerp(target, r1, r2, alpha) {\n      THREE.Quaternion.slerp(r1, r2, target, alpha);\n    }\n  }, {\n    key: \"updateOriginFrameToBufferTail\",\n    value: function updateOriginFrameToBufferTail() {\n      freeFrame(this.originFrame);\n      this.originFrame = this.buffer.shift();\n    }\n  }, {\n    key: \"appendBuffer\",\n    value: function appendBuffer(position, velocity, quaternion, scale) {\n      var tail = this.buffer.length > 0 ? this.buffer[this.buffer.length - 1] : null; // update the last entry in the buffer if this is the same frame\n\n      if (tail && tail.time === this.time) {\n        if (position) {\n          tail.position.copy(position);\n        }\n\n        if (velocity) {\n          tail.velocity.copy(velocity);\n        }\n\n        if (quaternion) {\n          tail.quaternion.copy(quaternion);\n        }\n\n        if (scale) {\n          tail.scale.copy(scale);\n        }\n      } else {\n        var priorFrame = tail || this.originFrame;\n        var newFrame = getPooledFrame();\n        newFrame.position.copy(position || priorFrame.position);\n        newFrame.velocity.copy(velocity || priorFrame.velocity);\n        newFrame.quaternion.copy(quaternion || priorFrame.quaternion);\n        newFrame.scale.copy(scale || priorFrame.scale);\n        newFrame.time = this.time;\n        this.buffer.push(newFrame);\n      }\n    }\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(position, velocity, quaternion, scale) {\n      this.appendBuffer(position, velocity, quaternion, scale);\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(position, velocity) {\n      this.appendBuffer(position, velocity, null, null);\n    }\n  }, {\n    key: \"setQuaternion\",\n    value: function setQuaternion(quaternion) {\n      this.appendBuffer(null, null, quaternion, null);\n    }\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      this.appendBuffer(null, null, null, scale);\n    }\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      if (this.state === INITIALIZING) {\n        if (this.buffer.length > 0) {\n          this.updateOriginFrameToBufferTail();\n          this.position.copy(this.originFrame.position);\n          this.quaternion.copy(this.originFrame.quaternion);\n          this.scale.copy(this.originFrame.scale);\n          this.state = BUFFERING;\n        }\n      }\n\n      if (this.state === BUFFERING) {\n        if (this.buffer.length > 0 && this.time > this.bufferTime) {\n          this.state = PLAYING;\n        }\n      }\n\n      if (this.state === PLAYING) {\n        var mark = this.time - this.bufferTime; //Purge this.buffer of expired frames\n\n        while (this.buffer.length > 0 && mark > this.buffer[0].time) {\n          //if this is the last frame in the buffer, just update the time and reuse it\n          if (this.buffer.length > 1) {\n            this.updateOriginFrameToBufferTail();\n          } else {\n            this.originFrame.position.copy(this.buffer[0].position);\n            this.originFrame.velocity.copy(this.buffer[0].velocity);\n            this.originFrame.quaternion.copy(this.buffer[0].quaternion);\n            this.originFrame.scale.copy(this.buffer[0].scale);\n            this.originFrame.time = this.buffer[0].time;\n            this.buffer[0].time = this.time + delta;\n          }\n        }\n\n        if (this.buffer.length > 0 && this.buffer[0].time > 0) {\n          var targetFrame = this.buffer[0];\n          var delta_time = targetFrame.time - this.originFrame.time;\n          var alpha = (mark - this.originFrame.time) / delta_time;\n\n          if (this.mode === MODE_LERP) {\n            this.lerp(this.position, this.originFrame.position, targetFrame.position, alpha);\n          } else if (this.mode === MODE_HERMITE) {\n            this.hermite(this.position, alpha, this.originFrame.position, targetFrame.position, this.originFrame.velocity.multiplyScalar(delta_time), targetFrame.velocity.multiplyScalar(delta_time));\n          }\n\n          this.slerp(this.quaternion, this.originFrame.quaternion, targetFrame.quaternion, alpha);\n          this.lerp(this.scale, this.originFrame.scale, targetFrame.scale, alpha);\n        }\n      }\n\n      if (this.state !== INITIALIZING) {\n        this.time += delta;\n      }\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      return this.position;\n    }\n  }, {\n    key: \"getQuaternion\",\n    value: function getQuaternion() {\n      return this.quaternion;\n    }\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return this.scale;\n    }\n  }]);\n\n  return InterpolationBuffer;\n}();\n\nmodule.exports = InterpolationBuffer;\n\n//# sourceURL=webpack:///./node_modules/buffered-interpolation/dist/buffered-interpolation.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  } // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n  if (!useColors) return;\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.debug;\n  } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\n\nexports.enable(load());\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\n\nfunction createDebug(namespace) {\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n    var self = debug; // set `diff` timestamp\n\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr; // turn the `arguments` into a proper Array\n\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    } // apply any `formatters` transformations\n\n\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`\n\n        args.splice(index, 1);\n        index--;\n      }\n\n      return match;\n    }); // apply env-specific formatting (colors, etc.)\n\n    exports.formatArgs.call(self, args);\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace); // env-specific initialization logic for debug instances\n\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n  exports.names = [];\n  exports.skips = [];\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n\n    namespaces = split[i].replace(/\\*/g, '.*?');\n\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n/**\n * Disable debug output.\n *\n * @api public\n */\n\n\nfunction disable() {\n  exports.enable('');\n}\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\n\nfunction enabled(name) {\n  var i, len;\n\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar naiveFallback = function naiveFallback() {\n  if ((typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === \"object\" && self) return self;\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window) return window;\n  throw new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = function () {\n  if (this) return this; // Unexpected strict mode (may happen if e.g. bundled into ESM module)\n  // Fallback to standard globalThis if available\n\n  if ((typeof globalThis === \"undefined\" ? \"undefined\" : _typeof(globalThis)) === \"object\" && globalThis) return globalThis; // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n  // In all ES5+ engines global object inherits from Object.prototype\n  // (if you approached one that doesn't please report)\n\n  try {\n    Object.defineProperty(Object.prototype, \"__global__\", {\n      get: function get() {\n        return this;\n      },\n      configurable: true\n    });\n  } catch (error) {\n    // Unfortunate case of updates to Object.prototype being restricted\n    // via preventExtensions, seal or freeze\n    return naiveFallback();\n  }\n\n  try {\n    // Safari case (window.__global__ works, but __global__ does not)\n    if (!__global__) return naiveFallback();\n    return __global__;\n  } finally {\n    delete Object.prototype.__global__;\n  }\n}();\n\n//# sourceURL=webpack:///./node_modules/es5-ext/global.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/h264-profile-level-id/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js\")('h264-profile-level-id');\n/* eslint-disable no-console */\n\n\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nvar ProfileConstrainedBaseline = 1;\nvar ProfileBaseline = 2;\nvar ProfileMain = 3;\nvar ProfileConstrainedHigh = 4;\nvar ProfileHigh = 5;\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh; // All values are equal to ten times the level number, except level 1b which is\n// special.\n\nvar Level1_b = 0;\nvar Level1 = 10;\nvar Level1_1 = 11;\nvar Level1_2 = 12;\nvar Level1_3 = 13;\nvar Level2 = 20;\nvar Level2_1 = 21;\nvar Level2_2 = 22;\nvar Level3 = 30;\nvar Level3_1 = 31;\nvar Level3_2 = 32;\nvar Level4 = 40;\nvar Level4_1 = 41;\nvar Level4_2 = 42;\nvar Level5 = 50;\nvar Level5_1 = 51;\nvar Level5_2 = 52;\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nvar ProfileLevelId = function ProfileLevelId(profile, level) {\n  _classCallCheck(this, ProfileLevelId);\n\n  this.profile = profile;\n  this.level = level;\n};\n\nexports.ProfileLevelId = ProfileLevelId; // Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\n\nvar DefaultProfileLevelId = new ProfileLevelId(ProfileConstrainedBaseline, Level3_1); // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\n\nvar ConstraintSet3Flag = 0x10; // Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\n\nvar BitPattern = /*#__PURE__*/function () {\n  function BitPattern(str) {\n    _classCallCheck(this, BitPattern);\n\n    this._mask = ~byteMaskString('x', str);\n    this._maskedValue = byteMaskString('1', str);\n  }\n\n  _createClass(BitPattern, [{\n    key: \"isMatch\",\n    value: function isMatch(value) {\n      return this._maskedValue === (value & this._mask);\n    }\n  }]);\n\n  return BitPattern;\n}(); // Class for converting between profile_idc/profile_iop to Profile.\n\n\nvar ProfilePattern = function ProfilePattern(profile_idc, profile_iop, profile) {\n  _classCallCheck(this, ProfilePattern);\n\n  this.profile_idc = profile_idc;\n  this.profile_iop = profile_iop;\n  this.profile = profile;\n}; // This is from https://tools.ietf.org/html/rfc6184#section-8.1.\n\n\nvar ProfilePatterns = [new ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline), new ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline), new ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain), new ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh), new ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)];\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\n\nexports.parseProfileLevelId = function (str) {\n  // The string should consist of 3 bytes in hexadecimal format.\n  if (typeof str !== 'string' || str.length !== 6) return null;\n  var profile_level_id_numeric = parseInt(str, 16);\n  if (profile_level_id_numeric === 0) return null; // Separate into three bytes.\n\n  var level_idc = profile_level_id_numeric & 0xFF;\n  var profile_iop = profile_level_id_numeric >> 8 & 0xFF;\n  var profile_idc = profile_level_id_numeric >> 16 & 0xFF; // Parse level based on level_idc and constraint set 3 flag.\n\n  var level;\n\n  switch (level_idc) {\n    case Level1_1:\n      {\n        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n        break;\n      }\n\n    case Level1:\n    case Level1_2:\n    case Level1_3:\n    case Level2:\n    case Level2_1:\n    case Level2_2:\n    case Level3:\n    case Level3_1:\n    case Level3_2:\n    case Level4:\n    case Level4_1:\n    case Level4_2:\n    case Level5:\n    case Level5_1:\n    case Level5_2:\n      {\n        level = level_idc;\n        break;\n      }\n    // Unrecognized level_idc.\n\n    default:\n      {\n        debug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n        return null;\n      }\n  } // Parse profile_idc/profile_iop into a Profile enum.\n\n\n  var _iterator = _createForOfIteratorHelper(ProfilePatterns),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pattern = _step.value;\n\n      if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {\n        return new ProfileLevelId(pattern.profile, level);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  debug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n  return null;\n};\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\n\n\nexports.profileLevelIdToString = function (profile_level_id) {\n  // Handle special case level == 1b.\n  if (profile_level_id.level == Level1_b) {\n    switch (profile_level_id.profile) {\n      case ProfileConstrainedBaseline:\n        {\n          return '42f00b';\n        }\n\n      case ProfileBaseline:\n        {\n          return '42100b';\n        }\n\n      case ProfileMain:\n        {\n          return '4d100b';\n        }\n      // Level 1_b is not allowed for other profiles.\n\n      default:\n        {\n          debug('profileLevelIdToString() | Level 1_b not is allowed for profile:%s', profile_level_id.profile);\n          return null;\n        }\n    }\n  }\n\n  var profile_idc_iop_string;\n\n  switch (profile_level_id.profile) {\n    case ProfileConstrainedBaseline:\n      {\n        profile_idc_iop_string = '42e0';\n        break;\n      }\n\n    case ProfileBaseline:\n      {\n        profile_idc_iop_string = '4200';\n        break;\n      }\n\n    case ProfileMain:\n      {\n        profile_idc_iop_string = '4d00';\n        break;\n      }\n\n    case ProfileConstrainedHigh:\n      {\n        profile_idc_iop_string = '640c';\n        break;\n      }\n\n    case ProfileHigh:\n      {\n        profile_idc_iop_string = '6400';\n        break;\n      }\n\n    default:\n      {\n        debug('profileLevelIdToString() | unrecognized profile:%s', profile_level_id.profile);\n        return null;\n      }\n  }\n\n  var levelStr = profile_level_id.level.toString(16);\n  if (levelStr.length === 1) levelStr = \"0\".concat(levelStr);\n  return \"\".concat(profile_idc_iop_string).concat(levelStr);\n};\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\n\n\nexports.parseSdpProfileLevelId = function () {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var profile_level_id = params['profile-level-id'];\n  return !profile_level_id ? DefaultProfileLevelId : exports.parseProfileLevelId(profile_level_id);\n};\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\n\n\nexports.isSameProfile = function () {\n  var params1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var params2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n  var profile_level_id_2 = exports.parseSdpProfileLevelId(params2); // Compare H264 profiles, but not levels.\n\n  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);\n};\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\n\n\nexports.generateProfileLevelIdForAnswer = function () {\n  var local_supported_params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var remote_offered_params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // If both local and remote params do not contain profile-level-id, they are\n  // both using the default profile. In this case, don't return anything.\n  if (!local_supported_params['profile-level-id'] && !remote_offered_params['profile-level-id']) {\n    debug('generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n    return null;\n  } // Parse profile-level-ids.\n\n\n  var local_profile_level_id = exports.parseSdpProfileLevelId(local_supported_params);\n  var remote_profile_level_id = exports.parseSdpProfileLevelId(remote_offered_params); // The local and remote codec must have valid and equal H264 Profiles.\n\n  if (!local_profile_level_id) throw new TypeError('invalid local_profile_level_id');\n  if (!remote_profile_level_id) throw new TypeError('invalid remote_profile_level_id');\n  if (local_profile_level_id.profile !== remote_profile_level_id.profile) throw new TypeError('H264 Profile mismatch'); // Parse level information.\n\n  var level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);\n  var local_level = local_profile_level_id.level;\n  var remote_level = remote_profile_level_id.level;\n  var min_level = minLevel(local_level, remote_level); // Determine answer level. When level asymmetry is not allowed, level upgrade\n  // is not allowed, i.e., the level in the answer must be equal to or lower\n  // than the level in the offer.\n\n  var answer_level = level_asymmetry_allowed ? local_level : min_level;\n  debug('generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]', local_profile_level_id.profile, answer_level); // Return the resulting profile-level-id for the answer parameters.\n\n  return exports.profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));\n}; // Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\n\n\nfunction byteMaskString(c, str) {\n  return (str[0] === c) << 7 | (str[1] === c) << 6 | (str[2] === c) << 5 | (str[3] === c) << 4 | (str[4] === c) << 3 | (str[5] === c) << 2 | (str[6] === c) << 1 | (str[7] === c) << 0;\n} // Compare H264 levels and handle the level 1b case.\n\n\nfunction isLessLevel(a, b) {\n  if (a === Level1_b) return b !== Level1 && b !== Level1_b;\n  if (b === Level1_b) return a !== Level1;\n  return a < b;\n}\n\nfunction minLevel(a, b) {\n  return isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var level_asymmetry_allowed = params['level-asymmetry-allowed'];\n  return level_asymmetry_allowed === 1 || level_asymmetry_allowed === '1';\n}\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/index.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/h264-profile-level-id/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/debug/src/common.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/debug/src/common.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug[\"default\"] = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/h264-profile-level-id/node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n    newDebug.log = this.log;\n    return newDebug;\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @return {String} namespaces\n  * @api public\n  */\n\n\n  function disable() {\n    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {\n      return '-' + namespace;\n    }))).join(',');\n    createDebug.enable('');\n    return namespaces;\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Convert regexp to namespace\n  *\n  * @param {RegExp} regxep\n  * @return {String} namespace\n  * @api private\n  */\n\n\n  function toNamespace(regexp) {\n    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/node_modules/ms/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/h264-profile-level-id/node_modules/ms/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Consumer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Consumer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar logger = new Logger_1.Logger('Consumer');\n\nvar Consumer = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(Consumer, _EnhancedEventEmitter);\n\n  var _super = _createSuper(Consumer);\n\n  /**\n   * @emits transportclose\n   * @emits trackended\n   * @emits @getstats\n   * @emits @close\n   */\n  function Consumer(_ref) {\n    var _this;\n\n    var id = _ref.id,\n        localId = _ref.localId,\n        producerId = _ref.producerId,\n        rtpReceiver = _ref.rtpReceiver,\n        track = _ref.track,\n        rtpParameters = _ref.rtpParameters,\n        appData = _ref.appData;\n\n    _classCallCheck(this, Consumer);\n\n    _this = _super.call(this); // Closed flag.\n\n    _this._closed = false;\n    logger.debug('constructor()');\n    _this._id = id;\n    _this._localId = localId;\n    _this._producerId = producerId;\n    _this._rtpReceiver = rtpReceiver;\n    _this._track = track;\n    _this._rtpParameters = rtpParameters;\n    _this._paused = !track.enabled;\n    _this._appData = appData;\n    _this._onTrackEnded = _this._onTrackEnded.bind(_assertThisInitialized(_this));\n\n    _this._handleTrack();\n\n    return _this;\n  }\n  /**\n   * Consumer id.\n   */\n\n\n  _createClass(Consumer, [{\n    key: \"close\",\n\n    /**\n     * Closes the Consumer.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true;\n\n      this._destroyTrack();\n\n      this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n\n  }, {\n    key: \"transportClosed\",\n    value: function transportClosed() {\n      if (this._closed) return;\n      logger.debug('transportClosed()');\n      this._closed = true;\n\n      this._destroyTrack();\n\n      this.safeEmit('transportclose');\n    }\n    /**\n     * Get associated RTCRtpReceiver stats.\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function () {\n      var _getStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 2:\n                return _context.abrupt(\"return\", this.safeEmitAsPromise('@getstats'));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getStats() {\n        return _getStats.apply(this, arguments);\n      }\n\n      return getStats;\n    }()\n    /**\n     * Pauses receiving media.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      logger.debug('pause()');\n\n      if (this._closed) {\n        logger.error('pause() | Consumer closed');\n        return;\n      }\n\n      this._paused = true;\n      this._track.enabled = false;\n    }\n    /**\n     * Resumes receiving media.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      logger.debug('resume()');\n\n      if (this._closed) {\n        logger.error('resume() | Consumer closed');\n        return;\n      }\n\n      this._paused = false;\n      this._track.enabled = true;\n    }\n  }, {\n    key: \"_onTrackEnded\",\n    value: function _onTrackEnded() {\n      logger.debug('track \"ended\" event');\n      this.safeEmit('trackended');\n    }\n  }, {\n    key: \"_handleTrack\",\n    value: function _handleTrack() {\n      this._track.addEventListener('ended', this._onTrackEnded);\n    }\n  }, {\n    key: \"_destroyTrack\",\n    value: function _destroyTrack() {\n      try {\n        this._track.removeEventListener('ended', this._onTrackEnded);\n\n        this._track.stop();\n      } catch (error) {}\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Local id.\n     */\n\n  }, {\n    key: \"localId\",\n    get: function get() {\n      return this._localId;\n    }\n    /**\n     * Associated Producer id.\n     */\n\n  }, {\n    key: \"producerId\",\n    get: function get() {\n      return this._producerId;\n    }\n    /**\n     * Whether the Consumer is closed.\n     */\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n\n  }, {\n    key: \"kind\",\n    get: function get() {\n      return this._track.kind;\n    }\n    /**\n     * Associated RTCRtpReceiver.\n     */\n\n  }, {\n    key: \"rtpReceiver\",\n    get: function get() {\n      return this._rtpReceiver;\n    }\n    /**\n     * The associated track.\n     */\n\n  }, {\n    key: \"track\",\n    get: function get() {\n      return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n\n  }, {\n    key: \"rtpParameters\",\n    get: function get() {\n      return this._rtpParameters;\n    }\n    /**\n     * Whether the Consumer is paused.\n     */\n\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * App custom data.\n     */\n\n  }, {\n    key: \"appData\",\n    get: function get() {\n      return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(appData) {\n      throw new Error('cannot override appData object');\n    }\n  }]);\n\n  return Consumer;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.Consumer = Consumer;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/Consumer.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataConsumer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataConsumer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar logger = new Logger_1.Logger('DataConsumer');\n\nvar DataConsumer = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(DataConsumer, _EnhancedEventEmitter);\n\n  var _super = _createSuper(DataConsumer);\n\n  /**\n   * @emits transportclose\n   * @emits open\n   * @emits error - (error: Error)\n   * @emits close\n   * @emits message - (message: any)\n   * @emits @close\n   */\n  function DataConsumer(_ref) {\n    var _this;\n\n    var id = _ref.id,\n        dataProducerId = _ref.dataProducerId,\n        dataChannel = _ref.dataChannel,\n        sctpStreamParameters = _ref.sctpStreamParameters,\n        appData = _ref.appData;\n\n    _classCallCheck(this, DataConsumer);\n\n    _this = _super.call(this); // Closed flag.\n\n    _this._closed = false;\n    logger.debug('constructor()');\n    _this._id = id;\n    _this._dataProducerId = dataProducerId;\n    _this._dataChannel = dataChannel;\n    _this._sctpStreamParameters = sctpStreamParameters;\n    _this._appData = appData;\n\n    _this._handleDataChannel();\n\n    return _this;\n  }\n  /**\n   * DataConsumer id.\n   */\n\n\n  _createClass(DataConsumer, [{\n    key: \"close\",\n\n    /**\n     * Closes the DataConsumer.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true;\n\n      this._dataChannel.close();\n\n      this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n\n  }, {\n    key: \"transportClosed\",\n    value: function transportClosed() {\n      if (this._closed) return;\n      logger.debug('transportClosed()');\n      this._closed = true;\n\n      this._dataChannel.close();\n\n      this.safeEmit('transportclose');\n    }\n  }, {\n    key: \"_handleDataChannel\",\n    value: function _handleDataChannel() {\n      var _this2 = this;\n\n      this._dataChannel.addEventListener('open', function () {\n        if (_this2._closed) return;\n        logger.debug('DataChannel \"open\" event');\n\n        _this2.safeEmit('open');\n      });\n\n      this._dataChannel.addEventListener('error', function (event) {\n        if (_this2._closed) return;\n        var error = event.error;\n        if (!error) error = new Error('unknown DataChannel error');\n\n        if (error.errorDetail === 'sctp-failure') {\n          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n        } else {\n          logger.error('DataChannel \"error\" event: %o', error);\n        }\n\n        _this2.safeEmit('error', error);\n      });\n\n      this._dataChannel.addEventListener('close', function () {\n        if (_this2._closed) return;\n        logger.warn('DataChannel \"close\" event');\n        _this2._closed = true;\n\n        _this2.emit('@close');\n\n        _this2.safeEmit('close');\n      });\n\n      this._dataChannel.addEventListener('message', function (event) {\n        if (_this2._closed) return;\n\n        _this2.safeEmit('message', event.data);\n      });\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Associated DataProducer id.\n     */\n\n  }, {\n    key: \"dataProducerId\",\n    get: function get() {\n      return this._dataProducerId;\n    }\n    /**\n     * Whether the DataConsumer is closed.\n     */\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n\n  }, {\n    key: \"sctpStreamParameters\",\n    get: function get() {\n      return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel binaryType.\n     */\n\n  }, {\n    key: \"binaryType\",\n    get: function get() {\n      return this._dataChannel.binaryType;\n    }\n    /**\n     * Set DataChannel binaryType.\n     */\n    ,\n    set: function set(binaryType) {\n      this._dataChannel.binaryType = binaryType;\n    }\n    /**\n     * App custom data.\n     */\n\n  }, {\n    key: \"appData\",\n    get: function get() {\n      return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(appData) {\n      throw new Error('cannot override appData object');\n    }\n  }]);\n\n  return DataConsumer;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.DataConsumer = DataConsumer;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/DataConsumer.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/DataProducer.js":
/*!***********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/DataProducer.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar logger = new Logger_1.Logger('DataProducer');\n\nvar DataProducer = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(DataProducer, _EnhancedEventEmitter);\n\n  var _super = _createSuper(DataProducer);\n\n  /**\n   * @emits transportclose\n   * @emits open\n   * @emits error - (error: Error)\n   * @emits close\n   * @emits bufferedamountlow\n   * @emits @close\n   */\n  function DataProducer(_ref) {\n    var _this;\n\n    var id = _ref.id,\n        dataChannel = _ref.dataChannel,\n        sctpStreamParameters = _ref.sctpStreamParameters,\n        appData = _ref.appData;\n\n    _classCallCheck(this, DataProducer);\n\n    _this = _super.call(this); // Closed flag.\n\n    _this._closed = false;\n    logger.debug('constructor()');\n    _this._id = id;\n    _this._dataChannel = dataChannel;\n    _this._sctpStreamParameters = sctpStreamParameters;\n    _this._appData = appData;\n\n    _this._handleDataChannel();\n\n    return _this;\n  }\n  /**\n   * DataProducer id.\n   */\n\n\n  _createClass(DataProducer, [{\n    key: \"close\",\n\n    /**\n     * Closes the DataProducer.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true;\n\n      this._dataChannel.close();\n\n      this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n\n  }, {\n    key: \"transportClosed\",\n    value: function transportClosed() {\n      if (this._closed) return;\n      logger.debug('transportClosed()');\n      this._closed = true;\n\n      this._dataChannel.close();\n\n      this.safeEmit('transportclose');\n    }\n    /**\n     * Send a message.\n     *\n     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      logger.debug('send()');\n      if (this._closed) throw new errors_1.InvalidStateError('closed');\n\n      this._dataChannel.send(data);\n    }\n  }, {\n    key: \"_handleDataChannel\",\n    value: function _handleDataChannel() {\n      var _this2 = this;\n\n      this._dataChannel.addEventListener('open', function () {\n        if (_this2._closed) return;\n        logger.debug('DataChannel \"open\" event');\n\n        _this2.safeEmit('open');\n      });\n\n      this._dataChannel.addEventListener('error', function (event) {\n        if (_this2._closed) return;\n        var error = event.error;\n        if (!error) error = new Error('unknown DataChannel error');\n\n        if (error.errorDetail === 'sctp-failure') {\n          logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\n        } else {\n          logger.error('DataChannel \"error\" event: %o', error);\n        }\n\n        _this2.safeEmit('error', error);\n      });\n\n      this._dataChannel.addEventListener('close', function () {\n        if (_this2._closed) return;\n        logger.warn('DataChannel \"close\" event');\n        _this2._closed = true;\n\n        _this2.emit('@close');\n\n        _this2.safeEmit('close');\n      });\n\n      this._dataChannel.addEventListener('message', function () {\n        if (_this2._closed) return;\n        logger.warn('DataChannel \"message\" event in a DataProducer, message discarded');\n      });\n\n      this._dataChannel.addEventListener('bufferedamountlow', function () {\n        if (_this2._closed) return;\n\n        _this2.safeEmit('bufferedamountlow');\n      });\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Whether the DataProducer is closed.\n     */\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * SCTP stream parameters.\n     */\n\n  }, {\n    key: \"sctpStreamParameters\",\n    get: function get() {\n      return this._sctpStreamParameters;\n    }\n    /**\n     * DataChannel readyState.\n     */\n\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._dataChannel.readyState;\n    }\n    /**\n     * DataChannel label.\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this._dataChannel.label;\n    }\n    /**\n     * DataChannel protocol.\n     */\n\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._dataChannel.protocol;\n    }\n    /**\n     * DataChannel bufferedAmount.\n     */\n\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      return this._dataChannel.bufferedAmount;\n    }\n    /**\n     * DataChannel bufferedAmountLowThreshold.\n     */\n\n  }, {\n    key: \"bufferedAmountLowThreshold\",\n    get: function get() {\n      return this._dataChannel.bufferedAmountLowThreshold;\n    }\n    /**\n     * Set DataChannel bufferedAmountLowThreshold.\n     */\n    ,\n    set: function set(bufferedAmountLowThreshold) {\n      this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;\n    }\n    /**\n     * App custom data.\n     */\n\n  }, {\n    key: \"appData\",\n    get: function get() {\n      return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(appData) {\n      throw new Error('cannot override appData object');\n    }\n  }]);\n\n  return DataProducer;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.DataProducer = DataProducer;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/DataProducer.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Device.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Device.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* global RTCRtpTransceiver */\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bowser = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar ortc = __webpack_require__(/*! ./ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar Transport_1 = __webpack_require__(/*! ./Transport */ \"./node_modules/mediasoup-client/lib/Transport.js\");\n\nvar Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome74.js\");\n\nvar Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome70.js\");\n\nvar Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome67.js\");\n\nvar Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ \"./node_modules/mediasoup-client/lib/handlers/Chrome55.js\");\n\nvar Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ \"./node_modules/mediasoup-client/lib/handlers/Firefox60.js\");\n\nvar Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ \"./node_modules/mediasoup-client/lib/handlers/Safari12.js\");\n\nvar Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ \"./node_modules/mediasoup-client/lib/handlers/Safari11.js\");\n\nvar Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ \"./node_modules/mediasoup-client/lib/handlers/Edge11.js\");\n\nvar ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ \"./node_modules/mediasoup-client/lib/handlers/ReactNative.js\");\n\nvar logger = new Logger_1.Logger('Device');\n\nfunction detectDevice() {\n  // React-Native.\n  // NOTE: react-native-webrtc >= 1.75.0 is required.\n  if ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) === 'object' && navigator.product === 'ReactNative') {\n    if (typeof RTCPeerConnection === 'undefined') {\n      logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');\n      return undefined;\n    }\n\n    logger.debug('this._detectDevice() | ReactNative handler chosen');\n    return 'ReactNative';\n  } // Browser.\n  else if ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) === 'object' && typeof navigator.userAgent === 'string') {\n      var ua = navigator.userAgent;\n      var browser = bowser.getParser(ua);\n      var engine = browser.getEngine(); // Chrome and Chromium.\n\n      if (browser.satisfies({\n        chrome: '>=74',\n        chromium: '>=74'\n      })) {\n        return 'Chrome74';\n      } else if (browser.satisfies({\n        chrome: '>=70',\n        chromium: '>=70'\n      })) {\n        return 'Chrome70';\n      } else if (browser.satisfies({\n        chrome: '>=67',\n        chromium: '>=67'\n      })) {\n        return 'Chrome67';\n      } else if (browser.satisfies({\n        chrome: '>=55',\n        chromium: '>=55'\n      })) {\n        return 'Chrome55';\n      } // Firefox.\n      else if (browser.satisfies({\n          firefox: '>=60'\n        })) {\n          return 'Firefox60';\n        } // Safari with Unified-Plan support enabled.\n        else if (browser.satisfies({\n            safari: '>=12.0'\n          }) && typeof RTCRtpTransceiver !== 'undefined' && RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\n            return 'Safari12';\n          } // Safari with Plab-B support.\n          else if (browser.satisfies({\n              safari: '>=11'\n            })) {\n              return 'Safari11';\n            } // Old Edge with ORTC support.\n            else if (browser.satisfies({\n                'microsoft edge': '>=11'\n              }) && browser.satisfies({\n                'microsoft edge': '<=18'\n              })) {\n                return 'Edge11';\n              } // Best effort for Chromium based browsers.\n              else if (engine.name && engine.name.toLowerCase() === 'blink') {\n                  var match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\n\n                  if (match) {\n                    var version = Number(match[1]);\n\n                    if (version >= 74) {\n                      return 'Chrome74';\n                    } else if (version >= 70) {\n                      return 'Chrome70';\n                    } else if (version >= 67) {\n                      return 'Chrome67';\n                    } else {\n                      return 'Chrome55';\n                    }\n                  } else {\n                    return 'Chrome74';\n                  }\n                } // Unsupported browser.\n                else {\n                    logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());\n                    return undefined;\n                  }\n    } // Unknown device.\n    else {\n        logger.warn('this._detectDevice() | unknown device');\n        return undefined;\n      }\n}\n\nexports.detectDevice = detectDevice;\n\nvar Device = /*#__PURE__*/function () {\n  /**\n   * Create a new Device to connect to mediasoup server.\n   *\n   * @throws {UnsupportedError} if device is not supported.\n   */\n  function Device() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        handlerName = _ref.handlerName,\n        handlerFactory = _ref.handlerFactory,\n        Handler = _ref.Handler;\n\n    _classCallCheck(this, Device);\n\n    // Loaded flag.\n    this._loaded = false;\n    logger.debug('constructor()'); // Handle deprecated option.\n\n    if (Handler) {\n      logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');\n      if (typeof Handler === 'string') handlerName = Handler;else throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');\n    }\n\n    if (handlerName && handlerFactory) {\n      throw new TypeError('just one of handlerName or handlerInterface can be given');\n    }\n\n    if (handlerFactory) {\n      this._handlerFactory = handlerFactory;\n    } else {\n      if (handlerName) {\n        logger.debug('constructor() | handler given: %s', handlerName);\n      } else {\n        handlerName = detectDevice();\n        if (handlerName) logger.debug('constructor() | detected handler: %s', handlerName);else throw new errors_1.UnsupportedError('device not supported');\n      }\n\n      switch (handlerName) {\n        case 'Chrome74':\n          this._handlerFactory = Chrome74_1.Chrome74.createFactory();\n          break;\n\n        case 'Chrome70':\n          this._handlerFactory = Chrome70_1.Chrome70.createFactory();\n          break;\n\n        case 'Chrome67':\n          this._handlerFactory = Chrome67_1.Chrome67.createFactory();\n          break;\n\n        case 'Chrome55':\n          this._handlerFactory = Chrome55_1.Chrome55.createFactory();\n          break;\n\n        case 'Firefox60':\n          this._handlerFactory = Firefox60_1.Firefox60.createFactory();\n          break;\n\n        case 'Safari12':\n          this._handlerFactory = Safari12_1.Safari12.createFactory();\n          break;\n\n        case 'Safari11':\n          this._handlerFactory = Safari11_1.Safari11.createFactory();\n          break;\n\n        case 'Edge11':\n          this._handlerFactory = Edge11_1.Edge11.createFactory();\n          break;\n\n        case 'ReactNative':\n          this._handlerFactory = ReactNative_1.ReactNative.createFactory();\n          break;\n\n        default:\n          throw new TypeError(\"unknown handlerName \\\"\".concat(handlerName, \"\\\"\"));\n      }\n    } // Create a temporal handler to get its name.\n\n\n    var handler = this._handlerFactory();\n\n    this._handlerName = handler.name;\n    handler.close();\n    this._extendedRtpCapabilities = undefined;\n    this._recvRtpCapabilities = undefined;\n    this._canProduceByKind = {\n      audio: false,\n      video: false\n    };\n    this._sctpCapabilities = undefined;\n  }\n  /**\n   * The RTC handler name.\n   */\n\n\n  _createClass(Device, [{\n    key: \"load\",\n\n    /**\n     * Initialize the Device.\n     */\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref2) {\n        var routerRtpCapabilities, handler, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                routerRtpCapabilities = _ref2.routerRtpCapabilities;\n                logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities); // Temporal handler to get its capabilities.\n\n                _context.prev = 2;\n\n                if (!this._loaded) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('already loaded');\n\n              case 5:\n                // This may throw.\n                ortc.validateRtpCapabilities(routerRtpCapabilities);\n                handler = this._handlerFactory();\n                _context.next = 9;\n                return handler.getNativeRtpCapabilities();\n\n              case 9:\n                nativeRtpCapabilities = _context.sent;\n                logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities); // This may throw.\n\n                ortc.validateRtpCapabilities(nativeRtpCapabilities); // Get extended RTP capabilities.\n\n                this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);\n                logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities); // Check whether we can produce audio/video.\n\n                this._canProduceByKind.audio = ortc.canSend('audio', this._extendedRtpCapabilities);\n                this._canProduceByKind.video = ortc.canSend('video', this._extendedRtpCapabilities); // Generate our receiving RTP capabilities for receiving media.\n\n                this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities); // This may throw.\n\n                ortc.validateRtpCapabilities(this._recvRtpCapabilities);\n                logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities); // Generate our SCTP capabilities.\n\n                _context.next = 21;\n                return handler.getNativeSctpCapabilities();\n\n              case 21:\n                this._sctpCapabilities = _context.sent;\n                logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities); // This may throw.\n\n                ortc.validateSctpCapabilities(this._sctpCapabilities);\n                logger.debug('load() succeeded');\n                this._loaded = true;\n                handler.close();\n                _context.next = 33;\n                break;\n\n              case 29:\n                _context.prev = 29;\n                _context.t0 = _context[\"catch\"](2);\n                if (handler) handler.close();\n                throw _context.t0;\n\n              case 33:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 29]]);\n      }));\n\n      function load(_x) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n    /**\n     * Whether we can produce audio/video.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n\n  }, {\n    key: \"canProduce\",\n    value: function canProduce(kind) {\n      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');else if (kind !== 'audio' && kind !== 'video') throw new TypeError(\"invalid kind \\\"\".concat(kind, \"\\\"\"));\n      return this._canProduceByKind[kind];\n    }\n    /**\n     * Creates a Transport for sending media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n\n  }, {\n    key: \"createSendTransport\",\n    value: function createSendTransport(_ref3) {\n      var id = _ref3.id,\n          iceParameters = _ref3.iceParameters,\n          iceCandidates = _ref3.iceCandidates,\n          dtlsParameters = _ref3.dtlsParameters,\n          sctpParameters = _ref3.sctpParameters,\n          iceServers = _ref3.iceServers,\n          iceTransportPolicy = _ref3.iceTransportPolicy,\n          additionalSettings = _ref3.additionalSettings,\n          proprietaryConstraints = _ref3.proprietaryConstraints,\n          _ref3$appData = _ref3.appData,\n          appData = _ref3$appData === void 0 ? {} : _ref3$appData;\n      logger.debug('createSendTransport()');\n      return this._createTransport({\n        direction: 'send',\n        id: id,\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        iceServers: iceServers,\n        iceTransportPolicy: iceTransportPolicy,\n        additionalSettings: additionalSettings,\n        proprietaryConstraints: proprietaryConstraints,\n        appData: appData\n      });\n    }\n    /**\n     * Creates a Transport for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     * @throws {TypeError} if wrong arguments.\n     */\n\n  }, {\n    key: \"createRecvTransport\",\n    value: function createRecvTransport(_ref4) {\n      var id = _ref4.id,\n          iceParameters = _ref4.iceParameters,\n          iceCandidates = _ref4.iceCandidates,\n          dtlsParameters = _ref4.dtlsParameters,\n          sctpParameters = _ref4.sctpParameters,\n          iceServers = _ref4.iceServers,\n          iceTransportPolicy = _ref4.iceTransportPolicy,\n          additionalSettings = _ref4.additionalSettings,\n          proprietaryConstraints = _ref4.proprietaryConstraints,\n          _ref4$appData = _ref4.appData,\n          appData = _ref4$appData === void 0 ? {} : _ref4$appData;\n      logger.debug('createRecvTransport()');\n      return this._createTransport({\n        direction: 'recv',\n        id: id,\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        iceServers: iceServers,\n        iceTransportPolicy: iceTransportPolicy,\n        additionalSettings: additionalSettings,\n        proprietaryConstraints: proprietaryConstraints,\n        appData: appData\n      });\n    }\n  }, {\n    key: \"_createTransport\",\n    value: function _createTransport(_ref5) {\n      var direction = _ref5.direction,\n          id = _ref5.id,\n          iceParameters = _ref5.iceParameters,\n          iceCandidates = _ref5.iceCandidates,\n          dtlsParameters = _ref5.dtlsParameters,\n          sctpParameters = _ref5.sctpParameters,\n          iceServers = _ref5.iceServers,\n          iceTransportPolicy = _ref5.iceTransportPolicy,\n          additionalSettings = _ref5.additionalSettings,\n          proprietaryConstraints = _ref5.proprietaryConstraints,\n          _ref5$appData = _ref5.appData,\n          appData = _ref5$appData === void 0 ? {} : _ref5$appData;\n      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');else if (typeof id !== 'string') throw new TypeError('missing id');else if (_typeof(iceParameters) !== 'object') throw new TypeError('missing iceParameters');else if (!Array.isArray(iceCandidates)) throw new TypeError('missing iceCandidates');else if (_typeof(dtlsParameters) !== 'object') throw new TypeError('missing dtlsParameters');else if (sctpParameters && _typeof(sctpParameters) !== 'object') throw new TypeError('wrong sctpParameters');else if (appData && _typeof(appData) !== 'object') throw new TypeError('if given, appData must be an object'); // Create a new Transport.\n\n      var transport = new Transport_1.Transport({\n        direction: direction,\n        id: id,\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        iceServers: iceServers,\n        iceTransportPolicy: iceTransportPolicy,\n        additionalSettings: additionalSettings,\n        proprietaryConstraints: proprietaryConstraints,\n        appData: appData,\n        handlerFactory: this._handlerFactory,\n        extendedRtpCapabilities: this._extendedRtpCapabilities,\n        canProduceByKind: this._canProduceByKind\n      });\n      return transport;\n    }\n  }, {\n    key: \"handlerName\",\n    get: function get() {\n      return this._handlerName;\n    }\n    /**\n     * Whether the Device is loaded.\n     */\n\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this._loaded;\n    }\n    /**\n     * RTP capabilities of the Device for receiving media.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n\n  }, {\n    key: \"rtpCapabilities\",\n    get: function get() {\n      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');\n      return this._recvRtpCapabilities;\n    }\n    /**\n     * SCTP capabilities of the Device.\n     *\n     * @throws {InvalidStateError} if not loaded.\n     */\n\n  }, {\n    key: \"sctpCapabilities\",\n    get: function get() {\n      if (!this._loaded) throw new errors_1.InvalidStateError('not loaded');\n      return this._sctpCapabilities;\n    }\n  }]);\n\n  return Device;\n}();\n\nexports.Device = Device;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/Device.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/node-libs-browser/node_modules/events/events.js\");\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar logger = new Logger_1.Logger('EnhancedEventEmitter');\n\nvar EnhancedEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(EnhancedEventEmitter, _events_1$EventEmitte);\n\n  var _super = _createSuper(EnhancedEventEmitter);\n\n  function EnhancedEventEmitter() {\n    var _this;\n\n    _classCallCheck(this, EnhancedEventEmitter);\n\n    _this = _super.call(this);\n\n    _this.setMaxListeners(Infinity);\n\n    return _this;\n  }\n\n  _createClass(EnhancedEventEmitter, [{\n    key: \"safeEmit\",\n    value: function safeEmit(event) {\n      var numListeners = this.listenerCount(event);\n\n      try {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return this.emit.apply(this, [event].concat(args));\n      } catch (error) {\n        logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);\n        return Boolean(numListeners);\n      }\n    }\n  }, {\n    key: \"safeEmitAsPromise\",\n    value: function () {\n      var _safeEmitAsPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {\n        var _this2 = this;\n\n        var _len2,\n            args,\n            _key2,\n            _args = arguments;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                  args[_key2 - 1] = _args[_key2];\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return _this2.safeEmit.apply(_this2, [event].concat(args, [resolve, reject]));\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function safeEmitAsPromise(_x) {\n        return _safeEmitAsPromise.apply(this, arguments);\n      }\n\n      return safeEmitAsPromise;\n    }()\n  }]);\n\n  return EnhancedEventEmitter;\n}(events_1.EventEmitter);\n\nexports.EnhancedEventEmitter = EnhancedEventEmitter;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Logger.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Logger.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar debug_1 = __webpack_require__(/*! debug */ \"./node_modules/mediasoup-client/node_modules/debug/src/browser.js\");\n\nvar APP_NAME = 'mediasoup-client';\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(prefix) {\n    _classCallCheck(this, Logger);\n\n    if (prefix) {\n      this._debug = debug_1[\"default\"](\"\".concat(APP_NAME, \":\").concat(prefix));\n      this._warn = debug_1[\"default\"](\"\".concat(APP_NAME, \":WARN:\").concat(prefix));\n      this._error = debug_1[\"default\"](\"\".concat(APP_NAME, \":ERROR:\").concat(prefix));\n    } else {\n      this._debug = debug_1[\"default\"](APP_NAME);\n      this._warn = debug_1[\"default\"](\"\".concat(APP_NAME, \":WARN\"));\n      this._error = debug_1[\"default\"](\"\".concat(APP_NAME, \":ERROR\"));\n    }\n    /* eslint-disable no-console */\n\n\n    this._debug.log = console.info.bind(console);\n    this._warn.log = console.warn.bind(console);\n    this._error.log = console.error.bind(console);\n    /* eslint-enable no-console */\n  }\n\n  _createClass(Logger, [{\n    key: \"debug\",\n    get: function get() {\n      return this._debug;\n    }\n  }, {\n    key: \"warn\",\n    get: function get() {\n      return this._warn;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Logger;\n}();\n\nexports.Logger = Logger;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/Logger.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Producer.js":
/*!*******************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Producer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar logger = new Logger_1.Logger('Producer');\n\nvar Producer = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(Producer, _EnhancedEventEmitter);\n\n  var _super = _createSuper(Producer);\n\n  /**\n   * @emits transportclose\n   * @emits trackended\n   * @emits @replacetrack - (track: MediaStreamTrack | null)\n   * @emits @setmaxspatiallayer - (spatialLayer: string)\n   * @emits @setrtpencodingparameters - (params: any)\n   * @emits @getstats\n   * @emits @close\n   */\n  function Producer(_ref) {\n    var _this;\n\n    var id = _ref.id,\n        localId = _ref.localId,\n        rtpSender = _ref.rtpSender,\n        track = _ref.track,\n        rtpParameters = _ref.rtpParameters,\n        stopTracks = _ref.stopTracks,\n        disableTrackOnPause = _ref.disableTrackOnPause,\n        zeroRtpOnPause = _ref.zeroRtpOnPause,\n        appData = _ref.appData;\n\n    _classCallCheck(this, Producer);\n\n    _this = _super.call(this); // Closed flag.\n\n    _this._closed = false;\n    logger.debug('constructor()');\n    _this._id = id;\n    _this._localId = localId;\n    _this._rtpSender = rtpSender;\n    _this._track = track;\n    _this._kind = track.kind;\n    _this._rtpParameters = rtpParameters;\n    _this._paused = disableTrackOnPause ? !track.enabled : false;\n    _this._maxSpatialLayer = undefined;\n    _this._stopTracks = stopTracks;\n    _this._disableTrackOnPause = disableTrackOnPause;\n    _this._zeroRtpOnPause = zeroRtpOnPause;\n    _this._appData = appData;\n    _this._onTrackEnded = _this._onTrackEnded.bind(_assertThisInitialized(_this)); // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n    // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n\n    _this._handleTrack();\n\n    return _this;\n  }\n  /**\n   * Producer id.\n   */\n\n\n  _createClass(Producer, [{\n    key: \"close\",\n\n    /**\n     * Closes the Producer.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true;\n\n      this._destroyTrack();\n\n      this.emit('@close');\n    }\n    /**\n     * Transport was closed.\n     */\n\n  }, {\n    key: \"transportClosed\",\n    value: function transportClosed() {\n      if (this._closed) return;\n      logger.debug('transportClosed()');\n      this._closed = true;\n\n      this._destroyTrack();\n\n      this.safeEmit('transportclose');\n    }\n    /**\n     * Get associated RTCRtpSender stats.\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function () {\n      var _getStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 2:\n                return _context.abrupt(\"return\", this.safeEmitAsPromise('@getstats'));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getStats() {\n        return _getStats.apply(this, arguments);\n      }\n\n      return getStats;\n    }()\n    /**\n     * Pauses sending media.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      logger.debug('pause()');\n\n      if (this._closed) {\n        logger.error('pause() | Producer closed');\n        return;\n      }\n\n      this._paused = true;\n\n      if (this._track && this._disableTrackOnPause) {\n        this._track.enabled = false;\n      }\n\n      if (this._zeroRtpOnPause) {\n        this.safeEmitAsPromise('@replacetrack', null)[\"catch\"](function () {});\n      }\n    }\n    /**\n     * Resumes sending media.\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      logger.debug('resume()');\n\n      if (this._closed) {\n        logger.error('resume() | Producer closed');\n        return;\n      }\n\n      this._paused = false;\n\n      if (this._track && this._disableTrackOnPause) {\n        this._track.enabled = true;\n      }\n\n      if (this._zeroRtpOnPause) {\n        this.safeEmitAsPromise('@replacetrack', this._track)[\"catch\"](function () {});\n      }\n    }\n    /**\n     * Replaces the current track with a new one or null.\n     */\n\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {\n        var track;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                track = _ref2.track;\n                logger.debug('replaceTrack() [track:%o]', track);\n\n                if (!this._closed) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                // This must be done here. Otherwise there is no chance to stop the given\n                // track.\n                if (track && this._stopTracks) {\n                  try {\n                    track.stop();\n                  } catch (error) {}\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 7:\n                if (!(track && track.readyState === 'ended')) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('track ended');\n\n              case 9:\n                if (!(track === this._track)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                logger.debug('replaceTrack() | same track, ignored');\n                return _context2.abrupt(\"return\");\n\n              case 12:\n                if (!(!this._zeroRtpOnPause || !this._paused)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.next = 15;\n                return this.safeEmitAsPromise('@replacetrack', track);\n\n              case 15:\n                // Destroy the previous track.\n                this._destroyTrack(); // Set the new track.\n\n\n                this._track = track; // If this Producer was paused/resumed and the state of the new\n                // track does not match, fix it.\n\n                if (this._track && this._disableTrackOnPause) {\n                  if (!this._paused) this._track.enabled = true;else if (this._paused) this._track.enabled = false;\n                } // Handle the effective track.\n\n\n                this._handleTrack();\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function replaceTrack(_x) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n    /**\n     * Sets the video max spatial layer to be sent.\n     */\n\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(spatialLayer) {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._closed) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 4:\n                if (!(this._kind !== 'video')) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('not a video Producer');\n\n              case 8:\n                if (!(typeof spatialLayer !== 'number')) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                throw new TypeError('invalid spatialLayer');\n\n              case 10:\n                if (!(spatialLayer === this._maxSpatialLayer)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 12:\n                _context3.next = 14;\n                return this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\n\n              case 14:\n                this._maxSpatialLayer = spatialLayer;\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function setMaxSpatialLayer(_x2) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n    /**\n     * Sets the DSCP value.\n     */\n\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(params) {\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this._closed) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 4:\n                if (!(_typeof(params) !== 'object')) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new TypeError('invalid params');\n\n              case 6:\n                _context4.next = 8;\n                return this.safeEmitAsPromise('@setrtpencodingparameters', params);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function setRtpEncodingParameters(_x3) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"_onTrackEnded\",\n    value: function _onTrackEnded() {\n      logger.debug('track \"ended\" event');\n      this.safeEmit('trackended');\n    }\n  }, {\n    key: \"_handleTrack\",\n    value: function _handleTrack() {\n      if (!this._track) return;\n\n      this._track.addEventListener('ended', this._onTrackEnded);\n    }\n  }, {\n    key: \"_destroyTrack\",\n    value: function _destroyTrack() {\n      if (!this._track) return;\n\n      try {\n        this._track.removeEventListener('ended', this._onTrackEnded); // Just stop the track unless the app set stopTracks: false.\n\n\n        if (this._stopTracks) this._track.stop();\n      } catch (error) {}\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Local id.\n     */\n\n  }, {\n    key: \"localId\",\n    get: function get() {\n      return this._localId;\n    }\n    /**\n     * Whether the Producer is closed.\n     */\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n\n  }, {\n    key: \"kind\",\n    get: function get() {\n      return this._kind;\n    }\n    /**\n     * Associated RTCRtpSender.\n     */\n\n  }, {\n    key: \"rtpSender\",\n    get: function get() {\n      return this._rtpSender;\n    }\n    /**\n     * The associated track.\n     */\n\n  }, {\n    key: \"track\",\n    get: function get() {\n      return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n\n  }, {\n    key: \"rtpParameters\",\n    get: function get() {\n      return this._rtpParameters;\n    }\n    /**\n     * Whether the Producer is paused.\n     */\n\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this._paused;\n    }\n    /**\n     * Max spatial layer.\n     *\n     * @type {Number | undefined}\n     */\n\n  }, {\n    key: \"maxSpatialLayer\",\n    get: function get() {\n      return this._maxSpatialLayer;\n    }\n    /**\n     * App custom data.\n     */\n\n  }, {\n    key: \"appData\",\n    get: function get() {\n      return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(appData) {\n      throw new Error('cannot override appData object');\n    }\n  }]);\n\n  return Producer;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.Producer = Producer;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/Producer.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/Transport.js":
/*!********************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/Transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar awaitqueue_1 = __webpack_require__(/*! awaitqueue */ \"./node_modules/awaitqueue/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ./Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ./ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar Producer_1 = __webpack_require__(/*! ./Producer */ \"./node_modules/mediasoup-client/lib/Producer.js\");\n\nvar Consumer_1 = __webpack_require__(/*! ./Consumer */ \"./node_modules/mediasoup-client/lib/Consumer.js\");\n\nvar DataProducer_1 = __webpack_require__(/*! ./DataProducer */ \"./node_modules/mediasoup-client/lib/DataProducer.js\");\n\nvar DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ \"./node_modules/mediasoup-client/lib/DataConsumer.js\");\n\nvar logger = new Logger_1.Logger('Transport');\n\nvar Transport = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(Transport, _EnhancedEventEmitter);\n\n  var _super = _createSuper(Transport);\n\n  /**\n   * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)\n   * @emits connectionstatechange - (connectionState: ConnectionState)\n   * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)\n   * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)\n   */\n  function Transport(_ref) {\n    var _this;\n\n    var direction = _ref.direction,\n        id = _ref.id,\n        iceParameters = _ref.iceParameters,\n        iceCandidates = _ref.iceCandidates,\n        dtlsParameters = _ref.dtlsParameters,\n        sctpParameters = _ref.sctpParameters,\n        iceServers = _ref.iceServers,\n        iceTransportPolicy = _ref.iceTransportPolicy,\n        additionalSettings = _ref.additionalSettings,\n        proprietaryConstraints = _ref.proprietaryConstraints,\n        appData = _ref.appData,\n        handlerFactory = _ref.handlerFactory,\n        extendedRtpCapabilities = _ref.extendedRtpCapabilities,\n        canProduceByKind = _ref.canProduceByKind;\n\n    _classCallCheck(this, Transport);\n\n    _this = _super.call(this); // Closed flag.\n\n    _this._closed = false; // Transport connection state.\n\n    _this._connectionState = 'new'; // Map of Producers indexed by id.\n\n    _this._producers = new Map(); // Map of Consumers indexed by id.\n\n    _this._consumers = new Map(); // Map of DataProducers indexed by id.\n\n    _this._dataProducers = new Map(); // Map of DataConsumers indexed by id.\n\n    _this._dataConsumers = new Map(); // Whether the Consumer for RTP probation has been created.\n\n    _this._probatorConsumerCreated = false; // AwaitQueue instance to make async tasks happen sequentially.\n\n    _this._awaitQueue = new awaitqueue_1.AwaitQueue({\n      ClosedErrorClass: errors_1.InvalidStateError\n    });\n    logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n    _this._id = id;\n    _this._direction = direction;\n    _this._extendedRtpCapabilities = extendedRtpCapabilities;\n    _this._canProduceByKind = canProduceByKind;\n    _this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null; // Clone and sanitize additionalSettings.\n\n    additionalSettings = utils.clone(additionalSettings);\n    delete additionalSettings.iceServers;\n    delete additionalSettings.iceTransportPolicy;\n    delete additionalSettings.bundlePolicy;\n    delete additionalSettings.rtcpMuxPolicy;\n    delete additionalSettings.sdpSemantics;\n    _this._handler = handlerFactory();\n\n    _this._handler.run({\n      direction: direction,\n      iceParameters: iceParameters,\n      iceCandidates: iceCandidates,\n      dtlsParameters: dtlsParameters,\n      sctpParameters: sctpParameters,\n      iceServers: iceServers,\n      iceTransportPolicy: iceTransportPolicy,\n      additionalSettings: additionalSettings,\n      proprietaryConstraints: proprietaryConstraints,\n      extendedRtpCapabilities: extendedRtpCapabilities\n    });\n\n    _this._appData = appData;\n\n    _this._handleHandler();\n\n    return _this;\n  }\n  /**\n   * Transport id.\n   */\n\n\n  _createClass(Transport, [{\n    key: \"close\",\n\n    /**\n     * Close the Transport.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true; // Close the AwaitQueue.\n\n      this._awaitQueue.close(); // Close the handler.\n\n\n      this._handler.close(); // Close all Producers.\n\n\n      var _iterator = _createForOfIteratorHelper(this._producers.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var producer = _step.value;\n          producer.transportClosed();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._producers.clear(); // Close all Consumers.\n\n\n      var _iterator2 = _createForOfIteratorHelper(this._consumers.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var consumer = _step2.value;\n          consumer.transportClosed();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._consumers.clear(); // Close all DataProducers.\n\n\n      var _iterator3 = _createForOfIteratorHelper(this._dataProducers.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var dataProducer = _step3.value;\n          dataProducer.transportClosed();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._dataProducers.clear(); // Close all DataConsumers.\n\n\n      var _iterator4 = _createForOfIteratorHelper(this._dataConsumers.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var dataConsumer = _step4.value;\n          dataConsumer.transportClosed();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this._dataConsumers.clear();\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n\n  }, {\n    key: \"getStats\",\n    value: function () {\n      var _getStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 2:\n                return _context.abrupt(\"return\", this._handler.getTransportStats());\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getStats() {\n        return _getStats.apply(this, arguments);\n      }\n\n      return getStats;\n    }()\n    /**\n     * Restart ICE connection.\n     */\n\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2) {\n        var _this2 = this;\n\n        var iceParameters;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                iceParameters = _ref2.iceParameters;\n                logger.debug('restartIce()');\n\n                if (!this._closed) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 6:\n                if (iceParameters) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new TypeError('missing iceParameters');\n\n              case 8:\n                return _context3.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                  return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          return _context2.abrupt(\"return\", _this2._handler.restartIce(iceParameters));\n\n                        case 1:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                }))));\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function restartIce(_x) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n    /**\n     * Update ICE servers.\n     */\n\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        var _this3 = this;\n\n        var _ref4,\n            iceServers,\n            _args5 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _ref4 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, iceServers = _ref4.iceServers;\n                logger.debug('updateIceServers()');\n\n                if (!this._closed) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 6:\n                if (Array.isArray(iceServers)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                throw new TypeError('missing iceServers');\n\n              case 8:\n                return _context5.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n                  return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          return _context4.abrupt(\"return\", _this3._handler.updateIceServers(iceServers));\n\n                        case 1:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }))));\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function updateIceServers() {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n    /**\n     * Create a Producer.\n     */\n\n  }, {\n    key: \"produce\",\n    value: function () {\n      var _produce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n        var _this4 = this;\n\n        var _ref6,\n            track,\n            encodings,\n            codecOptions,\n            codec,\n            _ref6$stopTracks,\n            stopTracks,\n            _ref6$disableTrackOnP,\n            disableTrackOnPause,\n            _ref6$zeroRtpOnPause,\n            zeroRtpOnPause,\n            _ref6$appData,\n            appData,\n            _args7 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _ref6 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, track = _ref6.track, encodings = _ref6.encodings, codecOptions = _ref6.codecOptions, codec = _ref6.codec, _ref6$stopTracks = _ref6.stopTracks, stopTracks = _ref6$stopTracks === void 0 ? true : _ref6$stopTracks, _ref6$disableTrackOnP = _ref6.disableTrackOnPause, disableTrackOnPause = _ref6$disableTrackOnP === void 0 ? true : _ref6$disableTrackOnP, _ref6$zeroRtpOnPause = _ref6.zeroRtpOnPause, zeroRtpOnPause = _ref6$zeroRtpOnPause === void 0 ? false : _ref6$zeroRtpOnPause, _ref6$appData = _ref6.appData, appData = _ref6$appData === void 0 ? {} : _ref6$appData;\n                logger.debug('produce() [track:%o]', track);\n\n                if (track) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                throw new TypeError('missing track');\n\n              case 6:\n                if (!(this._direction !== 'send')) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('not a sending Transport');\n\n              case 10:\n                if (this._canProduceByKind[track.kind]) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError(\"cannot produce \".concat(track.kind));\n\n              case 14:\n                if (!(track.readyState === 'ended')) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('track ended');\n\n              case 18:\n                if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                throw new TypeError('no \"connect\" listener set into this transport');\n\n              case 22:\n                if (!(this.listenerCount('produce') === 0)) {\n                  _context7.next = 26;\n                  break;\n                }\n\n                throw new TypeError('no \"produce\" listener set into this transport');\n\n              case 26:\n                if (!(appData && _typeof(appData) !== 'object')) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                throw new TypeError('if given, appData must be an object');\n\n              case 28:\n                return _context7.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {\n                  var normalizedEncodings, _yield$_this4$_handle, localId, rtpParameters, rtpSender, _yield$_this4$safeEmi, id, producer;\n\n                  return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                    while (1) {\n                      switch (_context6.prev = _context6.next) {\n                        case 0:\n                          if (!(encodings && !Array.isArray(encodings))) {\n                            _context6.next = 4;\n                            break;\n                          }\n\n                          throw TypeError('encodings must be an array');\n\n                        case 4:\n                          if (encodings && encodings.length === 0) {\n                            normalizedEncodings = undefined;\n                          } else if (encodings) {\n                            normalizedEncodings = encodings.map(function (encoding) {\n                              var normalizedEncoding = {\n                                active: true\n                              };\n                              if (encoding.active === false) normalizedEncoding.active = false;\n                              if (typeof encoding.maxBitrate === 'number') normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                              if (typeof encoding.maxFramerate === 'number') normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                              if (typeof encoding.scaleResolutionDownBy === 'number') normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n                              if (typeof encoding.dtx === 'boolean') normalizedEncoding.dtx = encoding.dtx;\n                              if (typeof encoding.scalabilityMode === 'string') normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                              if (typeof encoding.priority === 'string') normalizedEncoding.priority = encoding.priority;\n                              if (typeof encoding.networkPriority === 'string') normalizedEncoding.networkPriority = encoding.networkPriority;\n                              return normalizedEncoding;\n                            });\n                          }\n\n                        case 5:\n                          _context6.next = 7;\n                          return _this4._handler.send({\n                            track: track,\n                            encodings: normalizedEncodings,\n                            codecOptions: codecOptions,\n                            codec: codec\n                          });\n\n                        case 7:\n                          _yield$_this4$_handle = _context6.sent;\n                          localId = _yield$_this4$_handle.localId;\n                          rtpParameters = _yield$_this4$_handle.rtpParameters;\n                          rtpSender = _yield$_this4$_handle.rtpSender;\n                          _context6.prev = 11;\n                          // This will fill rtpParameters's missing fields with default values.\n                          ortc.validateRtpParameters(rtpParameters);\n                          _context6.next = 15;\n                          return _this4.safeEmitAsPromise('produce', {\n                            kind: track.kind,\n                            rtpParameters: rtpParameters,\n                            appData: appData\n                          });\n\n                        case 15:\n                          _yield$_this4$safeEmi = _context6.sent;\n                          id = _yield$_this4$safeEmi.id;\n                          producer = new Producer_1.Producer({\n                            id: id,\n                            localId: localId,\n                            rtpSender: rtpSender,\n                            track: track,\n                            rtpParameters: rtpParameters,\n                            stopTracks: stopTracks,\n                            disableTrackOnPause: disableTrackOnPause,\n                            zeroRtpOnPause: zeroRtpOnPause,\n                            appData: appData\n                          });\n\n                          _this4._producers.set(producer.id, producer);\n\n                          _this4._handleProducer(producer);\n\n                          return _context6.abrupt(\"return\", producer);\n\n                        case 23:\n                          _context6.prev = 23;\n                          _context6.t0 = _context6[\"catch\"](11);\n\n                          _this4._handler.stopSending(localId)[\"catch\"](function () {});\n\n                          throw _context6.t0;\n\n                        case 27:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }\n                  }, _callee6, null, [[11, 23]]);\n                }))) // This catch is needed to stop the given track if the command above\n                // failed due to closed Transport.\n                [\"catch\"](function (error) {\n                  if (stopTracks) {\n                    try {\n                      track.stop();\n                    } catch (error2) {}\n                  }\n\n                  throw error;\n                }));\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function produce() {\n        return _produce.apply(this, arguments);\n      }\n\n      return produce;\n    }()\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n\n  }, {\n    key: \"consume\",\n    value: function () {\n      var _consume = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref8) {\n        var _this5 = this;\n\n        var id, producerId, kind, rtpParameters, _ref8$appData, appData;\n\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                id = _ref8.id, producerId = _ref8.producerId, kind = _ref8.kind, rtpParameters = _ref8.rtpParameters, _ref8$appData = _ref8.appData, appData = _ref8$appData === void 0 ? {} : _ref8$appData;\n                logger.debug('consume()');\n\n                if (!this._closed) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 6:\n                if (!(this._direction !== 'recv')) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('not a receiving Transport');\n\n              case 10:\n                if (!(typeof id !== 'string')) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                throw new TypeError('missing id');\n\n              case 14:\n                if (!(typeof producerId !== 'string')) {\n                  _context9.next = 18;\n                  break;\n                }\n\n                throw new TypeError('missing producerId');\n\n              case 18:\n                if (!(kind !== 'audio' && kind !== 'video')) {\n                  _context9.next = 22;\n                  break;\n                }\n\n                throw new TypeError(\"invalid kind '\".concat(kind, \"'\"));\n\n              case 22:\n                if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {\n                  _context9.next = 26;\n                  break;\n                }\n\n                throw new TypeError('no \"connect\" listener set into this transport');\n\n              case 26:\n                if (!(appData && _typeof(appData) !== 'object')) {\n                  _context9.next = 28;\n                  break;\n                }\n\n                throw new TypeError('if given, appData must be an object');\n\n              case 28:\n                return _context9.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n                  var canConsume, _yield$_this5$_handle, localId, rtpReceiver, track, consumer, probatorRtpParameters;\n\n                  return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                    while (1) {\n                      switch (_context8.prev = _context8.next) {\n                        case 0:\n                          // Ensure the device can consume it.\n                          canConsume = ortc.canReceive(rtpParameters, _this5._extendedRtpCapabilities);\n\n                          if (canConsume) {\n                            _context8.next = 3;\n                            break;\n                          }\n\n                          throw new errors_1.UnsupportedError('cannot consume this Producer');\n\n                        case 3:\n                          _context8.next = 5;\n                          return _this5._handler.receive({\n                            trackId: id,\n                            kind: kind,\n                            rtpParameters: rtpParameters\n                          });\n\n                        case 5:\n                          _yield$_this5$_handle = _context8.sent;\n                          localId = _yield$_this5$_handle.localId;\n                          rtpReceiver = _yield$_this5$_handle.rtpReceiver;\n                          track = _yield$_this5$_handle.track;\n                          consumer = new Consumer_1.Consumer({\n                            id: id,\n                            localId: localId,\n                            producerId: producerId,\n                            rtpReceiver: rtpReceiver,\n                            track: track,\n                            rtpParameters: rtpParameters,\n                            appData: appData\n                          });\n\n                          _this5._consumers.set(consumer.id, consumer);\n\n                          _this5._handleConsumer(consumer); // If this is the first video Consumer and the Consumer for RTP probation\n                          // has not yet been created, create it now.\n\n\n                          if (!(!_this5._probatorConsumerCreated && kind === 'video')) {\n                            _context8.next = 24;\n                            break;\n                          }\n\n                          _context8.prev = 13;\n                          probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\n                          _context8.next = 17;\n                          return _this5._handler.receive({\n                            trackId: 'probator',\n                            kind: 'video',\n                            rtpParameters: probatorRtpParameters\n                          });\n\n                        case 17:\n                          logger.debug('consume() | Consumer for RTP probation created');\n                          _this5._probatorConsumerCreated = true;\n                          _context8.next = 24;\n                          break;\n\n                        case 21:\n                          _context8.prev = 21;\n                          _context8.t0 = _context8[\"catch\"](13);\n                          logger.error('consume() | failed to create Consumer for RTP probation:%o', _context8.t0);\n\n                        case 24:\n                          return _context8.abrupt(\"return\", consumer);\n\n                        case 25:\n                        case \"end\":\n                          return _context8.stop();\n                      }\n                    }\n                  }, _callee8, null, [[13, 21]]);\n                }))));\n\n              case 29:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function consume(_x2) {\n        return _consume.apply(this, arguments);\n      }\n\n      return consume;\n    }()\n    /**\n     * Create a DataProducer\n     */\n\n  }, {\n    key: \"produceData\",\n    value: function () {\n      var _produceData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {\n        var _this6 = this;\n\n        var _ref10,\n            _ref10$ordered,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            _ref10$priority,\n            priority,\n            _ref10$label,\n            label,\n            _ref10$protocol,\n            protocol,\n            _ref10$appData,\n            appData,\n            _args11 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _ref10 = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {}, _ref10$ordered = _ref10.ordered, ordered = _ref10$ordered === void 0 ? true : _ref10$ordered, maxPacketLifeTime = _ref10.maxPacketLifeTime, maxRetransmits = _ref10.maxRetransmits, _ref10$priority = _ref10.priority, priority = _ref10$priority === void 0 ? 'low' : _ref10$priority, _ref10$label = _ref10.label, label = _ref10$label === void 0 ? '' : _ref10$label, _ref10$protocol = _ref10.protocol, protocol = _ref10$protocol === void 0 ? '' : _ref10$protocol, _ref10$appData = _ref10.appData, appData = _ref10$appData === void 0 ? {} : _ref10$appData;\n                logger.debug('produceData()');\n\n                if (!(this._direction !== 'send')) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('not a sending Transport');\n\n              case 6:\n                if (this._maxSctpMessageSize) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n\n              case 10:\n                if (['very-low', 'low', 'medium', 'high'].includes(priority)) {\n                  _context11.next = 14;\n                  break;\n                }\n\n                throw new TypeError('wrong priority');\n\n              case 14:\n                if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {\n                  _context11.next = 18;\n                  break;\n                }\n\n                throw new TypeError('no \"connect\" listener set into this transport');\n\n              case 18:\n                if (!(this.listenerCount('producedata') === 0)) {\n                  _context11.next = 22;\n                  break;\n                }\n\n                throw new TypeError('no \"producedata\" listener set into this transport');\n\n              case 22:\n                if (!(appData && _typeof(appData) !== 'object')) {\n                  _context11.next = 24;\n                  break;\n                }\n\n                throw new TypeError('if given, appData must be an object');\n\n              case 24:\n                if (maxPacketLifeTime || maxRetransmits) ordered = false; // Enqueue command.\n\n                return _context11.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {\n                  var _yield$_this6$_handle, dataChannel, sctpStreamParameters, _yield$_this6$safeEmi, id, dataProducer;\n\n                  return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                    while (1) {\n                      switch (_context10.prev = _context10.next) {\n                        case 0:\n                          _context10.next = 2;\n                          return _this6._handler.sendDataChannel({\n                            ordered: ordered,\n                            maxPacketLifeTime: maxPacketLifeTime,\n                            maxRetransmits: maxRetransmits,\n                            priority: priority,\n                            label: label,\n                            protocol: protocol\n                          });\n\n                        case 2:\n                          _yield$_this6$_handle = _context10.sent;\n                          dataChannel = _yield$_this6$_handle.dataChannel;\n                          sctpStreamParameters = _yield$_this6$_handle.sctpStreamParameters;\n                          // This will fill sctpStreamParameters's missing fields with default values.\n                          ortc.validateSctpStreamParameters(sctpStreamParameters);\n                          _context10.next = 8;\n                          return _this6.safeEmitAsPromise('producedata', {\n                            sctpStreamParameters: sctpStreamParameters,\n                            label: label,\n                            protocol: protocol,\n                            appData: appData\n                          });\n\n                        case 8:\n                          _yield$_this6$safeEmi = _context10.sent;\n                          id = _yield$_this6$safeEmi.id;\n                          dataProducer = new DataProducer_1.DataProducer({\n                            id: id,\n                            dataChannel: dataChannel,\n                            sctpStreamParameters: sctpStreamParameters,\n                            appData: appData\n                          });\n\n                          _this6._dataProducers.set(dataProducer.id, dataProducer);\n\n                          _this6._handleDataProducer(dataProducer);\n\n                          return _context10.abrupt(\"return\", dataProducer);\n\n                        case 14:\n                        case \"end\":\n                          return _context10.stop();\n                      }\n                    }\n                  }, _callee10);\n                }))));\n\n              case 26:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function produceData() {\n        return _produceData.apply(this, arguments);\n      }\n\n      return produceData;\n    }()\n    /**\n     * Create a DataConsumer\n     */\n\n  }, {\n    key: \"consumeData\",\n    value: function () {\n      var _consumeData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref12) {\n        var _this7 = this;\n\n        var id, dataProducerId, sctpStreamParameters, _ref12$label, label, _ref12$protocol, protocol, _ref12$appData, appData;\n\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                id = _ref12.id, dataProducerId = _ref12.dataProducerId, sctpStreamParameters = _ref12.sctpStreamParameters, _ref12$label = _ref12.label, label = _ref12$label === void 0 ? '' : _ref12$label, _ref12$protocol = _ref12.protocol, protocol = _ref12$protocol === void 0 ? '' : _ref12$protocol, _ref12$appData = _ref12.appData, appData = _ref12$appData === void 0 ? {} : _ref12$appData;\n                logger.debug('consumeData()');\n\n                if (!this._closed) {\n                  _context13.next = 6;\n                  break;\n                }\n\n                throw new errors_1.InvalidStateError('closed');\n\n              case 6:\n                if (!(this._direction !== 'recv')) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('not a receiving Transport');\n\n              case 10:\n                if (this._maxSctpMessageSize) {\n                  _context13.next = 14;\n                  break;\n                }\n\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n\n              case 14:\n                if (!(typeof id !== 'string')) {\n                  _context13.next = 18;\n                  break;\n                }\n\n                throw new TypeError('missing id');\n\n              case 18:\n                if (!(typeof dataProducerId !== 'string')) {\n                  _context13.next = 22;\n                  break;\n                }\n\n                throw new TypeError('missing dataProducerId');\n\n              case 22:\n                if (!(this.listenerCount('connect') === 0 && this._connectionState === 'new')) {\n                  _context13.next = 26;\n                  break;\n                }\n\n                throw new TypeError('no \"connect\" listener set into this transport');\n\n              case 26:\n                if (!(appData && _typeof(appData) !== 'object')) {\n                  _context13.next = 28;\n                  break;\n                }\n\n                throw new TypeError('if given, appData must be an object');\n\n              case 28:\n                // This may throw.\n                ortc.validateSctpStreamParameters(sctpStreamParameters); // Enqueue command.\n\n                return _context13.abrupt(\"return\", this._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {\n                  var _yield$_this7$_handle, dataChannel, dataConsumer;\n\n                  return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                    while (1) {\n                      switch (_context12.prev = _context12.next) {\n                        case 0:\n                          _context12.next = 2;\n                          return _this7._handler.receiveDataChannel({\n                            sctpStreamParameters: sctpStreamParameters,\n                            label: label,\n                            protocol: protocol\n                          });\n\n                        case 2:\n                          _yield$_this7$_handle = _context12.sent;\n                          dataChannel = _yield$_this7$_handle.dataChannel;\n                          dataConsumer = new DataConsumer_1.DataConsumer({\n                            id: id,\n                            dataProducerId: dataProducerId,\n                            dataChannel: dataChannel,\n                            sctpStreamParameters: sctpStreamParameters,\n                            appData: appData\n                          });\n\n                          _this7._dataConsumers.set(dataConsumer.id, dataConsumer);\n\n                          _this7._handleDataConsumer(dataConsumer);\n\n                          return _context12.abrupt(\"return\", dataConsumer);\n\n                        case 8:\n                        case \"end\":\n                          return _context12.stop();\n                      }\n                    }\n                  }, _callee12);\n                }))));\n\n              case 30:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function consumeData(_x3) {\n        return _consumeData.apply(this, arguments);\n      }\n\n      return consumeData;\n    }()\n  }, {\n    key: \"_handleHandler\",\n    value: function _handleHandler() {\n      var _this8 = this;\n\n      var handler = this._handler;\n      handler.on('@connect', function (_ref14, callback, errback) {\n        var dtlsParameters = _ref14.dtlsParameters;\n\n        if (_this8._closed) {\n          errback(new errors_1.InvalidStateError('closed'));\n          return;\n        }\n\n        _this8.safeEmit('connect', {\n          dtlsParameters: dtlsParameters\n        }, callback, errback);\n      });\n      handler.on('@connectionstatechange', function (connectionState) {\n        if (connectionState === _this8._connectionState) return;\n        logger.debug('connection state changed to %s', connectionState);\n        _this8._connectionState = connectionState;\n        if (!_this8._closed) _this8.safeEmit('connectionstatechange', connectionState);\n      });\n    }\n  }, {\n    key: \"_handleProducer\",\n    value: function _handleProducer(producer) {\n      var _this9 = this;\n\n      producer.on('@close', function () {\n        _this9._producers[\"delete\"](producer.id);\n\n        if (_this9._closed) return;\n\n        _this9._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {\n          return regeneratorRuntime.wrap(function _callee14$(_context14) {\n            while (1) {\n              switch (_context14.prev = _context14.next) {\n                case 0:\n                  return _context14.abrupt(\"return\", _this9._handler.stopSending(producer.localId));\n\n                case 1:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }\n          }, _callee14);\n        })))[\"catch\"](function (error) {\n          return logger.warn('producer.close() failed:%o', error);\n        });\n      });\n      producer.on('@replacetrack', function (track, callback, errback) {\n        _this9._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {\n          return regeneratorRuntime.wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  return _context15.abrupt(\"return\", _this9._handler.replaceTrack(producer.localId, track));\n\n                case 1:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15);\n        }))).then(callback)[\"catch\"](errback);\n      });\n      producer.on('@setmaxspatiallayer', function (spatialLayer, callback, errback) {\n        _this9._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {\n          return regeneratorRuntime.wrap(function _callee16$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  return _context16.abrupt(\"return\", _this9._handler.setMaxSpatialLayer(producer.localId, spatialLayer));\n\n                case 1:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }, _callee16);\n        }))).then(callback)[\"catch\"](errback);\n      });\n      producer.on('@setrtpencodingparameters', function (params, callback, errback) {\n        _this9._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {\n          return regeneratorRuntime.wrap(function _callee17$(_context17) {\n            while (1) {\n              switch (_context17.prev = _context17.next) {\n                case 0:\n                  return _context17.abrupt(\"return\", _this9._handler.setRtpEncodingParameters(producer.localId, params));\n\n                case 1:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }\n          }, _callee17);\n        }))).then(callback)[\"catch\"](errback);\n      });\n      producer.on('@getstats', function (callback, errback) {\n        if (_this9._closed) return errback(new errors_1.InvalidStateError('closed'));\n\n        _this9._handler.getSenderStats(producer.localId).then(callback)[\"catch\"](errback);\n      });\n    }\n  }, {\n    key: \"_handleConsumer\",\n    value: function _handleConsumer(consumer) {\n      var _this10 = this;\n\n      consumer.on('@close', function () {\n        _this10._consumers[\"delete\"](consumer.id);\n\n        if (_this10._closed) return;\n\n        _this10._awaitQueue.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {\n          return regeneratorRuntime.wrap(function _callee18$(_context18) {\n            while (1) {\n              switch (_context18.prev = _context18.next) {\n                case 0:\n                  return _context18.abrupt(\"return\", _this10._handler.stopReceiving(consumer.localId));\n\n                case 1:\n                case \"end\":\n                  return _context18.stop();\n              }\n            }\n          }, _callee18);\n        })))[\"catch\"](function () {});\n      });\n      consumer.on('@getstats', function (callback, errback) {\n        if (_this10._closed) return errback(new errors_1.InvalidStateError('closed'));\n\n        _this10._handler.getReceiverStats(consumer.localId).then(callback)[\"catch\"](errback);\n      });\n    }\n  }, {\n    key: \"_handleDataProducer\",\n    value: function _handleDataProducer(dataProducer) {\n      var _this11 = this;\n\n      dataProducer.on('@close', function () {\n        _this11._dataProducers[\"delete\"](dataProducer.id);\n      });\n    }\n  }, {\n    key: \"_handleDataConsumer\",\n    value: function _handleDataConsumer(dataConsumer) {\n      var _this12 = this;\n\n      dataConsumer.on('@close', function () {\n        _this12._dataConsumers[\"delete\"](dataConsumer.id);\n      });\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this._handler;\n    }\n    /**\n     * Connection state.\n     */\n\n  }, {\n    key: \"connectionState\",\n    get: function get() {\n      return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n\n  }, {\n    key: \"appData\",\n    get: function get() {\n      return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(appData) {\n      throw new Error('cannot override appData object');\n    }\n  }]);\n\n  return Transport;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.Transport = Transport;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/Transport.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/errors.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Error indicating not support for something.\n */\n\nvar UnsupportedError = /*#__PURE__*/function (_Error) {\n  _inherits(UnsupportedError, _Error);\n\n  var _super = _createSuper(UnsupportedError);\n\n  function UnsupportedError(message) {\n    var _this;\n\n    _classCallCheck(this, UnsupportedError);\n\n    _this = _super.call(this, message);\n    _this.name = 'UnsupportedError';\n\n    if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n      {\n        // @ts-ignore\n        Error.captureStackTrace(_assertThisInitialized(_this), UnsupportedError);\n      } else {\n      _this.stack = new Error(message).stack;\n    }\n\n    return _this;\n  }\n\n  return UnsupportedError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.UnsupportedError = UnsupportedError;\n/**\n * Error produced when calling a method in an invalid state.\n */\n\nvar InvalidStateError = /*#__PURE__*/function (_Error2) {\n  _inherits(InvalidStateError, _Error2);\n\n  var _super2 = _createSuper(InvalidStateError);\n\n  function InvalidStateError(message) {\n    var _this2;\n\n    _classCallCheck(this, InvalidStateError);\n\n    _this2 = _super2.call(this, message);\n    _this2.name = 'InvalidStateError';\n\n    if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n      {\n        // @ts-ignore\n        Error.captureStackTrace(_assertThisInitialized(_this2), InvalidStateError);\n      } else {\n      _this2.stack = new Error(message).stack;\n    }\n\n    return _this2;\n  }\n\n  return InvalidStateError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.InvalidStateError = InvalidStateError;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/errors.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome55.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome55.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('Chrome55');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Chrome55 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Chrome55, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Chrome55);\n\n  function Chrome55() {\n    var _this;\n\n    _classCallCheck(this, Chrome55);\n\n    _this = _super.call(this); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Map of sending MediaStreamTracks indexed by localId.\n\n    _this._mapSendLocalIdTrack = new Map(); // Next sending localId.\n\n    _this._nextSendLocalId = 0; // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n\n    _this._mapRecvLocalIdInfo = new Map(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Chrome55, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'plan-b'\n                });\n                _context.prev = 2;\n                _context.next = 5;\n                return pc.createOffer({\n                  offerToReceiveAudio: true,\n                  offerToReceiveVideo: true\n                });\n\n              case 5:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 12]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        planB: true\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require',\n        sdpSemantics: 'plan-b'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (codec) {\n                  logger.warn('send() | codec selection is not available in %s handler', this.name);\n                }\n\n                this._sendStream.addTrack(track);\n\n                this._pc.addStream(this._sendStream);\n\n                _context6.next = 8;\n                return this._pc.createOffer();\n\n              case 8:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n\n                if (this._transportReady) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 17:\n                if (track.kind === 'video' && encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media.find(function (m) {\n                    return m.type === 'video';\n                  });\n                  sdpPlanBUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    track: track,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 21;\n                return this._pc.setLocalDescription(offer);\n\n              case 21:\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === track.kind;\n                }); // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject,\n                  track: track\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                    if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                  }\n                } // If VP8 and there is effective simulcast, add scalabilityMode to each\n                // encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 32;\n                return this._pc.setRemoteDescription(answer);\n\n              case 32:\n                localId = String(this._nextSendLocalId);\n                this._nextSendLocalId++; // Insert into the map.\n\n                this._mapSendLocalIdTrack.set(localId, track);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters\n                });\n\n              case 36:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var track, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                track = this._mapSendLocalIdTrack.get(localId);\n\n                if (track) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('track not found');\n\n              case 5:\n                this._mapSendLocalIdTrack[\"delete\"](localId);\n\n                this._sendStream.removeTrack(track);\n\n                this._pc.addStream(this._sendStream);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.prev = 12;\n                _context7.next = 15;\n                return this._pc.setLocalDescription(offer);\n\n              case 15:\n                _context7.next = 23;\n                break;\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](12);\n\n                if (!(this._sendStream.getTracks().length === 0)) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());\n                return _context7.abrupt(\"return\");\n\n              case 22:\n                throw _context7.t0;\n\n              case 23:\n                if (!(this._pc.signalingState === 'stable')) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 25:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 29;\n                return this._pc.setRemoteDescription(answer);\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[12, 17]]);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      localId, track) {\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                throw new errors_1.UnsupportedError(' not implemented');\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not supported');\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, mid, streamId, offer, answer, localSdpObject, answerMediaObject, stream, track;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = trackId;\n                mid = kind;\n                streamId = rtpParameters.rtcp.cname;\n\n                this._remoteSdp.receive({\n                  mid: mid,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: streamId,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 11;\n                return this._pc.setRemoteDescription(offer);\n\n              case 11:\n                _context13.next = 13;\n                return this._pc.createAnswer();\n\n              case 13:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === mid;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 21;\n                  break;\n                }\n\n                _context13.next = 21;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 21:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 24;\n                return this._pc.setLocalDescription(answer);\n\n              case 24:\n                stream = this._pc.getRemoteStreams().find(function (s) {\n                  return s.id === streamId;\n                });\n                track = stream.getTrackById(localId);\n\n                if (track) {\n                  _context13.next = 28;\n                  break;\n                }\n\n                throw new Error('remote track not found');\n\n              case 28:\n                // Insert into the map.\n                this._mapRecvLocalIdInfo.set(localId, {\n                  mid: mid,\n                  rtpParameters: rtpParameters\n                });\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: track\n                });\n\n              case 30:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var _ref5, mid, rtpParameters, offer, answer;\n\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref5.mid, rtpParameters = _ref5.rtpParameters; // Remove from the map.\n\n                this._mapRecvLocalIdInfo[\"delete\"](localId);\n\n                this._remoteSdp.planBStopReceiving({\n                  mid: mid,\n                  offerRtpParameters: rtpParameters\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context14.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 15;\n                return this._pc.setLocalDescription(answer);\n\n              case 15:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref6) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation({\n                  oldDataChannelSpec: true\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref7) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Chrome55';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Chrome55();\n      };\n    }\n  }]);\n\n  return Chrome55;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Chrome55 = Chrome55;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Chrome55.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome67.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome67.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('Chrome67');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Chrome67 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Chrome67, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Chrome67);\n\n  function Chrome67() {\n    var _this;\n\n    _classCallCheck(this, Chrome67);\n\n    _this = _super.call(this); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Map of RTCRtpSender indexed by localId.\n\n    _this._mapSendLocalIdRtpSender = new Map(); // Next sending localId.\n\n    _this._nextSendLocalId = 0; // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n\n    _this._mapRecvLocalIdInfo = new Map(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Chrome67, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'plan-b'\n                });\n                _context.prev = 2;\n                _context.next = 5;\n                return pc.createOffer({\n                  offerToReceiveAudio: true,\n                  offerToReceiveVideo: true\n                });\n\n              case 5:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 12]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        planB: true\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require',\n        sdpSemantics: 'plan-b'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId, rtpSender;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (codec) {\n                  logger.warn('send() | codec selection is not available in %s handler', this.name);\n                }\n\n                this._sendStream.addTrack(track);\n\n                this._pc.addTrack(track, this._sendStream);\n\n                _context6.next = 8;\n                return this._pc.createOffer();\n\n              case 8:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n\n                if (this._transportReady) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 17:\n                if (track.kind === 'video' && encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media.find(function (m) {\n                    return m.type === 'video';\n                  });\n                  sdpPlanBUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    track: track,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 21;\n                return this._pc.setLocalDescription(offer);\n\n              case 21:\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === track.kind;\n                }); // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject,\n                  track: track\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                    if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                  }\n                } // If VP8 and there is effective simulcast, add scalabilityMode to each\n                // encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 32;\n                return this._pc.setRemoteDescription(answer);\n\n              case 32:\n                localId = String(this._nextSendLocalId);\n                this._nextSendLocalId++;\n                rtpSender = this._pc.getSenders().find(function (s) {\n                  return s.track === track;\n                }); // Insert into the map.\n\n                this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: rtpSender\n                });\n\n              case 37:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var rtpSender, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                this._pc.removeTrack(rtpSender);\n\n                if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);\n\n                this._mapSendLocalIdRtpSender[\"delete\"](localId);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.prev = 12;\n                _context7.next = 15;\n                return this._pc.setLocalDescription(offer);\n\n              case 15:\n                _context7.next = 23;\n                break;\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](12);\n\n                if (!(this._sendStream.getTracks().length === 0)) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());\n                return _context7.abrupt(\"return\");\n\n              case 22:\n                throw _context7.t0;\n\n              case 23:\n                if (!(this._pc.signalingState === 'stable')) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 25:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 29;\n                return this._pc.setRemoteDescription(answer);\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[12, 17]]);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var rtpSender, oldTrack;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                oldTrack = rtpSender.track;\n                _context8.next = 8;\n                return rtpSender.replaceTrack(track);\n\n              case 8:\n                // Remove the old track from the local stream.\n                if (oldTrack) this._sendStream.removeTrack(oldTrack); // Add the new track to the local stream.\n\n                if (track) this._sendStream.addTrack(track);\n\n              case 10:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 9;\n                return rtpSender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return rtpSender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var rtpSender;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", rtpSender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, mid, offer, answer, localSdpObject, answerMediaObject, rtpReceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = trackId;\n                mid = kind;\n\n                this._remoteSdp.receive({\n                  mid: mid,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context13.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === mid;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 20;\n                  break;\n                }\n\n                _context13.next = 20;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 20:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 23;\n                return this._pc.setLocalDescription(answer);\n\n              case 23:\n                rtpReceiver = this._pc.getReceivers().find(function (r) {\n                  return r.track && r.track.id === localId;\n                });\n\n                if (rtpReceiver) {\n                  _context13.next = 26;\n                  break;\n                }\n\n                throw new Error('new RTCRtpReceiver not');\n\n              case 26:\n                // Insert into the map.\n                this._mapRecvLocalIdInfo.set(localId, {\n                  mid: mid,\n                  rtpParameters: rtpParameters,\n                  rtpReceiver: rtpReceiver\n                });\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: rtpReceiver.track,\n                  rtpReceiver: rtpReceiver\n                });\n\n              case 28:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var _ref5, mid, rtpParameters, offer, answer;\n\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref5.mid, rtpParameters = _ref5.rtpParameters; // Remove from the map.\n\n                this._mapRecvLocalIdInfo[\"delete\"](localId);\n\n                this._remoteSdp.planBStopReceiving({\n                  mid: mid,\n                  offerRtpParameters: rtpParameters\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context14.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 15;\n                return this._pc.setLocalDescription(answer);\n\n              case 15:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var _ref6, rtpReceiver;\n\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                _ref6 = this._mapRecvLocalIdInfo.get(localId) || {}, rtpReceiver = _ref6.rtpReceiver;\n\n                if (rtpReceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpReceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", rtpReceiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref7) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref7.sctpStreamParameters, label = _ref7.label, protocol = _ref7.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation({\n                  oldDataChannelSpec: true\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref8) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref8.localDtlsRole, localSdpObject = _ref8.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Chrome67';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Chrome67();\n      };\n    }\n  }]);\n\n  return Chrome67;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Chrome67 = Chrome67;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Chrome67.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome70.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome70.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\n\nvar logger = new Logger_1.Logger('Chrome70');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Chrome70 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Chrome70, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Chrome70);\n\n  function Chrome70() {\n    var _this;\n\n    _classCallCheck(this, Chrome70);\n\n    _this = _super.call(this); // Map of RTCTransceivers indexed by MID.\n\n    _this._mapMidTransceiver = new Map(); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Chrome70, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'unified-plan'\n                });\n                _context.prev = 2;\n                pc.addTransceiver('audio');\n                pc.addTransceiver('video');\n                _context.next = 7;\n                return pc.createOffer();\n\n              case 7:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 14]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require',\n        sdpSemantics: 'unified-plan'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, hackVp9Svc, layers, parameters, idx, encoding, desiredEncoding, localId, _idx, _iterator, _step, _encoding, answer;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n                mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n                transceiver = this._pc.addTransceiver(track, {\n                  direction: 'sendonly',\n                  streams: [this._sendStream]\n                });\n                _context6.next = 11;\n                return this._pc.createOffer();\n\n              case 11:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n\n                if (this._transportReady) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                _context6.next = 16;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 16:\n                if (encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling legacy simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n                  sdpUnifiedPlanUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                } // Special case for VP9 with SVC.\n\n\n                hackVp9Svc = false;\n                layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\n\n                if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n                  logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n                  hackVp9Svc = true;\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n                  sdpUnifiedPlanUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    numStreams: layers.spatialLayers\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 23;\n                return this._pc.setLocalDescription(offer);\n\n              case 23:\n                if (!encodings) {\n                  _context6.next = 38;\n                  break;\n                }\n\n                logger.debug('send() | applying given encodings');\n                parameters = transceiver.sender.getParameters();\n                idx = 0;\n\n              case 27:\n                if (!(idx < (parameters.encodings || []).length)) {\n                  _context6.next = 36;\n                  break;\n                }\n\n                encoding = parameters.encodings[idx];\n                desiredEncoding = encodings[idx]; // Should not happen but just in case.\n\n                if (desiredEncoding) {\n                  _context6.next = 32;\n                  break;\n                }\n\n                return _context6.abrupt(\"break\", 36);\n\n              case 32:\n                parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);\n\n              case 33:\n                ++idx;\n                _context6.next = 27;\n                break;\n\n              case 36:\n                _context6.next = 38;\n                return transceiver.sender.setParameters(parameters);\n\n              case 38:\n                // We can now get the transceiver.mid.\n                localId = transceiver.mid; // Set MID.\n\n                sendingRtpParameters.mid = localId;\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx]; // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (_idx = 0; _idx < sendingRtpParameters.encodings.length; ++_idx) {\n                    if (encodings[_idx]) Object.assign(sendingRtpParameters.encodings[_idx], encodings[_idx]);\n                  }\n                } // Hack for VP9 SVC.\n\n\n                if (hackVp9Svc) {\n                  sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];\n                } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n                // each encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      _encoding = _step.value;\n                      _encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  reuseMid: mediaSectionIdx.reuseMid,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 52;\n                return this._pc.setRemoteDescription(answer);\n\n              case 52:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: transceiver.sender\n                });\n\n              case 54:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                transceiver.sender.replaceTrack(null);\n\n                this._pc.removeTrack(transceiver.sender);\n\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.next = 14;\n                return this._pc.setLocalDescription(offer);\n\n              case 14:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 18;\n                return this._pc.setRemoteDescription(answer);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                _context8.next = 7;\n                return transceiver.sender.replaceTrack(track);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", transceiver.sender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, offer, answer, localSdpObject, answerMediaObject, transceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n\n                this._remoteSdp.receive({\n                  mid: localId,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context13.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === localId;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                _context13.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                transceiver = this._pc.getTransceivers().find(function (t) {\n                  return t.mid === localId;\n                });\n\n                if (transceiver) {\n                  _context13.next = 25;\n                  break;\n                }\n\n                throw new Error('new RTCRtpTransceiver not found');\n\n              case 25:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: transceiver.receiver.track,\n                  rtpReceiver: transceiver.receiver\n                });\n\n              case 27:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context14.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 16;\n                return this._pc.setLocalDescription(answer);\n\n              case 16:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", transceiver.receiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref5) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation();\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref6) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Chrome70';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Chrome70();\n      };\n    }\n  }]);\n\n  return Chrome70;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Chrome70 = Chrome70;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Chrome70.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Chrome74.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Chrome74.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\n\nvar logger = new Logger_1.Logger('Chrome74');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Chrome74 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Chrome74, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Chrome74);\n\n  function Chrome74() {\n    var _this;\n\n    _classCallCheck(this, Chrome74);\n\n    _this = _super.call(this); // Map of RTCTransceivers indexed by MID.\n\n    _this._mapMidTransceiver = new Map(); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Chrome74, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'unified-plan'\n                });\n                _context.prev = 2;\n                pc.addTransceiver('audio');\n                pc.addTransceiver('video');\n                _context.next = 7;\n                return pc.createOffer();\n\n              case 7:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 14]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require',\n        sdpSemantics: 'unified-plan'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, hackVp9Svc, layers, localId, newEncodings, _iterator, _step, encoding, answer;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (encodings && encodings.length > 1) {\n                  encodings.forEach(function (encoding, idx) {\n                    encoding.rid = \"r\".concat(idx);\n                  });\n                }\n\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n                mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n                transceiver = this._pc.addTransceiver(track, {\n                  direction: 'sendonly',\n                  streams: [this._sendStream],\n                  sendEncodings: encodings\n                });\n                _context6.next = 12;\n                return this._pc.createOffer();\n\n              case 12:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n\n                if (this._transportReady) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 17:\n                // Special case for VP9 with SVC.\n                hackVp9Svc = false;\n                layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\n\n                if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\n                  logger.debug('send() | enabling legacy simulcast for VP9 SVC');\n                  hackVp9Svc = true;\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n                  sdpUnifiedPlanUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    numStreams: layers.spatialLayers\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 23;\n                return this._pc.setLocalDescription(offer);\n\n              case 23:\n                // We can now get the transceiver.mid.\n                localId = transceiver.mid; // Set MID.\n\n                sendingRtpParameters.mid = localId;\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx]; // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings by parsing the SDP offer if no encodings are given.\n\n                if (!encodings) {\n                  sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                    offerMediaObject: offerMediaObject\n                  });\n                } // Set RTP encodings by parsing the SDP offer and complete them with given\n                // one if just a single encoding has been given.\n                else if (encodings.length === 1) {\n                    newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                      offerMediaObject: offerMediaObject\n                    });\n                    Object.assign(newEncodings[0], encodings[0]); // Hack for VP9 SVC.\n\n                    if (hackVp9Svc) newEncodings = [newEncodings[0]];\n                    sendingRtpParameters.encodings = newEncodings;\n                  } // Otherwise if more than 1 encoding are given use them verbatim.\n                  else {\n                      sendingRtpParameters.encodings = encodings;\n                    } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n                // each encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  reuseMid: mediaSectionIdx.reuseMid,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions,\n                  extmapAllowMixed: true\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 35;\n                return this._pc.setRemoteDescription(answer);\n\n              case 35:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: transceiver.sender\n                });\n\n              case 37:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                transceiver.sender.replaceTrack(null);\n\n                this._pc.removeTrack(transceiver.sender);\n\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.next = 14;\n                return this._pc.setLocalDescription(offer);\n\n              case 14:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 18;\n                return this._pc.setRemoteDescription(answer);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                _context8.next = 7;\n                return transceiver.sender.replaceTrack(track);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", transceiver.sender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, offer, answer, localSdpObject, answerMediaObject, transceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n\n                this._remoteSdp.receive({\n                  mid: localId,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context13.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === localId;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                _context13.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                transceiver = this._pc.getTransceivers().find(function (t) {\n                  return t.mid === localId;\n                });\n\n                if (transceiver) {\n                  _context13.next = 25;\n                  break;\n                }\n\n                throw new Error('new RTCRtpTransceiver not found');\n\n              case 25:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: transceiver.receiver.track,\n                  rtpReceiver: transceiver.receiver\n                });\n\n              case 27:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context14.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 16;\n                return this._pc.setLocalDescription(answer);\n\n              case 16:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", transceiver.receiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref5) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation();\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref6) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Chrome74';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Chrome74();\n      };\n    }\n  }]);\n\n  return Chrome74;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Chrome74 = Chrome74;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Chrome74.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Edge11.js":
/*!**************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Edge11.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar edgeUtils = __webpack_require__(/*! ./ortc/edgeUtils */ \"./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar logger = new Logger_1.Logger('Edge11');\n\nvar Edge11 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Edge11, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Edge11);\n\n  function Edge11() {\n    var _this;\n\n    _classCallCheck(this, Edge11);\n\n    _this = _super.call(this); // Map of RTCRtpSenders indexed by id.\n\n    _this._rtpSenders = new Map(); // Map of RTCRtpReceivers indexed by id.\n\n    _this._rtpReceivers = new Map(); // Next localId for sending tracks.\n\n    _this._nextSendLocalId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Edge11, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close the ICE gatherer.\n      // NOTE: Not yet implemented by Edge.\n\n      try {\n        this._iceGatherer.close();\n      } catch (error) {} // Close the ICE transport.\n\n\n      try {\n        this._iceTransport.stop();\n      } catch (error) {} // Close the DTLS transport.\n\n\n      try {\n        this._dtlsTransport.stop();\n      } catch (error) {} // Close RTCRtpSenders.\n\n\n      var _iterator = _createForOfIteratorHelper(this._rtpSenders.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rtpSender = _step.value;\n\n          try {\n            rtpSender.stop();\n          } catch (error) {}\n        } // Close RTCRtpReceivers.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this._rtpReceivers.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var rtpReceiver = _step2.value;\n\n          try {\n            rtpReceiver.stop();\n          } catch (error) {}\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                return _context.abrupt(\"return\", edgeUtils.getCapabilities());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: {\n                    OS: 0,\n                    MIS: 0\n                  }\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._remoteIceParameters = iceParameters;\n      this._remoteIceCandidates = iceCandidates;\n      this._remoteDtlsParameters = dtlsParameters;\n      this._cname = \"CNAME-\".concat(utils.generateRandomNumber());\n\n      this._setIceGatherer({\n        iceServers: iceServers,\n        iceTransportPolicy: iceTransportPolicy\n      });\n\n      this._setIceTransport();\n\n      this._setDtlsTransport();\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not supported');\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var _iterator3, _step3, candidate;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()');\n                this._remoteIceParameters = iceParameters;\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                logger.debug('restartIce() | calling iceTransport.start()');\n\n                this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');\n\n                _iterator3 = _createForOfIteratorHelper(this._remoteIceCandidates);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    candidate = _step3.value;\n\n                    this._iceTransport.addRemoteCandidate(candidate);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                this._iceTransport.addRemoteCandidate({});\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._iceTransport.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _ref2) {\n        var track, encodings, codecOptions, codec, rtpSender, rtpParameters, useRtx, _iterator4, _step4, encoding, edgeRtpParameters, localId;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (this._transportReady) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                _context6.next = 5;\n                return this._setupTransport({\n                  localDtlsRole: 'server'\n                });\n\n              case 5:\n                logger.debug('send() | calling new RTCRtpSender()');\n                rtpSender = new RTCRtpSender(track, this._dtlsTransport);\n                rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n                rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);\n                useRtx = rtpParameters.codecs.some(function (_codec) {\n                  return /.+\\/rtx$/i.test(_codec.mimeType);\n                });\n                if (!encodings) encodings = [{}];\n                _iterator4 = _createForOfIteratorHelper(encodings);\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    encoding = _step4.value;\n                    encoding.ssrc = utils.generateRandomNumber();\n                    if (useRtx) encoding.rtx = {\n                      ssrc: utils.generateRandomNumber()\n                    };\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n\n                rtpParameters.encodings = encodings; // Fill RTCRtpParameters.rtcp.\n\n                rtpParameters.rtcp = {\n                  cname: this._cname,\n                  reducedSize: true,\n                  mux: true\n                }; // NOTE: Convert our standard RTCRtpParameters into those that Edge\n                // expects.\n\n                edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n                logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);\n                _context6.next = 19;\n                return rtpSender.send(edgeRtpParameters);\n\n              case 19:\n                localId = String(this._nextSendLocalId);\n                this._nextSendLocalId++; // Store it.\n\n                this._rtpSenders.set(localId, rtpSender);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: rtpParameters,\n                  rtpSender: rtpSender\n                });\n\n              case 23:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var rtpSender;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                logger.debug('stopSending() [localId:%s]', localId);\n                rtpSender = this._rtpSenders.get(localId);\n\n                if (rtpSender) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error('RTCRtpSender not found');\n\n              case 4:\n                this._rtpSenders[\"delete\"](localId);\n\n                _context7.prev = 5;\n                logger.debug('stopSending() | calling rtpSender.stop()');\n                rtpSender.stop();\n                _context7.next = 14;\n                break;\n\n              case 10:\n                _context7.prev = 10;\n                _context7.t0 = _context7[\"catch\"](5);\n                logger.warn('stopSending() | rtpSender.stop() failed:%o', _context7.t0);\n                throw _context7.t0;\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 10]]);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var rtpSender;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                rtpSender = this._rtpSenders.get(localId);\n\n                if (rtpSender) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                throw new Error('RTCRtpSender not found');\n\n              case 4:\n                rtpSender.setTrack(track);\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                rtpSender = this._rtpSenders.get(localId);\n\n                if (rtpSender) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new Error('RTCRtpSender not found');\n\n              case 4:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 8;\n                return rtpSender.setParameters(parameters);\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                rtpSender = this._rtpSenders.get(localId);\n\n                if (rtpSender) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new Error('RTCRtpSender not found');\n\n              case 4:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 8;\n                return rtpSender.setParameters(parameters);\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var rtpSender;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                rtpSender = this._rtpSenders.get(localId);\n\n                if (rtpSender) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new Error('RTCRtpSender not found');\n\n              case 3:\n                return _context11.abrupt(\"return\", rtpSender.getStats());\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      options) {\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref3) {\n        var trackId, kind, rtpParameters, rtpReceiver, edgeRtpParameters, localId;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref3.trackId, kind = _ref3.kind, rtpParameters = _ref3.rtpParameters;\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n\n                if (this._transportReady) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                _context13.next = 5;\n                return this._setupTransport({\n                  localDtlsRole: 'server'\n                });\n\n              case 5:\n                logger.debug('receive() | calling new RTCRtpReceiver()');\n                rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\n                rtpReceiver.addEventListener('error', function (event) {\n                  logger.error('rtpReceiver \"error\" event [event:%o]', event);\n                }); // NOTE: Convert our standard RTCRtpParameters into those that Edge\n                // expects.\n\n                edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\n                logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);\n                _context13.next = 12;\n                return rtpReceiver.receive(edgeRtpParameters);\n\n              case 12:\n                localId = trackId; // Store it.\n\n                this._rtpReceivers.set(localId, rtpReceiver);\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: rtpReceiver.track,\n                  rtpReceiver: rtpReceiver\n                });\n\n              case 15:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var rtpReceiver;\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                rtpReceiver = this._rtpReceivers.get(localId);\n\n                if (rtpReceiver) {\n                  _context14.next = 4;\n                  break;\n                }\n\n                throw new Error('RTCRtpReceiver not found');\n\n              case 4:\n                this._rtpReceivers[\"delete\"](localId);\n\n                try {\n                  logger.debug('stopReceiving() | calling rtpReceiver.stop()');\n                  rtpReceiver.stop();\n                } catch (error) {\n                  logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);\n                }\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var rtpReceiver;\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                rtpReceiver = this._rtpReceivers.get(localId);\n\n                if (rtpReceiver) {\n                  _context15.next = 3;\n                  break;\n                }\n\n                throw new Error('RTCRtpReceiver not found');\n\n              case 3:\n                return _context15.abrupt(\"return\", rtpReceiver.getStats());\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      options) {\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setIceGatherer\",\n    value: function _setIceGatherer(_ref4) {\n      var iceServers = _ref4.iceServers,\n          iceTransportPolicy = _ref4.iceTransportPolicy;\n      var iceGatherer = new RTCIceGatherer({\n        iceServers: iceServers || [],\n        gatherPolicy: iceTransportPolicy || 'all'\n      });\n      iceGatherer.addEventListener('error', function (event) {\n        logger.error('iceGatherer \"error\" event [event:%o]', event);\n      }); // NOTE: Not yet implemented by Edge, which starts gathering automatically.\n\n      try {\n        iceGatherer.gather();\n      } catch (error) {\n        logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());\n      }\n\n      this._iceGatherer = iceGatherer;\n    }\n  }, {\n    key: \"_setIceTransport\",\n    value: function _setIceTransport() {\n      var _this2 = this;\n\n      var iceTransport = new RTCIceTransport(this._iceGatherer); // NOTE: Not yet implemented by Edge.\n\n      iceTransport.addEventListener('statechange', function () {\n        switch (iceTransport.state) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      }); // NOTE: Not standard, but implemented by Edge.\n\n      iceTransport.addEventListener('icestatechange', function () {\n        switch (iceTransport.state) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n      iceTransport.addEventListener('candidatepairchange', function (event) {\n        logger.debug('iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\n      });\n      this._iceTransport = iceTransport;\n    }\n  }, {\n    key: \"_setDtlsTransport\",\n    value: function _setDtlsTransport() {\n      var _this3 = this;\n\n      var dtlsTransport = new RTCDtlsTransport(this._iceTransport); // NOTE: Not yet implemented by Edge.\n\n      dtlsTransport.addEventListener('statechange', function () {\n        logger.debug('dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\n      }); // NOTE: Not standard, but implemented by Edge.\n\n      dtlsTransport.addEventListener('dtlsstatechange', function () {\n        logger.debug('dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\n        if (dtlsTransport.state === 'closed') _this3.emit('@connectionstatechange', 'closed');\n      });\n      dtlsTransport.addEventListener('error', function (event) {\n        logger.error('dtlsTransport \"error\" event [event:%o]', event);\n      });\n      this._dtlsTransport = dtlsTransport;\n    }\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref5) {\n        var localDtlsRole, dtlsParameters, _iterator5, _step5, candidate;\n\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref5.localDtlsRole;\n                logger.debug('_setupTransport()'); // Get our local DTLS parameters.\n\n                dtlsParameters = this._dtlsTransport.getLocalParameters();\n                dtlsParameters.role = localDtlsRole; // Need to tell the remote transport about our parameters.\n\n                _context17.next = 6;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 6:\n                // Start the RTCIceTransport.\n                this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling'); // Add remote ICE candidates.\n\n\n                _iterator5 = _createForOfIteratorHelper(this._remoteIceCandidates);\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    candidate = _step5.value;\n\n                    this._iceTransport.addRemoteCandidate(candidate);\n                  } // Also signal a 'complete' candidate as per spec.\n                  // NOTE: It should be {complete: true} but Edge prefers {}.\n                  // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport\n                  // won't enter the 'completed' state.\n\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n                this._iceTransport.addRemoteCandidate({}); // NOTE: Edge does not like SHA less than 256.\n\n\n                this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter(function (fingerprint) {\n                  return fingerprint.algorithm === 'sha-256' || fingerprint.algorithm === 'sha-384' || fingerprint.algorithm === 'sha-512';\n                }); // Start the RTCDtlsTransport.\n\n                this._dtlsTransport.start(this._remoteDtlsParameters);\n\n                this._transportReady = true;\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Edge11';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Edge11();\n      };\n    }\n  }]);\n\n  return Edge11;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Edge11 = Edge11;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Edge11.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Firefox60.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Firefox60.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('Firefox60');\nvar SCTP_NUM_STREAMS = {\n  OS: 16,\n  MIS: 2048\n};\n\nvar Firefox60 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Firefox60, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Firefox60);\n\n  function Firefox60() {\n    var _this;\n\n    _classCallCheck(this, Firefox60);\n\n    _this = _super.call(this); // Map of RTCTransceivers indexed by MID.\n\n    _this._mapMidTransceiver = new Map(); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Firefox60, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, canvas, fakeStream, fakeVideoTrack, videoTransceiver, parameters, encodings, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require'\n                }); // NOTE: We need to add a real video track to get the RID extension mapping.\n\n                canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.\n\n                canvas.getContext('2d');\n                fakeStream = canvas.captureStream();\n                fakeVideoTrack = fakeStream.getVideoTracks()[0];\n                _context.prev = 6;\n                pc.addTransceiver('audio', {\n                  direction: 'sendrecv'\n                });\n                videoTransceiver = pc.addTransceiver(fakeVideoTrack, {\n                  direction: 'sendrecv'\n                });\n                parameters = videoTransceiver.sender.getParameters();\n                encodings = [{\n                  rid: 'r0',\n                  maxBitrate: 100000\n                }, {\n                  rid: 'r1',\n                  maxBitrate: 500000\n                }];\n                parameters.encodings = encodings;\n                _context.next = 14;\n                return videoTransceiver.sender.setParameters(parameters);\n\n              case 14:\n                _context.next = 16;\n                return pc.createOffer();\n\n              case 16:\n                offer = _context.sent;\n\n                try {\n                  canvas.remove();\n                } catch (error) {}\n\n                try {\n                  fakeVideoTrack.stop();\n                } catch (error) {}\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](6);\n\n                try {\n                  canvas.remove();\n                } catch (error2) {}\n\n                try {\n                  fakeVideoTrack.stop();\n                } catch (error2) {}\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 31:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[6, 25]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not supported');\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, reverseEncodings, sendingRtpParameters, sendingRemoteRtpParameters, transceiver, parameters, offer, localSdpObject, localId, offerMediaObject, newEncodings, _iterator, _step, encoding, answer;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (encodings && encodings.length > 1) {\n                  encodings.forEach(function (encoding, idx) {\n                    encoding.rid = \"r\".concat(idx);\n                  }); // Clone the encodings and reverse them because Firefox likes them\n                  // from high to low.\n\n                  reverseEncodings = utils.clone(encodings).reverse();\n                }\n\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec); // NOTE: Firefox fails sometimes to properly anticipate the closed media\n                // section that it should use, so don't reuse closed media sections.\n                //   https://github.com/versatica/mediasoup-client/issues/104\n                //\n                // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n\n                transceiver = this._pc.addTransceiver(track, {\n                  direction: 'sendonly',\n                  streams: [this._sendStream]\n                }); // NOTE: This is not spec compliants. Encodings should be given in addTransceiver\n                // second argument, but Firefox does not support it.\n\n                if (!reverseEncodings) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings = reverseEncodings;\n                _context6.next = 14;\n                return transceiver.sender.setParameters(parameters);\n\n              case 14:\n                _context6.next = 16;\n                return this._pc.createOffer();\n\n              case 16:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp); // In Firefox use DTLS role client even if we are the \"offerer\" since\n                // Firefox does not respect ICE-Lite.\n\n                if (this._transportReady) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                _context6.next = 21;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 21:\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 24;\n                return this._pc.setLocalDescription(offer);\n\n              case 24:\n                // We can now get the transceiver.mid.\n                localId = transceiver.mid; // Set MID.\n\n                sendingRtpParameters.mid = localId;\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings by parsing the SDP offer if no encodings are given.\n\n                if (!encodings) {\n                  sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                    offerMediaObject: offerMediaObject\n                  });\n                } // Set RTP encodings by parsing the SDP offer and complete them with given\n                // one if just a single encoding has been given.\n                else if (encodings.length === 1) {\n                    newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                      offerMediaObject: offerMediaObject\n                    });\n                    Object.assign(newEncodings[0], encodings[0]);\n                    sendingRtpParameters.encodings = newEncodings;\n                  } // Otherwise if more than 1 encoding are given use them verbatim.\n                  else {\n                      sendingRtpParameters.encodings = encodings;\n                    } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n                // each encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions,\n                  extmapAllowMixed: true\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 36;\n                return this._pc.setRemoteDescription(answer);\n\n              case 36:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: transceiver.sender\n                });\n\n              case 38:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                logger.debug('stopSending() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error('associated transceiver not found');\n\n              case 4:\n                transceiver.sender.replaceTrack(null);\n\n                this._pc.removeTrack(transceiver.sender); // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n                // method.\n                // this._remoteSdp!.closeMediaSection(transceiver.mid);\n\n\n                this._remoteSdp.disableMediaSection(transceiver.mid);\n\n                _context7.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.next = 13;\n                return this._pc.setLocalDescription(offer);\n\n              case 13:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 17;\n                return this._pc.setRemoteDescription(answer);\n\n              case 17:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                _context8.next = 7;\n                return transceiver.sender.replaceTrack(track);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated transceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters(); // NOTE: We require encodings given from low to high, however Firefox\n                // requires them in reverse order, so do magic here.\n\n                spatialLayer = parameters.encodings.length - 1 - spatialLayer;\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx >= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 10;\n                return transceiver.sender.setParameters(parameters);\n\n              case 10:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", transceiver.sender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, offer, answer, localSdpObject, answerMediaObject, transceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n\n                this._remoteSdp.receive({\n                  mid: localId,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context13.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === localId;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                _context13.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                transceiver = this._pc.getTransceivers().find(function (t) {\n                  return t.mid === localId;\n                });\n\n                if (transceiver) {\n                  _context13.next = 25;\n                  break;\n                }\n\n                throw new Error('new RTCRtpTransceiver not found');\n\n              case 25:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: transceiver.receiver.track,\n                  rtpReceiver: transceiver.receiver\n                });\n\n              case 27:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context14.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 16;\n                return this._pc.setLocalDescription(answer);\n\n              case 16:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", transceiver.receiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref5) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation();\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref6) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Firefox60';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Firefox60();\n      };\n    }\n  }]);\n\n  return Firefox60;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Firefox60 = Firefox60;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Firefox60.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./node_modules/mediasoup-client/lib/EnhancedEventEmitter.js\");\n\nvar HandlerInterface = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(HandlerInterface, _EnhancedEventEmitter);\n\n  var _super = _createSuper(HandlerInterface);\n\n  /**\n   * @emits @connect - (\n   *     { dtlsParameters: DtlsParameters },\n   *     callback: Function,\n   *     errback: Function\n   *   )\n   * @emits @connectionstatechange - (connectionState: ConnectionState)\n   */\n  function HandlerInterface() {\n    _classCallCheck(this, HandlerInterface);\n\n    return _super.call(this);\n  }\n\n  return HandlerInterface;\n}(EnhancedEventEmitter_1.EnhancedEventEmitter);\n\nexports.HandlerInterface = HandlerInterface;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ReactNative.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ReactNative.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar errors_1 = __webpack_require__(/*! ../errors */ \"./node_modules/mediasoup-client/lib/errors.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('ReactNative');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar ReactNative = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(ReactNative, _HandlerInterface_1$H);\n\n  var _super = _createSuper(ReactNative);\n\n  function ReactNative() {\n    var _this;\n\n    _classCallCheck(this, ReactNative);\n\n    _this = _super.call(this); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Map of sending MediaStreamTracks indexed by localId.\n\n    _this._mapSendLocalIdTrack = new Map(); // Next sending localId.\n\n    _this._nextSendLocalId = 0; // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n\n    _this._mapRecvLocalIdInfo = new Map(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(ReactNative, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'plan-b'\n                });\n                _context.prev = 2;\n                _context.next = 5;\n                return pc.createOffer({\n                  offerToReceiveAudio: true,\n                  offerToReceiveVideo: true\n                });\n\n              case 5:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 12]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        planB: true\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require',\n        sdpSemantics: 'plan-b'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (codec) {\n                  logger.warn('send() | codec selection is not available in %s handler', this.name);\n                }\n\n                this._sendStream.addTrack(track);\n\n                this._pc.addStream(this._sendStream);\n\n                _context6.next = 8;\n                return this._pc.createOffer();\n\n              case 8:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n\n                if (this._transportReady) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 17:\n                if (track.kind === 'video' && encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media.find(function (m) {\n                    return m.type === 'video';\n                  });\n                  sdpPlanBUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    track: track,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 21;\n                return this._pc.setLocalDescription(offer);\n\n              case 21:\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === track.kind;\n                }); // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject,\n                  track: track\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                    if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                  }\n                } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n                // each encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 32;\n                return this._pc.setRemoteDescription(answer);\n\n              case 32:\n                localId = String(this._nextSendLocalId);\n                this._nextSendLocalId++; // Insert into the map.\n\n                this._mapSendLocalIdTrack.set(localId, track);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters\n                });\n\n              case 36:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var track, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                track = this._mapSendLocalIdTrack.get(localId);\n\n                if (track) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('track not found');\n\n              case 5:\n                this._mapSendLocalIdTrack[\"delete\"](localId);\n\n                this._sendStream.removeTrack(track);\n\n                this._pc.addStream(this._sendStream);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.prev = 12;\n                _context7.next = 15;\n                return this._pc.setLocalDescription(offer);\n\n              case 15:\n                _context7.next = 23;\n                break;\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](12);\n\n                if (!(this._sendStream.getTracks().length === 0)) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());\n                return _context7.abrupt(\"return\");\n\n              case 22:\n                throw _context7.t0;\n\n              case 23:\n                if (!(this._pc.signalingState === 'stable')) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 25:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 29;\n                return this._pc.setRemoteDescription(answer);\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[12, 17]]);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      localId, track) {\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, mid, streamId, offer, answer, localSdpObject, answerMediaObject, stream, track;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = trackId;\n                mid = kind;\n                streamId = rtpParameters.rtcp.cname; // NOTE: In React-Native we cannot reuse the same remote MediaStream for new\n                // remote tracks. This is because react-native-webrtc does not react on new\n                // tracks generated within already existing streams, so force the streamId\n                // to be different.\n\n                logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\n                streamId += \"-hack-\".concat(utils.generateRandomNumber());\n\n                this._remoteSdp.receive({\n                  mid: mid,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: streamId,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 13;\n                return this._pc.setRemoteDescription(offer);\n\n              case 13:\n                _context13.next = 15;\n                return this._pc.createAnswer();\n\n              case 15:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === mid;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 23;\n                  break;\n                }\n\n                _context13.next = 23;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 23:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 26;\n                return this._pc.setLocalDescription(answer);\n\n              case 26:\n                stream = this._pc.getRemoteStreams().find(function (s) {\n                  return s.id === streamId;\n                });\n                track = stream.getTrackById(localId);\n\n                if (track) {\n                  _context13.next = 30;\n                  break;\n                }\n\n                throw new Error('remote track not found');\n\n              case 30:\n                // Insert into the map.\n                this._mapRecvLocalIdInfo.set(localId, {\n                  mid: mid,\n                  rtpParameters: rtpParameters\n                });\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: track\n                });\n\n              case 32:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var _ref5, mid, rtpParameters, offer, answer;\n\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref5.mid, rtpParameters = _ref5.rtpParameters; // Remove from the map.\n\n                this._mapRecvLocalIdInfo[\"delete\"](localId);\n\n                this._remoteSdp.planBStopReceiving({\n                  mid: mid,\n                  offerRtpParameters: rtpParameters\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context14.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 15;\n                return this._pc.setLocalDescription(answer);\n\n              case 15:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                throw new errors_1.UnsupportedError('not implemented');\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref6) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref6.sctpStreamParameters, label = _ref6.label, protocol = _ref6.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmitTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation({\n                  oldDataChannelSpec: true\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref7) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref7.localDtlsRole, localSdpObject = _ref7.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'ReactNative';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new ReactNative();\n      };\n    }\n  }]);\n\n  return ReactNative;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.ReactNative = ReactNative;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/ReactNative.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari11.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari11.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpPlanBUtils = __webpack_require__(/*! ./sdp/planBUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('Safari11');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Safari11 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Safari11, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Safari11);\n\n  function Safari11() {\n    var _this;\n\n    _classCallCheck(this, Safari11);\n\n    _this = _super.call(this); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Map of RTCRtpSender indexed by localId.\n\n    _this._mapSendLocalIdRtpSender = new Map(); // Next sending localId.\n\n    _this._nextSendLocalId = 0; // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n\n    _this._mapRecvLocalIdInfo = new Map(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Safari11, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require',\n                  sdpSemantics: 'plan-b'\n                });\n                _context.prev = 2;\n                _context.next = 5;\n                return pc.createOffer({\n                  offerToReceiveAudio: true,\n                  offerToReceiveVideo: true\n                });\n\n              case 5:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 12]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters,\n        planB: true\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, offer, localSdpObject, offerMediaObject, sendingRtpParameters, sendingRemoteRtpParameters, idx, _iterator, _step, encoding, answer, localId, rtpSender;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n                if (codec) {\n                  logger.warn('send() | codec selection is not available in %s handler', this.name);\n                }\n\n                this._sendStream.addTrack(track);\n\n                this._pc.addTrack(track, this._sendStream);\n\n                _context6.next = 8;\n                return this._pc.createOffer();\n\n              case 8:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n\n                if (this._transportReady) {\n                  _context6.next = 17;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 17:\n                if (track.kind === 'video' && encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media.find(function (m) {\n                    return m.type === 'video';\n                  });\n                  sdpPlanBUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    track: track,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 21;\n                return this._pc.setLocalDescription(offer);\n\n              case 21:\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === track.kind;\n                }); // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject,\n                  track: track\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                    if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                  }\n                } // If VP8 and there is effective simulcast, add scalabilityMode to each\n                // encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 32;\n                return this._pc.setRemoteDescription(answer);\n\n              case 32:\n                localId = String(this._nextSendLocalId);\n                this._nextSendLocalId++;\n                rtpSender = this._pc.getSenders().find(function (s) {\n                  return s.track === track;\n                }); // Insert into the map.\n\n                this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: rtpSender\n                });\n\n              case 37:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var rtpSender, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 4:\n                if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);\n\n                this._mapSendLocalIdRtpSender[\"delete\"](localId);\n\n                _context7.next = 8;\n                return this._pc.createOffer();\n\n              case 8:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.prev = 10;\n                _context7.next = 13;\n                return this._pc.setLocalDescription(offer);\n\n              case 13:\n                _context7.next = 21;\n                break;\n\n              case 15:\n                _context7.prev = 15;\n                _context7.t0 = _context7[\"catch\"](10);\n\n                if (!(this._sendStream.getTracks().length === 0)) {\n                  _context7.next = 20;\n                  break;\n                }\n\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', _context7.t0.toString());\n                return _context7.abrupt(\"return\");\n\n              case 20:\n                throw _context7.t0;\n\n              case 21:\n                if (!(this._pc.signalingState === 'stable')) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 23:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 27;\n                return this._pc.setRemoteDescription(answer);\n\n              case 27:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[10, 15]]);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var rtpSender, oldTrack;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                oldTrack = rtpSender.track;\n                _context8.next = 8;\n                return rtpSender.replaceTrack(track);\n\n              case 8:\n                // Remove the old track from the local stream.\n                if (oldTrack) this._sendStream.removeTrack(oldTrack); // Add the new track to the local stream.\n\n                if (track) this._sendStream.addTrack(track);\n\n              case 10:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 9;\n                return rtpSender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var rtpSender, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 5:\n                parameters = rtpSender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return rtpSender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var rtpSender;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n                if (rtpSender) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpSender not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", rtpSender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, mid, offer, answer, localSdpObject, answerMediaObject, rtpReceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = trackId;\n                mid = kind;\n\n                this._remoteSdp.receive({\n                  mid: mid,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context13.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === mid;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 20;\n                  break;\n                }\n\n                _context13.next = 20;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 20:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 23;\n                return this._pc.setLocalDescription(answer);\n\n              case 23:\n                rtpReceiver = this._pc.getReceivers().find(function (r) {\n                  return r.track && r.track.id === localId;\n                });\n\n                if (rtpReceiver) {\n                  _context13.next = 26;\n                  break;\n                }\n\n                throw new Error('new RTCRtpReceiver not');\n\n              case 26:\n                // Insert into the map.\n                this._mapRecvLocalIdInfo.set(localId, {\n                  mid: mid,\n                  rtpParameters: rtpParameters,\n                  rtpReceiver: rtpReceiver\n                });\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: rtpReceiver.track,\n                  rtpReceiver: rtpReceiver\n                });\n\n              case 28:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var _ref5, mid, rtpParameters, offer, answer;\n\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                _ref5 = this._mapRecvLocalIdInfo.get(localId) || {}, mid = _ref5.mid, rtpParameters = _ref5.rtpParameters; // Remove from the map.\n\n                this._mapRecvLocalIdInfo[\"delete\"](localId);\n\n                this._remoteSdp.planBStopReceiving({\n                  mid: mid,\n                  offerRtpParameters: rtpParameters\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context14.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 15;\n                return this._pc.setLocalDescription(answer);\n\n              case 15:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var _ref6, rtpReceiver;\n\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                _ref6 = this._mapRecvLocalIdInfo.get(localId) || {}, rtpReceiver = _ref6.rtpReceiver;\n\n                if (rtpReceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpReceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", rtpReceiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref7) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref7.sctpStreamParameters, label = _ref7.label, protocol = _ref7.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation({\n                  oldDataChannelSpec: true\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref8) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref8.localDtlsRole, localSdpObject = _ref8.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Safari11';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Safari11();\n      };\n    }\n  }]);\n\n  return Safari11;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Safari11 = Safari11;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Safari11.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/Safari12.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/Safari12.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar ortc = __webpack_require__(/*! ../ortc */ \"./node_modules/mediasoup-client/lib/ortc.js\");\n\nvar sdpCommonUtils = __webpack_require__(/*! ./sdp/commonUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js\");\n\nvar sdpUnifiedPlanUtils = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js\");\n\nvar HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\");\n\nvar RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js\");\n\nvar logger = new Logger_1.Logger('Safari12');\nvar SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nvar Safari12 = /*#__PURE__*/function (_HandlerInterface_1$H) {\n  _inherits(Safari12, _HandlerInterface_1$H);\n\n  var _super = _createSuper(Safari12);\n\n  function Safari12() {\n    var _this;\n\n    _classCallCheck(this, Safari12);\n\n    _this = _super.call(this); // Map of RTCTransceivers indexed by MID.\n\n    _this._mapMidTransceiver = new Map(); // Local stream for sending.\n\n    _this._sendStream = new MediaStream(); // Whether a DataChannel m=application section has been created.\n\n    _this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    _this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    _this._transportReady = false;\n    return _this;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  _createClass(Safari12, [{\n    key: \"close\",\n    value: function close() {\n      logger.debug('close()'); // Close RTCPeerConnection.\n\n      if (this._pc) {\n        try {\n          this._pc.close();\n        } catch (error) {}\n      }\n    }\n  }, {\n    key: \"getNativeRtpCapabilities\",\n    value: function () {\n      var _getNativeRtpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var pc, offer, sdpObject, nativeRtpCapabilities;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger.debug('getNativeRtpCapabilities()');\n                pc = new RTCPeerConnection({\n                  iceServers: [],\n                  iceTransportPolicy: 'all',\n                  bundlePolicy: 'max-bundle',\n                  rtcpMuxPolicy: 'require'\n                });\n                _context.prev = 2;\n                pc.addTransceiver('audio');\n                pc.addTransceiver('video');\n                _context.next = 7;\n                return pc.createOffer();\n\n              case 7:\n                offer = _context.sent;\n\n                try {\n                  pc.close();\n                } catch (error) {}\n\n                sdpObject = sdpTransform.parse(offer.sdp);\n                nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n                  sdpObject: sdpObject\n                });\n                return _context.abrupt(\"return\", nativeRtpCapabilities);\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](2);\n\n                try {\n                  pc.close();\n                } catch (error2) {}\n\n                throw _context.t0;\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 14]]);\n      }));\n\n      function getNativeRtpCapabilities() {\n        return _getNativeRtpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeRtpCapabilities;\n    }()\n  }, {\n    key: \"getNativeSctpCapabilities\",\n    value: function () {\n      var _getNativeSctpCapabilities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger.debug('getNativeSctpCapabilities()');\n                return _context2.abrupt(\"return\", {\n                  numStreams: SCTP_NUM_STREAMS\n                });\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getNativeSctpCapabilities() {\n        return _getNativeSctpCapabilities.apply(this, arguments);\n      }\n\n      return getNativeSctpCapabilities;\n    }()\n  }, {\n    key: \"run\",\n    value: function run(_ref) {\n      var _this2 = this;\n\n      var direction = _ref.direction,\n          iceParameters = _ref.iceParameters,\n          iceCandidates = _ref.iceCandidates,\n          dtlsParameters = _ref.dtlsParameters,\n          sctpParameters = _ref.sctpParameters,\n          iceServers = _ref.iceServers,\n          iceTransportPolicy = _ref.iceTransportPolicy,\n          additionalSettings = _ref.additionalSettings,\n          proprietaryConstraints = _ref.proprietaryConstraints,\n          extendedRtpCapabilities = _ref.extendedRtpCapabilities;\n      logger.debug('run()');\n      this._direction = direction;\n      this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n        iceParameters: iceParameters,\n        iceCandidates: iceCandidates,\n        dtlsParameters: dtlsParameters,\n        sctpParameters: sctpParameters\n      });\n      this._sendingRtpParametersByKind = {\n        audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._sendingRemoteRtpParametersByKind = {\n        audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n        video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n      };\n      this._pc = new RTCPeerConnection(_objectSpread({\n        iceServers: iceServers || [],\n        iceTransportPolicy: iceTransportPolicy || 'all',\n        bundlePolicy: 'max-bundle',\n        rtcpMuxPolicy: 'require'\n      }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n      this._pc.addEventListener('iceconnectionstatechange', function () {\n        switch (_this2._pc.iceConnectionState) {\n          case 'checking':\n            _this2.emit('@connectionstatechange', 'connecting');\n\n            break;\n\n          case 'connected':\n          case 'completed':\n            _this2.emit('@connectionstatechange', 'connected');\n\n            break;\n\n          case 'failed':\n            _this2.emit('@connectionstatechange', 'failed');\n\n            break;\n\n          case 'disconnected':\n            _this2.emit('@connectionstatechange', 'disconnected');\n\n            break;\n\n          case 'closed':\n            _this2.emit('@connectionstatechange', 'closed');\n\n            break;\n        }\n      });\n    }\n  }, {\n    key: \"updateIceServers\",\n    value: function () {\n      var _updateIceServers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(iceServers) {\n        var configuration;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logger.debug('updateIceServers()');\n                configuration = this._pc.getConfiguration();\n                configuration.iceServers = iceServers;\n\n                this._pc.setConfiguration(configuration);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateIceServers(_x) {\n        return _updateIceServers.apply(this, arguments);\n      }\n\n      return updateIceServers;\n    }()\n  }, {\n    key: \"restartIce\",\n    value: function () {\n      var _restartIce = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(iceParameters) {\n        var offer, answer, _offer, _answer;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n                this._remoteSdp.updateIceParameters(iceParameters);\n\n                if (this._transportReady) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                if (!(this._direction === 'send')) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this._pc.createOffer({\n                  iceRestart: true\n                });\n\n              case 7:\n                offer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context4.next = 11;\n                return this._pc.setLocalDescription(offer);\n\n              case 11:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context4.next = 15;\n                return this._pc.setRemoteDescription(answer);\n\n              case 15:\n                _context4.next = 27;\n                break;\n\n              case 17:\n                _offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', _offer);\n                _context4.next = 21;\n                return this._pc.setRemoteDescription(_offer);\n\n              case 21:\n                _context4.next = 23;\n                return this._pc.createAnswer();\n\n              case 23:\n                _answer = _context4.sent;\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', _answer);\n                _context4.next = 27;\n                return this._pc.setLocalDescription(_answer);\n\n              case 27:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function restartIce(_x2) {\n        return _restartIce.apply(this, arguments);\n      }\n\n      return restartIce;\n    }()\n  }, {\n    key: \"getTransportStats\",\n    value: function () {\n      var _getTransportStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._pc.getStats());\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getTransportStats() {\n        return _getTransportStats.apply(this, arguments);\n      }\n\n      return getTransportStats;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var track, encodings, codecOptions, codec, sendingRtpParameters, sendingRemoteRtpParameters, mediaSectionIdx, transceiver, offer, localSdpObject, offerMediaObject, localId, idx, _iterator, _step, encoding, answer;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                track = _ref2.track, encodings = _ref2.encodings, codecOptions = _ref2.codecOptions, codec = _ref2.codec;\n\n                this._assertSendDirection();\n\n                logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n                sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n                sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]); // This may throw.\n\n                sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n                mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\n                transceiver = this._pc.addTransceiver(track, {\n                  direction: 'sendonly',\n                  streams: [this._sendStream]\n                });\n                _context6.next = 11;\n                return this._pc.createOffer();\n\n              case 11:\n                offer = _context6.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n\n                if (this._transportReady) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                _context6.next = 16;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 16:\n                if (encodings && encodings.length > 1) {\n                  logger.debug('send() | enabling legacy simulcast');\n                  localSdpObject = sdpTransform.parse(offer.sdp);\n                  offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\n                  sdpUnifiedPlanUtils.addLegacySimulcast({\n                    offerMediaObject: offerMediaObject,\n                    numStreams: encodings.length\n                  });\n                  offer = {\n                    type: 'offer',\n                    sdp: sdpTransform.write(localSdpObject)\n                  };\n                }\n\n                logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context6.next = 20;\n                return this._pc.setLocalDescription(offer);\n\n              case 20:\n                // We can now get the transceiver.mid.\n                localId = transceiver.mid; // Set MID.\n\n                sendingRtpParameters.mid = localId;\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx]; // Set RTCP CNAME.\n\n                sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n                  offerMediaObject: offerMediaObject\n                }); // Set RTP encodings.\n\n                sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n                  offerMediaObject: offerMediaObject\n                }); // Complete encodings with given values.\n\n                if (encodings) {\n                  for (idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                    if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n                  }\n                } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n                // each encoding.\n\n\n                if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n                  _iterator = _createForOfIteratorHelper(sendingRtpParameters.encodings);\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      encoding = _step.value;\n                      encoding.scalabilityMode = 'S1T3';\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                }\n\n                this._remoteSdp.send({\n                  offerMediaObject: offerMediaObject,\n                  reuseMid: mediaSectionIdx.reuseMid,\n                  offerRtpParameters: sendingRtpParameters,\n                  answerRtpParameters: sendingRemoteRtpParameters,\n                  codecOptions: codecOptions\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context6.next = 33;\n                return this._pc.setRemoteDescription(answer);\n\n              case 33:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context6.abrupt(\"return\", {\n                  localId: localId,\n                  rtpParameters: sendingRtpParameters,\n                  rtpSender: transceiver.sender\n                });\n\n              case 35:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function send(_x3) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"stopSending\",\n    value: function () {\n      var _stopSending = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('stopSending() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                transceiver.sender.replaceTrack(null);\n\n                this._pc.removeTrack(transceiver.sender);\n\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                _context7.next = 10;\n                return this._pc.createOffer();\n\n              case 10:\n                offer = _context7.sent;\n                logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context7.next = 14;\n                return this._pc.setLocalDescription(offer);\n\n              case 14:\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context7.next = 18;\n                return this._pc.setRemoteDescription(answer);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function stopSending(_x4) {\n        return _stopSending.apply(this, arguments);\n      }\n\n      return stopSending;\n    }()\n  }, {\n    key: \"replaceTrack\",\n    value: function () {\n      var _replaceTrack = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(localId, track) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._assertSendDirection();\n\n                if (track) {\n                  logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n                } else {\n                  logger.debug('replaceTrack() [localId:%s, no track]', localId);\n                }\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                _context8.next = 7;\n                return transceiver.sender.replaceTrack(track);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function replaceTrack(_x5, _x6) {\n        return _replaceTrack.apply(this, arguments);\n      }\n\n      return replaceTrack;\n    }()\n  }, {\n    key: \"setMaxSpatialLayer\",\n    value: function () {\n      var _setMaxSpatialLayer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(localId, spatialLayer) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n                });\n                _context9.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setMaxSpatialLayer(_x7, _x8) {\n        return _setMaxSpatialLayer.apply(this, arguments);\n      }\n\n      return setMaxSpatialLayer;\n    }()\n  }, {\n    key: \"setRtpEncodingParameters\",\n    value: function () {\n      var _setRtpEncodingParameters = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(localId, params) {\n        var transceiver, parameters;\n        return regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._assertSendDirection();\n\n                logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                parameters = transceiver.sender.getParameters();\n                parameters.encodings.forEach(function (encoding, idx) {\n                  parameters.encodings[idx] = _objectSpread(_objectSpread({}, encoding), params);\n                });\n                _context10.next = 9;\n                return transceiver.sender.setParameters(parameters);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setRtpEncodingParameters(_x9, _x10) {\n        return _setRtpEncodingParameters.apply(this, arguments);\n      }\n\n      return setRtpEncodingParameters;\n    }()\n  }, {\n    key: \"getSenderStats\",\n    value: function () {\n      var _getSenderStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this._assertSendDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context11.abrupt(\"return\", transceiver.sender.getStats());\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getSenderStats(_x11) {\n        return _getSenderStats.apply(this, arguments);\n      }\n\n      return getSenderStats;\n    }()\n  }, {\n    key: \"sendDataChannel\",\n    value: function () {\n      var _sendDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(_ref3) {\n        var ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority, options, dataChannel, offer, localSdpObject, offerMediaObject, answer, sctpStreamParameters;\n        return regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                ordered = _ref3.ordered, maxPacketLifeTime = _ref3.maxPacketLifeTime, maxRetransmits = _ref3.maxRetransmits, label = _ref3.label, protocol = _ref3.protocol, priority = _ref3.priority;\n\n                this._assertSendDirection();\n\n                options = {\n                  negotiated: true,\n                  id: this._nextSendSctpStreamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol,\n                  priority: priority\n                };\n                logger.debug('sendDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n                this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context12.next = 24;\n                  break;\n                }\n\n                _context12.next = 9;\n                return this._pc.createOffer();\n\n              case 9:\n                offer = _context12.sent;\n                localSdpObject = sdpTransform.parse(offer.sdp);\n                offerMediaObject = localSdpObject.media.find(function (m) {\n                  return m.type === 'application';\n                });\n\n                if (this._transportReady) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 15;\n                return this._setupTransport({\n                  localDtlsRole: 'server',\n                  localSdpObject: localSdpObject\n                });\n\n              case 15:\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n                _context12.next = 18;\n                return this._pc.setLocalDescription(offer);\n\n              case 18:\n                this._remoteSdp.sendSctpAssociation({\n                  offerMediaObject: offerMediaObject\n                });\n\n                answer = {\n                  type: 'answer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context12.next = 23;\n                return this._pc.setRemoteDescription(answer);\n\n              case 23:\n                this._hasDataChannelMediaSection = true;\n\n              case 24:\n                sctpStreamParameters = {\n                  streamId: options.id,\n                  ordered: options.ordered,\n                  maxPacketLifeTime: options.maxPacketLifeTime,\n                  maxRetransmits: options.maxRetransmits\n                };\n                return _context12.abrupt(\"return\", {\n                  dataChannel: dataChannel,\n                  sctpStreamParameters: sctpStreamParameters\n                });\n\n              case 26:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function sendDataChannel(_x12) {\n        return _sendDataChannel.apply(this, arguments);\n      }\n\n      return sendDataChannel;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(_ref4) {\n        var trackId, kind, rtpParameters, localId, offer, answer, localSdpObject, answerMediaObject, transceiver;\n        return regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                trackId = _ref4.trackId, kind = _ref4.kind, rtpParameters = _ref4.rtpParameters;\n\n                this._assertRecvDirection();\n\n                logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n                localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n\n                this._remoteSdp.receive({\n                  mid: localId,\n                  kind: kind,\n                  offerRtpParameters: rtpParameters,\n                  streamId: rtpParameters.rtcp.cname,\n                  trackId: trackId\n                });\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context13.next = 9;\n                return this._pc.setRemoteDescription(offer);\n\n              case 9:\n                _context13.next = 11;\n                return this._pc.createAnswer();\n\n              case 11:\n                answer = _context13.sent;\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                answerMediaObject = localSdpObject.media.find(function (m) {\n                  return String(m.mid) === localId;\n                }); // May need to modify codec parameters in the answer based on codec\n                // parameters in the offer.\n\n                sdpCommonUtils.applyCodecParameters({\n                  offerRtpParameters: rtpParameters,\n                  answerMediaObject: answerMediaObject\n                });\n                answer = {\n                  type: 'answer',\n                  sdp: sdpTransform.write(localSdpObject)\n                };\n\n                if (this._transportReady) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                _context13.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context13.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                transceiver = this._pc.getTransceivers().find(function (t) {\n                  return t.mid === localId;\n                });\n\n                if (transceiver) {\n                  _context13.next = 25;\n                  break;\n                }\n\n                throw new Error('new RTCRtpTransceiver not found');\n\n              case 25:\n                // Store in the map.\n                this._mapMidTransceiver.set(localId, transceiver);\n\n                return _context13.abrupt(\"return\", {\n                  localId: localId,\n                  track: transceiver.receiver.track,\n                  rtpReceiver: transceiver.receiver\n                });\n\n              case 27:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function receive(_x13) {\n        return _receive.apply(this, arguments);\n      }\n\n      return receive;\n    }()\n  }, {\n    key: \"stopReceiving\",\n    value: function () {\n      var _stopReceiving = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(localId) {\n        var transceiver, offer, answer;\n        return regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                logger.debug('stopReceiving() [localId:%s]', localId);\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 5:\n                this._remoteSdp.closeMediaSection(transceiver.mid);\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context14.next = 10;\n                return this._pc.setRemoteDescription(offer);\n\n              case 10:\n                _context14.next = 12;\n                return this._pc.createAnswer();\n\n              case 12:\n                answer = _context14.sent;\n                logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n                _context14.next = 16;\n                return this._pc.setLocalDescription(answer);\n\n              case 16:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function stopReceiving(_x14) {\n        return _stopReceiving.apply(this, arguments);\n      }\n\n      return stopReceiving;\n    }()\n  }, {\n    key: \"getReceiverStats\",\n    value: function () {\n      var _getReceiverStats = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(localId) {\n        var transceiver;\n        return regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this._assertRecvDirection();\n\n                transceiver = this._mapMidTransceiver.get(localId);\n\n                if (transceiver) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error('associated RTCRtpTransceiver not found');\n\n              case 4:\n                return _context15.abrupt(\"return\", transceiver.receiver.getStats());\n\n              case 5:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getReceiverStats(_x15) {\n        return _getReceiverStats.apply(this, arguments);\n      }\n\n      return getReceiverStats;\n    }()\n  }, {\n    key: \"receiveDataChannel\",\n    value: function () {\n      var _receiveDataChannel = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref5) {\n        var sctpStreamParameters, label, protocol, streamId, ordered, maxPacketLifeTime, maxRetransmits, options, dataChannel, offer, answer, localSdpObject;\n        return regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                sctpStreamParameters = _ref5.sctpStreamParameters, label = _ref5.label, protocol = _ref5.protocol;\n\n                this._assertRecvDirection();\n\n                streamId = sctpStreamParameters.streamId, ordered = sctpStreamParameters.ordered, maxPacketLifeTime = sctpStreamParameters.maxPacketLifeTime, maxRetransmits = sctpStreamParameters.maxRetransmits;\n                options = {\n                  negotiated: true,\n                  id: streamId,\n                  ordered: ordered,\n                  maxPacketLifeTime: maxPacketLifeTime,\n                  maxRetransmits: maxRetransmits,\n                  protocol: protocol\n                };\n                logger.debug('receiveDataChannel() [options:%o]', options);\n                dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n                // m=application section.\n\n                if (this._hasDataChannelMediaSection) {\n                  _context16.next = 23;\n                  break;\n                }\n\n                this._remoteSdp.receiveSctpAssociation();\n\n                offer = {\n                  type: 'offer',\n                  sdp: this._remoteSdp.getSdp()\n                };\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n                _context16.next = 12;\n                return this._pc.setRemoteDescription(offer);\n\n              case 12:\n                _context16.next = 14;\n                return this._pc.createAnswer();\n\n              case 14:\n                answer = _context16.sent;\n\n                if (this._transportReady) {\n                  _context16.next = 19;\n                  break;\n                }\n\n                localSdpObject = sdpTransform.parse(answer.sdp);\n                _context16.next = 19;\n                return this._setupTransport({\n                  localDtlsRole: 'client',\n                  localSdpObject: localSdpObject\n                });\n\n              case 19:\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n                _context16.next = 22;\n                return this._pc.setLocalDescription(answer);\n\n              case 22:\n                this._hasDataChannelMediaSection = true;\n\n              case 23:\n                return _context16.abrupt(\"return\", {\n                  dataChannel: dataChannel\n                });\n\n              case 24:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function receiveDataChannel(_x16) {\n        return _receiveDataChannel.apply(this, arguments);\n      }\n\n      return receiveDataChannel;\n    }()\n  }, {\n    key: \"_setupTransport\",\n    value: function () {\n      var _setupTransport2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(_ref6) {\n        var localDtlsRole, localSdpObject, dtlsParameters;\n        return regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                localDtlsRole = _ref6.localDtlsRole, localSdpObject = _ref6.localSdpObject;\n                if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n                dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n                  sdpObject: localSdpObject\n                }); // Set our DTLS role.\n\n                dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n                this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n                _context17.next = 7;\n                return this.safeEmitAsPromise('@connect', {\n                  dtlsParameters: dtlsParameters\n                });\n\n              case 7:\n                this._transportReady = true;\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _setupTransport(_x17) {\n        return _setupTransport2.apply(this, arguments);\n      }\n\n      return _setupTransport;\n    }()\n  }, {\n    key: \"_assertSendDirection\",\n    value: function _assertSendDirection() {\n      if (this._direction !== 'send') {\n        throw new Error('method can just be called for handlers with \"send\" direction');\n      }\n    }\n  }, {\n    key: \"_assertRecvDirection\",\n    value: function _assertRecvDirection() {\n      if (this._direction !== 'recv') {\n        throw new Error('method can just be called for handlers with \"recv\" direction');\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return 'Safari12';\n    }\n  }], [{\n    key: \"createFactory\",\n    value: function createFactory() {\n      return function () {\n        return new Safari12();\n      };\n    }\n  }]);\n\n  return Safari12;\n}(HandlerInterface_1.HandlerInterface);\n\nexports.Safari12 = Safari12;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/Safari12.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = __webpack_require__(/*! ../../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n/**\n * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full\n * compliant ORTC RTCRtpCapabilities.\n */\n\n\nfunction getCapabilities() {\n  var nativeCaps = RTCRtpReceiver.getCapabilities();\n  var caps = utils.clone(nativeCaps);\n\n  var _iterator = _createForOfIteratorHelper(caps.codecs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var codec = _step.value;\n      // Rename numChannels to channels.\n      codec.channels = codec.numChannels;\n      delete codec.numChannels; // Add mimeType.\n\n      codec.mimeType = codec.mimeType || \"\".concat(codec.kind, \"/\").concat(codec.name); // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.\n\n      if (codec.parameters) {\n        var parameters = codec.parameters;\n        if (parameters.apt) parameters.apt = Number(parameters.apt);\n        if (parameters['packetization-mode']) parameters['packetization-mode'] = Number(parameters['packetization-mode']);\n      } // Delete emty parameter String in rtcpFeedback.\n\n\n      var _iterator2 = _createForOfIteratorHelper(codec.rtcpFeedback || []),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var feedback = _step2.value;\n          if (!feedback.parameter) feedback.parameter = '';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return caps;\n}\n\nexports.getCapabilities = getCapabilities;\n/**\n * Generate RTCRtpParameters as ORTC based Edge likes.\n */\n\nfunction mangleRtpParameters(rtpParameters) {\n  var params = utils.clone(rtpParameters); // Rename mid to muxId.\n\n  if (params.mid) {\n    params.muxId = params.mid;\n    delete params.mid;\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(params.codecs),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var codec = _step3.value;\n\n      // Rename channels to numChannels.\n      if (codec.channels) {\n        codec.numChannels = codec.channels;\n        delete codec.channels;\n      } // Add codec.name (requried by Edge).\n\n\n      if (codec.mimeType && !codec.name) codec.name = codec.mimeType.split('/')[1]; // Remove mimeType.\n\n      delete codec.mimeType;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return params;\n}\n\nexports.mangleRtpParameters = mangleRtpParameters;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = __webpack_require__(/*! ../../utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar MediaSection = /*#__PURE__*/function () {\n  function MediaSection(_ref) {\n    var iceParameters = _ref.iceParameters,\n        iceCandidates = _ref.iceCandidates,\n        dtlsParameters = _ref.dtlsParameters,\n        _ref$planB = _ref.planB,\n        planB = _ref$planB === void 0 ? false : _ref$planB;\n\n    _classCallCheck(this, MediaSection);\n\n    this._mediaObject = {};\n    this._planB = planB;\n\n    if (iceParameters) {\n      this.setIceParameters(iceParameters);\n    }\n\n    if (iceCandidates) {\n      this._mediaObject.candidates = [];\n\n      var _iterator = _createForOfIteratorHelper(iceCandidates),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var candidate = _step.value;\n          var candidateObject = {}; // mediasoup does mandates rtcp-mux so candidates component is always\n          // RTP (1).\n\n          candidateObject.component = 1;\n          candidateObject.foundation = candidate.foundation;\n          candidateObject.ip = candidate.ip;\n          candidateObject.port = candidate.port;\n          candidateObject.priority = candidate.priority;\n          candidateObject.transport = candidate.protocol;\n          candidateObject.type = candidate.type;\n          if (candidate.tcpType) candidateObject.tcptype = candidate.tcpType;\n\n          this._mediaObject.candidates.push(candidateObject);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._mediaObject.endOfCandidates = 'end-of-candidates';\n      this._mediaObject.iceOptions = 'renomination';\n    }\n\n    if (dtlsParameters) {\n      this.setDtlsRole(dtlsParameters.role);\n    }\n  }\n\n  _createClass(MediaSection, [{\n    key: \"getObject\",\n    value: function getObject() {\n      return this._mediaObject;\n    }\n  }, {\n    key: \"setIceParameters\",\n    value: function setIceParameters(iceParameters) {\n      this._mediaObject.iceUfrag = iceParameters.usernameFragment;\n      this._mediaObject.icePwd = iceParameters.password;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this._mediaObject.direction = 'inactive';\n      delete this._mediaObject.ext;\n      delete this._mediaObject.ssrcs;\n      delete this._mediaObject.ssrcGroups;\n      delete this._mediaObject.simulcast;\n      delete this._mediaObject.simulcast_03;\n      delete this._mediaObject.rids;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._mediaObject.direction = 'inactive';\n      this._mediaObject.port = 0;\n      delete this._mediaObject.ext;\n      delete this._mediaObject.ssrcs;\n      delete this._mediaObject.ssrcGroups;\n      delete this._mediaObject.simulcast;\n      delete this._mediaObject.simulcast_03;\n      delete this._mediaObject.rids;\n      delete this._mediaObject.extmapAllowMixed;\n    }\n  }, {\n    key: \"mid\",\n    get: function get() {\n      return String(this._mediaObject.mid);\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._mediaObject.port === 0;\n    }\n  }]);\n\n  return MediaSection;\n}();\n\nexports.MediaSection = MediaSection;\n\nvar AnswerMediaSection = /*#__PURE__*/function (_MediaSection) {\n  _inherits(AnswerMediaSection, _MediaSection);\n\n  var _super = _createSuper(AnswerMediaSection);\n\n  function AnswerMediaSection(_ref2) {\n    var _this;\n\n    var iceParameters = _ref2.iceParameters,\n        iceCandidates = _ref2.iceCandidates,\n        dtlsParameters = _ref2.dtlsParameters,\n        sctpParameters = _ref2.sctpParameters,\n        plainRtpParameters = _ref2.plainRtpParameters,\n        _ref2$planB = _ref2.planB,\n        planB = _ref2$planB === void 0 ? false : _ref2$planB,\n        offerMediaObject = _ref2.offerMediaObject,\n        offerRtpParameters = _ref2.offerRtpParameters,\n        answerRtpParameters = _ref2.answerRtpParameters,\n        codecOptions = _ref2.codecOptions,\n        _ref2$extmapAllowMixe = _ref2.extmapAllowMixed,\n        extmapAllowMixed = _ref2$extmapAllowMixe === void 0 ? false : _ref2$extmapAllowMixe;\n\n    _classCallCheck(this, AnswerMediaSection);\n\n    _this = _super.call(this, {\n      iceParameters: iceParameters,\n      iceCandidates: iceCandidates,\n      dtlsParameters: dtlsParameters,\n      planB: planB\n    });\n    _this._mediaObject.mid = String(offerMediaObject.mid);\n    _this._mediaObject.type = offerMediaObject.type;\n    _this._mediaObject.protocol = offerMediaObject.protocol;\n\n    if (!plainRtpParameters) {\n      _this._mediaObject.connection = {\n        ip: '127.0.0.1',\n        version: 4\n      };\n      _this._mediaObject.port = 7;\n    } else {\n      _this._mediaObject.connection = {\n        ip: plainRtpParameters.ip,\n        version: plainRtpParameters.ipVersion\n      };\n      _this._mediaObject.port = plainRtpParameters.port;\n    }\n\n    switch (offerMediaObject.type) {\n      case 'audio':\n      case 'video':\n        {\n          _this._mediaObject.direction = 'recvonly';\n          _this._mediaObject.rtp = [];\n          _this._mediaObject.rtcpFb = [];\n          _this._mediaObject.fmtp = [];\n\n          var _iterator2 = _createForOfIteratorHelper(answerRtpParameters.codecs),\n              _step2;\n\n          try {\n            var _loop = function _loop() {\n              var codec = _step2.value;\n              var rtp = {\n                payload: codec.payloadType,\n                codec: getCodecName(codec),\n                rate: codec.clockRate\n              };\n              if (codec.channels > 1) rtp.encoding = codec.channels;\n\n              _this._mediaObject.rtp.push(rtp);\n\n              var codecParameters = utils.clone(codec.parameters || {});\n\n              if (codecOptions) {\n                var opusStereo = codecOptions.opusStereo,\n                    opusFec = codecOptions.opusFec,\n                    opusDtx = codecOptions.opusDtx,\n                    opusMaxPlaybackRate = codecOptions.opusMaxPlaybackRate,\n                    opusPtime = codecOptions.opusPtime,\n                    videoGoogleStartBitrate = codecOptions.videoGoogleStartBitrate,\n                    videoGoogleMaxBitrate = codecOptions.videoGoogleMaxBitrate,\n                    videoGoogleMinBitrate = codecOptions.videoGoogleMinBitrate;\n                var offerCodec = offerRtpParameters.codecs.find(function (c) {\n                  return c.payloadType === codec.payloadType;\n                });\n\n                switch (codec.mimeType.toLowerCase()) {\n                  case 'audio/opus':\n                    {\n                      if (opusStereo !== undefined) {\n                        offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;\n                        codecParameters.stereo = opusStereo ? 1 : 0;\n                      }\n\n                      if (opusFec !== undefined) {\n                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;\n                        codecParameters.useinbandfec = opusFec ? 1 : 0;\n                      }\n\n                      if (opusDtx !== undefined) {\n                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;\n                        codecParameters.usedtx = opusDtx ? 1 : 0;\n                      }\n\n                      if (opusMaxPlaybackRate !== undefined) {\n                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;\n                      }\n\n                      if (opusPtime !== undefined) {\n                        offerCodec.parameters.ptime = opusPtime;\n                        codecParameters.ptime = opusPtime;\n                      }\n\n                      break;\n                    }\n\n                  case 'video/vp8':\n                  case 'video/vp9':\n                  case 'video/h264':\n                  case 'video/h265':\n                    {\n                      if (videoGoogleStartBitrate !== undefined) codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;\n                      if (videoGoogleMaxBitrate !== undefined) codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;\n                      if (videoGoogleMinBitrate !== undefined) codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;\n                      break;\n                    }\n                }\n              }\n\n              var fmtp = {\n                payload: codec.payloadType,\n                config: ''\n              };\n\n              for (var _i = 0, _Object$keys = Object.keys(codecParameters); _i < _Object$keys.length; _i++) {\n                var key = _Object$keys[_i];\n                if (fmtp.config) fmtp.config += ';';\n                fmtp.config += \"\".concat(key, \"=\").concat(codecParameters[key]);\n              }\n\n              if (fmtp.config) _this._mediaObject.fmtp.push(fmtp);\n\n              var _iterator6 = _createForOfIteratorHelper(codec.rtcpFeedback),\n                  _step6;\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var fb = _step6.value;\n\n                  _this._mediaObject.rtcpFb.push({\n                    payload: codec.payloadType,\n                    type: fb.type,\n                    subtype: fb.parameter\n                  });\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            };\n\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          _this._mediaObject.payloads = answerRtpParameters.codecs.map(function (codec) {\n            return codec.payloadType;\n          }).join(' ');\n          _this._mediaObject.ext = [];\n\n          var _iterator3 = _createForOfIteratorHelper(answerRtpParameters.headerExtensions),\n              _step3;\n\n          try {\n            var _loop2 = function _loop2() {\n              var ext = _step3.value;\n              // Don't add a header extension if not present in the offer.\n              var found = (offerMediaObject.ext || []).some(function (localExt) {\n                return localExt.uri === ext.uri;\n              });\n              if (!found) return \"continue\";\n\n              _this._mediaObject.ext.push({\n                uri: ext.uri,\n                value: ext.id\n              });\n            };\n\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _ret = _loop2();\n\n              if (_ret === \"continue\") continue;\n            } // Allow both 1 byte and 2 bytes length header extensions.\n\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {\n            _this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';\n          } // Simulcast.\n\n\n          if (offerMediaObject.simulcast) {\n            _this._mediaObject.simulcast = {\n              dir1: 'recv',\n              list1: offerMediaObject.simulcast.list1\n            };\n            _this._mediaObject.rids = [];\n\n            var _iterator4 = _createForOfIteratorHelper(offerMediaObject.rids || []),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var rid = _step4.value;\n                if (rid.direction !== 'send') continue;\n\n                _this._mediaObject.rids.push({\n                  id: rid.id,\n                  direction: 'recv'\n                });\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } // Simulcast (draft version 03).\n          else if (offerMediaObject.simulcast_03) {\n              // eslint-disable-next-line camelcase\n              _this._mediaObject.simulcast_03 = {\n                value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')\n              };\n              _this._mediaObject.rids = [];\n\n              var _iterator5 = _createForOfIteratorHelper(offerMediaObject.rids || []),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _rid = _step5.value;\n                  if (_rid.direction !== 'send') continue;\n\n                  _this._mediaObject.rids.push({\n                    id: _rid.id,\n                    direction: 'recv'\n                  });\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n\n          _this._mediaObject.rtcpMux = 'rtcp-mux';\n          _this._mediaObject.rtcpRsize = 'rtcp-rsize';\n          if (_this._planB && _this._mediaObject.type === 'video') _this._mediaObject.xGoogleFlag = 'conference';\n          break;\n        }\n\n      case 'application':\n        {\n          // New spec.\n          if (typeof offerMediaObject.sctpPort === 'number') {\n            _this._mediaObject.payloads = 'webrtc-datachannel';\n            _this._mediaObject.sctpPort = sctpParameters.port;\n            _this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n          } // Old spec.\n          else if (offerMediaObject.sctpmap) {\n              _this._mediaObject.payloads = sctpParameters.port;\n              _this._mediaObject.sctpmap = {\n                app: 'webrtc-datachannel',\n                sctpmapNumber: sctpParameters.port,\n                maxMessageSize: sctpParameters.maxMessageSize\n              };\n            }\n\n          break;\n        }\n    }\n\n    return _this;\n  }\n\n  _createClass(AnswerMediaSection, [{\n    key: \"setDtlsRole\",\n    value: function setDtlsRole(role) {\n      switch (role) {\n        case 'client':\n          this._mediaObject.setup = 'active';\n          break;\n\n        case 'server':\n          this._mediaObject.setup = 'passive';\n          break;\n\n        case 'auto':\n          this._mediaObject.setup = 'actpass';\n          break;\n      }\n    }\n  }]);\n\n  return AnswerMediaSection;\n}(MediaSection);\n\nexports.AnswerMediaSection = AnswerMediaSection;\n\nvar OfferMediaSection = /*#__PURE__*/function (_MediaSection2) {\n  _inherits(OfferMediaSection, _MediaSection2);\n\n  var _super2 = _createSuper(OfferMediaSection);\n\n  function OfferMediaSection(_ref3) {\n    var _this2;\n\n    var iceParameters = _ref3.iceParameters,\n        iceCandidates = _ref3.iceCandidates,\n        dtlsParameters = _ref3.dtlsParameters,\n        sctpParameters = _ref3.sctpParameters,\n        plainRtpParameters = _ref3.plainRtpParameters,\n        _ref3$planB = _ref3.planB,\n        planB = _ref3$planB === void 0 ? false : _ref3$planB,\n        mid = _ref3.mid,\n        kind = _ref3.kind,\n        offerRtpParameters = _ref3.offerRtpParameters,\n        streamId = _ref3.streamId,\n        trackId = _ref3.trackId,\n        _ref3$oldDataChannelS = _ref3.oldDataChannelSpec,\n        oldDataChannelSpec = _ref3$oldDataChannelS === void 0 ? false : _ref3$oldDataChannelS;\n\n    _classCallCheck(this, OfferMediaSection);\n\n    _this2 = _super2.call(this, {\n      iceParameters: iceParameters,\n      iceCandidates: iceCandidates,\n      dtlsParameters: dtlsParameters,\n      planB: planB\n    });\n    _this2._mediaObject.mid = String(mid);\n    _this2._mediaObject.type = kind;\n\n    if (!plainRtpParameters) {\n      _this2._mediaObject.connection = {\n        ip: '127.0.0.1',\n        version: 4\n      };\n      if (!sctpParameters) _this2._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';else _this2._mediaObject.protocol = 'UDP/DTLS/SCTP';\n      _this2._mediaObject.port = 7;\n    } else {\n      _this2._mediaObject.connection = {\n        ip: plainRtpParameters.ip,\n        version: plainRtpParameters.ipVersion\n      };\n      _this2._mediaObject.protocol = 'RTP/AVP';\n      _this2._mediaObject.port = plainRtpParameters.port;\n    }\n\n    switch (kind) {\n      case 'audio':\n      case 'video':\n        {\n          _this2._mediaObject.direction = 'sendonly';\n          _this2._mediaObject.rtp = [];\n          _this2._mediaObject.rtcpFb = [];\n          _this2._mediaObject.fmtp = [];\n          if (!_this2._planB) _this2._mediaObject.msid = \"\".concat(streamId || '-', \" \").concat(trackId);\n\n          var _iterator7 = _createForOfIteratorHelper(offerRtpParameters.codecs),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var codec = _step7.value;\n              var rtp = {\n                payload: codec.payloadType,\n                codec: getCodecName(codec),\n                rate: codec.clockRate\n              };\n              if (codec.channels > 1) rtp.encoding = codec.channels;\n\n              _this2._mediaObject.rtp.push(rtp);\n\n              var fmtp = {\n                payload: codec.payloadType,\n                config: ''\n              };\n\n              for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {\n                var key = _Object$keys2[_i2];\n                if (fmtp.config) fmtp.config += ';';\n                fmtp.config += \"\".concat(key, \"=\").concat(codec.parameters[key]);\n              }\n\n              if (fmtp.config) _this2._mediaObject.fmtp.push(fmtp);\n\n              var _iterator9 = _createForOfIteratorHelper(codec.rtcpFeedback),\n                  _step9;\n\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var fb = _step9.value;\n\n                  _this2._mediaObject.rtcpFb.push({\n                    payload: codec.payloadType,\n                    type: fb.type,\n                    subtype: fb.parameter\n                  });\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          _this2._mediaObject.payloads = offerRtpParameters.codecs.map(function (codec) {\n            return codec.payloadType;\n          }).join(' ');\n          _this2._mediaObject.ext = [];\n\n          var _iterator8 = _createForOfIteratorHelper(offerRtpParameters.headerExtensions),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var ext = _step8.value;\n\n              _this2._mediaObject.ext.push({\n                uri: ext.uri,\n                value: ext.id\n              });\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          _this2._mediaObject.rtcpMux = 'rtcp-mux';\n          _this2._mediaObject.rtcpRsize = 'rtcp-rsize';\n          var encoding = offerRtpParameters.encodings[0];\n          var ssrc = encoding.ssrc;\n          var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n          _this2._mediaObject.ssrcs = [];\n          _this2._mediaObject.ssrcGroups = [];\n\n          if (offerRtpParameters.rtcp.cname) {\n            _this2._mediaObject.ssrcs.push({\n              id: ssrc,\n              attribute: 'cname',\n              value: offerRtpParameters.rtcp.cname\n            });\n          }\n\n          if (_this2._planB) {\n            _this2._mediaObject.ssrcs.push({\n              id: ssrc,\n              attribute: 'msid',\n              value: \"\".concat(streamId || '-', \" \").concat(trackId)\n            });\n          }\n\n          if (rtxSsrc) {\n            if (offerRtpParameters.rtcp.cname) {\n              _this2._mediaObject.ssrcs.push({\n                id: rtxSsrc,\n                attribute: 'cname',\n                value: offerRtpParameters.rtcp.cname\n              });\n            }\n\n            if (_this2._planB) {\n              _this2._mediaObject.ssrcs.push({\n                id: rtxSsrc,\n                attribute: 'msid',\n                value: \"\".concat(streamId || '-', \" \").concat(trackId)\n              });\n            } // Associate original and retransmission SSRCs.\n\n\n            _this2._mediaObject.ssrcGroups.push({\n              semantics: 'FID',\n              ssrcs: \"\".concat(ssrc, \" \").concat(rtxSsrc)\n            });\n          }\n\n          break;\n        }\n\n      case 'application':\n        {\n          // New spec.\n          if (!oldDataChannelSpec) {\n            _this2._mediaObject.payloads = 'webrtc-datachannel';\n            _this2._mediaObject.sctpPort = sctpParameters.port;\n            _this2._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\n          } // Old spec.\n          else {\n              _this2._mediaObject.payloads = sctpParameters.port;\n              _this2._mediaObject.sctpmap = {\n                app: 'webrtc-datachannel',\n                sctpmapNumber: sctpParameters.port,\n                maxMessageSize: sctpParameters.maxMessageSize\n              };\n            }\n\n          break;\n        }\n    }\n\n    return _this2;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _createClass(OfferMediaSection, [{\n    key: \"setDtlsRole\",\n    value: function setDtlsRole(role) {\n      // Always 'actpass'.\n      this._mediaObject.setup = 'actpass';\n    }\n  }, {\n    key: \"planBReceive\",\n    value: function planBReceive(_ref4) {\n      var offerRtpParameters = _ref4.offerRtpParameters,\n          streamId = _ref4.streamId,\n          trackId = _ref4.trackId;\n      var encoding = offerRtpParameters.encodings[0];\n      var ssrc = encoding.ssrc;\n      var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n\n      if (offerRtpParameters.rtcp.cname) {\n        this._mediaObject.ssrcs.push({\n          id: ssrc,\n          attribute: 'cname',\n          value: offerRtpParameters.rtcp.cname\n        });\n      }\n\n      this._mediaObject.ssrcs.push({\n        id: ssrc,\n        attribute: 'msid',\n        value: \"\".concat(streamId || '-', \" \").concat(trackId)\n      });\n\n      if (rtxSsrc) {\n        if (offerRtpParameters.rtcp.cname) {\n          this._mediaObject.ssrcs.push({\n            id: rtxSsrc,\n            attribute: 'cname',\n            value: offerRtpParameters.rtcp.cname\n          });\n        }\n\n        this._mediaObject.ssrcs.push({\n          id: rtxSsrc,\n          attribute: 'msid',\n          value: \"\".concat(streamId || '-', \" \").concat(trackId)\n        }); // Associate original and retransmission SSRCs.\n\n\n        this._mediaObject.ssrcGroups.push({\n          semantics: 'FID',\n          ssrcs: \"\".concat(ssrc, \" \").concat(rtxSsrc)\n        });\n      }\n    }\n  }, {\n    key: \"planBStopReceiving\",\n    value: function planBStopReceiving(_ref5) {\n      var offerRtpParameters = _ref5.offerRtpParameters;\n      var encoding = offerRtpParameters.encodings[0];\n      var ssrc = encoding.ssrc;\n      var rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : undefined;\n      this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter(function (s) {\n        return s.id !== ssrc && s.id !== rtxSsrc;\n      });\n\n      if (rtxSsrc) {\n        this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter(function (group) {\n          return group.ssrcs !== \"\".concat(ssrc, \" \").concat(rtxSsrc);\n        });\n      }\n    }\n  }]);\n\n  return OfferMediaSection;\n}(MediaSection);\n\nexports.OfferMediaSection = OfferMediaSection;\n\nfunction getCodecName(codec) {\n  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType');\n  return mimeTypeMatch[2];\n}\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nvar Logger_1 = __webpack_require__(/*! ../../Logger */ \"./node_modules/mediasoup-client/lib/Logger.js\");\n\nvar MediaSection_1 = __webpack_require__(/*! ./MediaSection */ \"./node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js\");\n\nvar logger = new Logger_1.Logger('RemoteSdp');\n\nvar RemoteSdp = /*#__PURE__*/function () {\n  function RemoteSdp(_ref) {\n    var iceParameters = _ref.iceParameters,\n        iceCandidates = _ref.iceCandidates,\n        dtlsParameters = _ref.dtlsParameters,\n        sctpParameters = _ref.sctpParameters,\n        plainRtpParameters = _ref.plainRtpParameters,\n        _ref$planB = _ref.planB,\n        planB = _ref$planB === void 0 ? false : _ref$planB;\n\n    _classCallCheck(this, RemoteSdp);\n\n    // MediaSection instances.\n    this._mediaSections = []; // MediaSection indices indexed by MID.\n\n    this._midToIndex = new Map();\n    this._iceParameters = iceParameters;\n    this._iceCandidates = iceCandidates;\n    this._dtlsParameters = dtlsParameters;\n    this._sctpParameters = sctpParameters;\n    this._plainRtpParameters = plainRtpParameters;\n    this._planB = planB;\n    this._sdpObject = {\n      version: 0,\n      origin: {\n        address: '0.0.0.0',\n        ipVer: 4,\n        netType: 'IN',\n        sessionId: 10000,\n        sessionVersion: 0,\n        username: 'mediasoup-client'\n      },\n      name: '-',\n      timing: {\n        start: 0,\n        stop: 0\n      },\n      media: []\n    }; // If ICE parameters are given, add ICE-Lite indicator.\n\n    if (iceParameters && iceParameters.iceLite) {\n      this._sdpObject.icelite = 'ice-lite';\n    } // If DTLS parameters are given, assume WebRTC and BUNDLE.\n\n\n    if (dtlsParameters) {\n      this._sdpObject.msidSemantic = {\n        semantic: 'WMS',\n        token: '*'\n      }; // NOTE: We take the latest fingerprint.\n\n      var numFingerprints = this._dtlsParameters.fingerprints.length;\n      this._sdpObject.fingerprint = {\n        type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n        hash: dtlsParameters.fingerprints[numFingerprints - 1].value\n      };\n      this._sdpObject.groups = [{\n        type: 'BUNDLE',\n        mids: ''\n      }];\n    } // If there are plain RPT parameters, override SDP origin.\n\n\n    if (plainRtpParameters) {\n      this._sdpObject.origin.address = plainRtpParameters.ip;\n      this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;\n    }\n  }\n\n  _createClass(RemoteSdp, [{\n    key: \"updateIceParameters\",\n    value: function updateIceParameters(iceParameters) {\n      logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);\n      this._iceParameters = iceParameters;\n      this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;\n\n      var _iterator = _createForOfIteratorHelper(this._mediaSections),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var mediaSection = _step.value;\n          mediaSection.setIceParameters(iceParameters);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"updateDtlsRole\",\n    value: function updateDtlsRole(role) {\n      logger.debug('updateDtlsRole() [role:%s]', role);\n      this._dtlsParameters.role = role;\n\n      var _iterator2 = _createForOfIteratorHelper(this._mediaSections),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mediaSection = _step2.value;\n          mediaSection.setDtlsRole(role);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"getNextMediaSectionIdx\",\n    value: function getNextMediaSectionIdx() {\n      // If a closed media section is found, return its index.\n      for (var idx = 0; idx < this._mediaSections.length; ++idx) {\n        var mediaSection = this._mediaSections[idx];\n        if (mediaSection.closed) return {\n          idx: idx,\n          reuseMid: mediaSection.mid\n        };\n      } // If no closed media section is found, return next one.\n\n\n      return {\n        idx: this._mediaSections.length\n      };\n    }\n  }, {\n    key: \"send\",\n    value: function send(_ref2) {\n      var offerMediaObject = _ref2.offerMediaObject,\n          reuseMid = _ref2.reuseMid,\n          offerRtpParameters = _ref2.offerRtpParameters,\n          answerRtpParameters = _ref2.answerRtpParameters,\n          codecOptions = _ref2.codecOptions,\n          _ref2$extmapAllowMixe = _ref2.extmapAllowMixed,\n          extmapAllowMixed = _ref2$extmapAllowMixe === void 0 ? false : _ref2$extmapAllowMixe;\n      var mediaSection = new MediaSection_1.AnswerMediaSection({\n        iceParameters: this._iceParameters,\n        iceCandidates: this._iceCandidates,\n        dtlsParameters: this._dtlsParameters,\n        plainRtpParameters: this._plainRtpParameters,\n        planB: this._planB,\n        offerMediaObject: offerMediaObject,\n        offerRtpParameters: offerRtpParameters,\n        answerRtpParameters: answerRtpParameters,\n        codecOptions: codecOptions,\n        extmapAllowMixed: extmapAllowMixed\n      }); // Unified-Plan with closed media section replacement.\n\n      if (reuseMid) {\n        this._replaceMediaSection(mediaSection, reuseMid);\n      } // Unified-Plan or Plan-B with different media kind.\n      else if (!this._midToIndex.has(mediaSection.mid)) {\n          this._addMediaSection(mediaSection);\n        } // Plan-B with same media kind.\n        else {\n            this._replaceMediaSection(mediaSection);\n          }\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(_ref3) {\n      var mid = _ref3.mid,\n          kind = _ref3.kind,\n          offerRtpParameters = _ref3.offerRtpParameters,\n          streamId = _ref3.streamId,\n          trackId = _ref3.trackId;\n\n      var idx = this._midToIndex.get(mid);\n\n      var mediaSection;\n      if (idx !== undefined) mediaSection = this._mediaSections[idx]; // Unified-Plan or different media kind.\n\n      if (!mediaSection) {\n        mediaSection = new MediaSection_1.OfferMediaSection({\n          iceParameters: this._iceParameters,\n          iceCandidates: this._iceCandidates,\n          dtlsParameters: this._dtlsParameters,\n          plainRtpParameters: this._plainRtpParameters,\n          planB: this._planB,\n          mid: mid,\n          kind: kind,\n          offerRtpParameters: offerRtpParameters,\n          streamId: streamId,\n          trackId: trackId\n        });\n\n        this._addMediaSection(mediaSection);\n      } // Plan-B.\n      else {\n          mediaSection.planBReceive({\n            offerRtpParameters: offerRtpParameters,\n            streamId: streamId,\n            trackId: trackId\n          });\n\n          this._replaceMediaSection(mediaSection);\n        }\n    }\n  }, {\n    key: \"disableMediaSection\",\n    value: function disableMediaSection(mid) {\n      var idx = this._midToIndex.get(mid);\n\n      if (idx === undefined) {\n        throw new Error(\"no media section found with mid '\".concat(mid, \"'\"));\n      }\n\n      var mediaSection = this._mediaSections[idx];\n      mediaSection.disable();\n    }\n  }, {\n    key: \"closeMediaSection\",\n    value: function closeMediaSection(mid) {\n      var idx = this._midToIndex.get(mid);\n\n      if (idx === undefined) {\n        throw new Error(\"no media section found with mid '\".concat(mid, \"'\"));\n      }\n\n      var mediaSection = this._mediaSections[idx]; // NOTE: Closing the first m section is a pain since it invalidates the\n      // bundled transport, so let's avoid it.\n\n      if (mid === this._firstMid) {\n        logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);\n        this.disableMediaSection(mid);\n        return;\n      }\n\n      mediaSection.close(); // Regenerate BUNDLE mids.\n\n      this._regenerateBundleMids();\n    }\n  }, {\n    key: \"planBStopReceiving\",\n    value: function planBStopReceiving(_ref4) {\n      var mid = _ref4.mid,\n          offerRtpParameters = _ref4.offerRtpParameters;\n\n      var idx = this._midToIndex.get(mid);\n\n      if (idx === undefined) {\n        throw new Error(\"no media section found with mid '\".concat(mid, \"'\"));\n      }\n\n      var mediaSection = this._mediaSections[idx];\n      mediaSection.planBStopReceiving({\n        offerRtpParameters: offerRtpParameters\n      });\n\n      this._replaceMediaSection(mediaSection);\n    }\n  }, {\n    key: \"sendSctpAssociation\",\n    value: function sendSctpAssociation(_ref5) {\n      var offerMediaObject = _ref5.offerMediaObject;\n      var mediaSection = new MediaSection_1.AnswerMediaSection({\n        iceParameters: this._iceParameters,\n        iceCandidates: this._iceCandidates,\n        dtlsParameters: this._dtlsParameters,\n        sctpParameters: this._sctpParameters,\n        plainRtpParameters: this._plainRtpParameters,\n        offerMediaObject: offerMediaObject\n      });\n\n      this._addMediaSection(mediaSection);\n    }\n  }, {\n    key: \"receiveSctpAssociation\",\n    value: function receiveSctpAssociation() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$oldDataChannelS = _ref6.oldDataChannelSpec,\n          oldDataChannelSpec = _ref6$oldDataChannelS === void 0 ? false : _ref6$oldDataChannelS;\n\n      var mediaSection = new MediaSection_1.OfferMediaSection({\n        iceParameters: this._iceParameters,\n        iceCandidates: this._iceCandidates,\n        dtlsParameters: this._dtlsParameters,\n        sctpParameters: this._sctpParameters,\n        plainRtpParameters: this._plainRtpParameters,\n        mid: 'datachannel',\n        kind: 'application',\n        oldDataChannelSpec: oldDataChannelSpec\n      });\n\n      this._addMediaSection(mediaSection);\n    }\n  }, {\n    key: \"getSdp\",\n    value: function getSdp() {\n      // Increase SDP version.\n      this._sdpObject.origin.sessionVersion++;\n      return sdpTransform.write(this._sdpObject);\n    }\n  }, {\n    key: \"_addMediaSection\",\n    value: function _addMediaSection(newMediaSection) {\n      if (!this._firstMid) this._firstMid = newMediaSection.mid; // Add to the vector.\n\n      this._mediaSections.push(newMediaSection); // Add to the map.\n\n\n      this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1); // Add to the SDP object.\n\n\n      this._sdpObject.media.push(newMediaSection.getObject()); // Regenerate BUNDLE mids.\n\n\n      this._regenerateBundleMids();\n    }\n  }, {\n    key: \"_replaceMediaSection\",\n    value: function _replaceMediaSection(newMediaSection, reuseMid) {\n      // Store it in the map.\n      if (typeof reuseMid === 'string') {\n        var idx = this._midToIndex.get(reuseMid);\n\n        if (idx === undefined) {\n          throw new Error(\"no media section found for reuseMid '\".concat(reuseMid, \"'\"));\n        }\n\n        var oldMediaSection = this._mediaSections[idx]; // Replace the index in the vector with the new media section.\n\n        this._mediaSections[idx] = newMediaSection; // Update the map.\n\n        this._midToIndex[\"delete\"](oldMediaSection.mid);\n\n        this._midToIndex.set(newMediaSection.mid, idx); // Update the SDP object.\n\n\n        this._sdpObject.media[idx] = newMediaSection.getObject(); // Regenerate BUNDLE mids.\n\n        this._regenerateBundleMids();\n      } else {\n        var _idx = this._midToIndex.get(newMediaSection.mid);\n\n        if (_idx === undefined) {\n          throw new Error(\"no media section found with mid '\".concat(newMediaSection.mid, \"'\"));\n        } // Replace the index in the vector with the new media section.\n\n\n        this._mediaSections[_idx] = newMediaSection; // Update the SDP object.\n\n        this._sdpObject.media[_idx] = newMediaSection.getObject();\n      }\n    }\n  }, {\n    key: \"_regenerateBundleMids\",\n    value: function _regenerateBundleMids() {\n      if (!this._dtlsParameters) return;\n      this._sdpObject.groups[0].mids = this._mediaSections.filter(function (mediaSection) {\n        return !mediaSection.closed;\n      }).map(function (mediaSection) {\n        return mediaSection.mid;\n      }).join(' ');\n    }\n  }]);\n\n  return RemoteSdp;\n}();\n\nexports.RemoteSdp = RemoteSdp;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sdpTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\n\nfunction extractRtpCapabilities(_ref) {\n  var sdpObject = _ref.sdpObject;\n  // Map of RtpCodecParameters indexed by payload type.\n  var codecsMap = new Map(); // Array of RtpHeaderExtensions.\n\n  var headerExtensions = []; // Whether a m=audio/video section has been already found.\n\n  var gotAudio = false;\n  var gotVideo = false;\n\n  var _iterator = _createForOfIteratorHelper(sdpObject.media),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var m = _step.value;\n      var kind = m.type;\n\n      switch (kind) {\n        case 'audio':\n          {\n            if (gotAudio) continue;\n            gotAudio = true;\n            break;\n          }\n\n        case 'video':\n          {\n            if (gotVideo) continue;\n            gotVideo = true;\n            break;\n          }\n\n        default:\n          {\n            continue;\n          }\n      } // Get codecs.\n\n\n      var _iterator2 = _createForOfIteratorHelper(m.rtp),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var rtp = _step2.value;\n          var codec = {\n            kind: kind,\n            mimeType: \"\".concat(kind, \"/\").concat(rtp.codec),\n            preferredPayloadType: rtp.payload,\n            clockRate: rtp.rate,\n            channels: rtp.encoding,\n            parameters: {},\n            rtcpFeedback: []\n          };\n          codecsMap.set(codec.preferredPayloadType, codec);\n        } // Get codec parameters.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(m.fmtp || []),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var fmtp = _step3.value;\n          var parameters = sdpTransform.parseParams(fmtp.config);\n\n          var _codec = codecsMap.get(fmtp.payload);\n\n          if (!_codec) continue; // Specials case to convert parameter value to string.\n\n          if (parameters && parameters['profile-level-id']) parameters['profile-level-id'] = String(parameters['profile-level-id']);\n          _codec.parameters = parameters;\n        } // Get RTCP feedback for each codec.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(m.rtcpFb || []),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var fb = _step4.value;\n\n          var _codec2 = codecsMap.get(fb.payload);\n\n          if (!_codec2) continue;\n          var feedback = {\n            type: fb.type,\n            parameter: fb.subtype\n          };\n          if (!feedback.parameter) delete feedback.parameter;\n\n          _codec2.rtcpFeedback.push(feedback);\n        } // Get RTP header extensions.\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(m.ext || []),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var ext = _step5.value;\n          // Ignore encrypted extensions (not yet supported in mediasoup).\n          if (ext['encrypt-uri']) continue;\n          var headerExtension = {\n            kind: kind,\n            uri: ext.uri,\n            preferredId: ext.value\n          };\n          headerExtensions.push(headerExtension);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var rtpCapabilities = {\n    codecs: Array.from(codecsMap.values()),\n    headerExtensions: headerExtensions\n  };\n  return rtpCapabilities;\n}\n\nexports.extractRtpCapabilities = extractRtpCapabilities;\n\nfunction extractDtlsParameters(_ref2) {\n  var sdpObject = _ref2.sdpObject;\n  var mediaObject = (sdpObject.media || []).find(function (m) {\n    return m.iceUfrag && m.port !== 0;\n  });\n  if (!mediaObject) throw new Error('no active media section found');\n  var fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n  var role;\n\n  switch (mediaObject.setup) {\n    case 'active':\n      role = 'client';\n      break;\n\n    case 'passive':\n      role = 'server';\n      break;\n\n    case 'actpass':\n      role = 'auto';\n      break;\n  }\n\n  var dtlsParameters = {\n    role: role,\n    fingerprints: [{\n      algorithm: fingerprint.type,\n      value: fingerprint.hash\n    }]\n  };\n  return dtlsParameters;\n}\n\nexports.extractDtlsParameters = extractDtlsParameters;\n\nfunction getCname(_ref3) {\n  var offerMediaObject = _ref3.offerMediaObject;\n  var ssrcCnameLine = (offerMediaObject.ssrcs || []).find(function (line) {\n    return line.attribute === 'cname';\n  });\n  if (!ssrcCnameLine) return '';\n  return ssrcCnameLine.value;\n}\n\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\n\nfunction applyCodecParameters(_ref4) {\n  var offerRtpParameters = _ref4.offerRtpParameters,\n      answerMediaObject = _ref4.answerMediaObject;\n\n  var _iterator6 = _createForOfIteratorHelper(offerRtpParameters.codecs),\n      _step6;\n\n  try {\n    var _loop = function _loop() {\n      var codec = _step6.value;\n      var mimeType = codec.mimeType.toLowerCase(); // Avoid parsing codec parameters for unhandled codecs.\n\n      if (mimeType !== 'audio/opus') return \"continue\";\n      var rtp = (answerMediaObject.rtp || []).find(function (r) {\n        return r.payload === codec.payloadType;\n      });\n      if (!rtp) return \"continue\"; // Just in case.\n\n      answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n      var fmtp = answerMediaObject.fmtp.find(function (f) {\n        return f.payload === codec.payloadType;\n      });\n\n      if (!fmtp) {\n        fmtp = {\n          payload: codec.payloadType,\n          config: ''\n        };\n        answerMediaObject.fmtp.push(fmtp);\n      }\n\n      var parameters = sdpTransform.parseParams(fmtp.config);\n\n      switch (mimeType) {\n        case 'audio/opus':\n          {\n            var spropStereo = codec.parameters['sprop-stereo'];\n            if (spropStereo !== undefined) parameters.stereo = spropStereo ? 1 : 0;\n            break;\n          }\n      } // Write the codec fmtp.config back.\n\n\n      fmtp.config = '';\n\n      for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        if (fmtp.config) fmtp.config += ';';\n        fmtp.config += \"\".concat(key, \"=\").concat(parameters[key]);\n      }\n    };\n\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n}\n\nexports.applyCodecParameters = applyCodecParameters;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction getRtpEncodings(_ref) {\n  var offerMediaObject = _ref.offerMediaObject,\n      track = _ref.track;\n  // First media SSRC (or the only one).\n  var firstSsrc;\n  var ssrcs = new Set();\n\n  var _iterator = _createForOfIteratorHelper(offerMediaObject.ssrcs || []),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      if (line.attribute !== 'msid') continue;\n      var trackId = line.value.split(' ')[1];\n\n      if (trackId === track.id) {\n        var ssrc = line.id;\n        ssrcs.add(ssrc);\n        if (!firstSsrc) firstSsrc = ssrc;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (ssrcs.size === 0) throw new Error(\"a=ssrc line with msid information not found [track.id:\".concat(track.id, \"]\"));\n  var ssrcToRtxSsrc = new Map(); // First assume RTX is used.\n\n  var _iterator2 = _createForOfIteratorHelper(offerMediaObject.ssrcGroups || []),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _line = _step2.value;\n      if (_line.semantics !== 'FID') continue;\n\n      var _line$ssrcs$split = _line.ssrcs.split(/\\s+/),\n          _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),\n          _ssrc = _line$ssrcs$split2[0],\n          rtxSsrc = _line$ssrcs$split2[1];\n\n      _ssrc = Number(_ssrc);\n      rtxSsrc = Number(rtxSsrc);\n\n      if (ssrcs.has(_ssrc)) {\n        // Remove both the SSRC and RTX SSRC from the set so later we know that they\n        // are already handled.\n        ssrcs[\"delete\"](_ssrc);\n        ssrcs[\"delete\"](rtxSsrc); // Add to the map.\n\n        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);\n      }\n    } // If the set of SSRCs is not empty it means that RTX is not being used, so take\n    // media SSRCs from there.\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(ssrcs),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ssrc2 = _step3.value;\n      // Add to the map.\n      ssrcToRtxSsrc.set(_ssrc2, null);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var encodings = [];\n\n  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          _ssrc3 = _step4$value[0],\n          _rtxSsrc = _step4$value[1];\n\n      var encoding = {\n        ssrc: _ssrc3\n      };\n      if (_rtxSsrc) encoding.rtx = {\n        ssrc: _rtxSsrc\n      };\n      encodings.push(encoding);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return encodings;\n}\n\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\n\nfunction addLegacySimulcast(_ref2) {\n  var offerMediaObject = _ref2.offerMediaObject,\n      track = _ref2.track,\n      numStreams = _ref2.numStreams;\n  if (numStreams <= 1) throw new TypeError('numStreams must be greater than 1');\n  var firstSsrc;\n  var firstRtxSsrc;\n  var streamId; // Get the SSRC.\n\n  var ssrcMsidLine = (offerMediaObject.ssrcs || []).find(function (line) {\n    if (line.attribute !== 'msid') return false;\n    var trackId = line.value.split(' ')[1];\n\n    if (trackId === track.id) {\n      firstSsrc = line.id;\n      streamId = line.value.split(' ')[0];\n      return true;\n    } else {\n      return false;\n    }\n  });\n  if (!ssrcMsidLine) throw new Error(\"a=ssrc line with msid information not found [track.id:\".concat(track.id, \"]\")); // Get the SSRC for RTX.\n\n  (offerMediaObject.ssrcGroups || []).some(function (line) {\n    if (line.semantics !== 'FID') return false;\n    var ssrcs = line.ssrcs.split(/\\s+/);\n\n    if (Number(ssrcs[0]) === firstSsrc) {\n      firstRtxSsrc = Number(ssrcs[1]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {\n    return line.attribute === 'cname' && line.id === firstSsrc;\n  });\n  if (!ssrcCnameLine) throw new Error(\"a=ssrc line with cname information not found [track.id:\".concat(track.id, \"]\"));\n  var cname = ssrcCnameLine.value;\n  var ssrcs = [];\n  var rtxSsrcs = [];\n\n  for (var i = 0; i < numStreams; ++i) {\n    ssrcs.push(firstSsrc + i);\n    if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);\n  }\n\n  offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];\n  offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];\n  offerMediaObject.ssrcGroups.push({\n    semantics: 'SIM',\n    ssrcs: ssrcs.join(' ')\n  });\n\n  for (var _i2 = 0; _i2 < ssrcs.length; ++_i2) {\n    var ssrc = ssrcs[_i2];\n    offerMediaObject.ssrcs.push({\n      id: ssrc,\n      attribute: 'cname',\n      value: cname\n    });\n    offerMediaObject.ssrcs.push({\n      id: ssrc,\n      attribute: 'msid',\n      value: \"\".concat(streamId, \" \").concat(track.id)\n    });\n  }\n\n  for (var _i3 = 0; _i3 < rtxSsrcs.length; ++_i3) {\n    var _ssrc4 = ssrcs[_i3];\n    var rtxSsrc = rtxSsrcs[_i3];\n    offerMediaObject.ssrcs.push({\n      id: rtxSsrc,\n      attribute: 'cname',\n      value: cname\n    });\n    offerMediaObject.ssrcs.push({\n      id: rtxSsrc,\n      attribute: 'msid',\n      value: \"\".concat(streamId, \" \").concat(track.id)\n    });\n    offerMediaObject.ssrcGroups.push({\n      semantics: 'FID',\n      ssrcs: \"\".concat(_ssrc4, \" \").concat(rtxSsrc)\n    });\n  }\n}\n\nexports.addLegacySimulcast = addLegacySimulcast;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction getRtpEncodings(_ref) {\n  var offerMediaObject = _ref.offerMediaObject;\n  var ssrcs = new Set();\n\n  var _iterator = _createForOfIteratorHelper(offerMediaObject.ssrcs || []),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      var ssrc = line.id;\n      ssrcs.add(ssrc);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (ssrcs.size === 0) throw new Error('no a=ssrc lines found');\n  var ssrcToRtxSsrc = new Map(); // First assume RTX is used.\n\n  var _iterator2 = _createForOfIteratorHelper(offerMediaObject.ssrcGroups || []),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _line = _step2.value;\n      if (_line.semantics !== 'FID') continue;\n\n      var _line$ssrcs$split = _line.ssrcs.split(/\\s+/),\n          _line$ssrcs$split2 = _slicedToArray(_line$ssrcs$split, 2),\n          _ssrc = _line$ssrcs$split2[0],\n          rtxSsrc = _line$ssrcs$split2[1];\n\n      _ssrc = Number(_ssrc);\n      rtxSsrc = Number(rtxSsrc);\n\n      if (ssrcs.has(_ssrc)) {\n        // Remove both the SSRC and RTX SSRC from the set so later we know that they\n        // are already handled.\n        ssrcs[\"delete\"](_ssrc);\n        ssrcs[\"delete\"](rtxSsrc); // Add to the map.\n\n        ssrcToRtxSsrc.set(_ssrc, rtxSsrc);\n      }\n    } // If the set of SSRCs is not empty it means that RTX is not being used, so take\n    // media SSRCs from there.\n\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(ssrcs),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ssrc2 = _step3.value;\n      // Add to the map.\n      ssrcToRtxSsrc.set(_ssrc2, null);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var encodings = [];\n\n  var _iterator4 = _createForOfIteratorHelper(ssrcToRtxSsrc),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          _ssrc3 = _step4$value[0],\n          _rtxSsrc = _step4$value[1];\n\n      var encoding = {\n        ssrc: _ssrc3\n      };\n      if (_rtxSsrc) encoding.rtx = {\n        ssrc: _rtxSsrc\n      };\n      encodings.push(encoding);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return encodings;\n}\n\nexports.getRtpEncodings = getRtpEncodings;\n/**\n * Adds multi-ssrc based simulcast into the given SDP media section offer.\n */\n\nfunction addLegacySimulcast(_ref2) {\n  var offerMediaObject = _ref2.offerMediaObject,\n      numStreams = _ref2.numStreams;\n  if (numStreams <= 1) throw new TypeError('numStreams must be greater than 1'); // Get the SSRC.\n\n  var ssrcMsidLine = (offerMediaObject.ssrcs || []).find(function (line) {\n    return line.attribute === 'msid';\n  });\n  if (!ssrcMsidLine) throw new Error('a=ssrc line with msid information not found');\n\n  var _ssrcMsidLine$value$s = _slicedToArray(ssrcMsidLine.value.split(' ')[0], 2),\n      streamId = _ssrcMsidLine$value$s[0],\n      trackId = _ssrcMsidLine$value$s[1];\n\n  var firstSsrc = ssrcMsidLine.id;\n  var firstRtxSsrc; // Get the SSRC for RTX.\n\n  (offerMediaObject.ssrcGroups || []).some(function (line) {\n    if (line.semantics !== 'FID') return false;\n    var ssrcs = line.ssrcs.split(/\\s+/);\n\n    if (Number(ssrcs[0]) === firstSsrc) {\n      firstRtxSsrc = Number(ssrcs[1]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n  var ssrcCnameLine = offerMediaObject.ssrcs.find(function (line) {\n    return line.attribute === 'cname';\n  });\n  if (!ssrcCnameLine) throw new Error('a=ssrc line with cname information not found');\n  var cname = ssrcCnameLine.value;\n  var ssrcs = [];\n  var rtxSsrcs = [];\n\n  for (var i = 0; i < numStreams; ++i) {\n    ssrcs.push(firstSsrc + i);\n    if (firstRtxSsrc) rtxSsrcs.push(firstRtxSsrc + i);\n  }\n\n  offerMediaObject.ssrcGroups = [];\n  offerMediaObject.ssrcs = [];\n  offerMediaObject.ssrcGroups.push({\n    semantics: 'SIM',\n    ssrcs: ssrcs.join(' ')\n  });\n\n  for (var _i2 = 0; _i2 < ssrcs.length; ++_i2) {\n    var ssrc = ssrcs[_i2];\n    offerMediaObject.ssrcs.push({\n      id: ssrc,\n      attribute: 'cname',\n      value: cname\n    });\n    offerMediaObject.ssrcs.push({\n      id: ssrc,\n      attribute: 'msid',\n      value: \"\".concat(streamId, \" \").concat(trackId)\n    });\n  }\n\n  for (var _i3 = 0; _i3 < rtxSsrcs.length; ++_i3) {\n    var _ssrc4 = ssrcs[_i3];\n    var rtxSsrc = rtxSsrcs[_i3];\n    offerMediaObject.ssrcs.push({\n      id: rtxSsrc,\n      attribute: 'cname',\n      value: cname\n    });\n    offerMediaObject.ssrcs.push({\n      id: rtxSsrc,\n      attribute: 'msid',\n      value: \"\".concat(streamId, \" \").concat(trackId)\n    });\n    offerMediaObject.ssrcGroups.push({\n      semantics: 'FID',\n      ssrcs: \"\".concat(_ssrc4, \" \").concat(rtxSsrc)\n    });\n  }\n}\n\nexports.addLegacySimulcast = addLegacySimulcast;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Device_1 = __webpack_require__(/*! ./Device */ \"./node_modules/mediasoup-client/lib/Device.js\");\n\nexports.Device = Device_1.Device;\nexports.detectDevice = Device_1.detectDevice;\n\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/mediasoup-client/lib/types.js\");\n\nexports.types = types;\n/**\n * Expose mediasoup-client version.\n */\n\nexports.version = '3.6.9';\n/**\n * Expose parseScalabilityMode() function.\n */\n\nvar scalabilityModes_1 = __webpack_require__(/*! ./scalabilityModes */ \"./node_modules/mediasoup-client/lib/scalabilityModes.js\");\n\nexports.parseScalabilityMode = scalabilityModes_1.parse;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/ortc.js":
/*!***************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/ortc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar h264 = __webpack_require__(/*! h264-profile-level-id */ \"./node_modules/h264-profile-level-id/index.js\");\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/mediasoup-client/lib/utils.js\");\n\nvar RTP_PROBATOR_MID = 'probator';\nvar RTP_PROBATOR_SSRC = 1234;\nvar RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCapabilities(caps) {\n  if (_typeof(caps) !== 'object') throw new TypeError('caps is not an object'); // codecs is optional. If unset, fill with an empty array.\n\n  if (caps.codecs && !Array.isArray(caps.codecs)) throw new TypeError('caps.codecs is not an array');else if (!caps.codecs) caps.codecs = [];\n\n  var _iterator = _createForOfIteratorHelper(caps.codecs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var codec = _step.value;\n      validateRtpCodecCapability(codec);\n    } // headerExtensions is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) throw new TypeError('caps.headerExtensions is not an array');else if (!caps.headerExtensions) caps.headerExtensions = [];\n\n  var _iterator2 = _createForOfIteratorHelper(caps.headerExtensions),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var ext = _step2.value;\n      validateRtpHeaderExtension(ext);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecCapability(codec) {\n  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (_typeof(codec) !== 'object') throw new TypeError('codec is not an object'); // mimeType is mandatory.\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType'); // Just override kind with media component of mimeType.\n\n  codec.kind = mimeTypeMatch[1].toLowerCase(); // preferredPayloadType is optional.\n\n  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') throw new TypeError('invalid codec.preferredPayloadType'); // clockRate is mandatory.\n\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate'); // channels is optional. If unset, set it to 1 (just if audio).\n\n  if (codec.kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || _typeof(codec.parameters) !== 'object') codec.parameters = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(codec.parameters); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(\"invalid codec parameter [key:\".concat(key, \"s, value:\").concat(value, \"]\"));\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n\n  var _iterator3 = _createForOfIteratorHelper(codec.rtcpFeedback),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var fb = _step3.value;\n      validateRtcpFeedback(fb);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpFeedback(fb) {\n  if (_typeof(fb) !== 'object') throw new TypeError('fb is not an object'); // type is mandatory.\n\n  if (!fb.type || typeof fb.type !== 'string') throw new TypeError('missing fb.type'); // parameter is optional. If unset set it to an empty string.\n\n  if (!fb.parameter || typeof fb.parameter !== 'string') fb.parameter = '';\n}\n\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtension(ext) {\n  if (_typeof(ext) !== 'object') throw new TypeError('ext is not an object'); // kind is optional. If unset set it to an empty string.\n\n  if (!ext.kind || typeof ext.kind !== 'string') ext.kind = '';\n  if (ext.kind !== '' && ext.kind !== 'audio' && ext.kind !== 'video') throw new TypeError('invalid ext.kind'); // uri is mandatory.\n\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri'); // preferredId is mandatory.\n\n  if (typeof ext.preferredId !== 'number') throw new TypeError('missing ext.preferredId'); // preferredEncrypt is optional. If unset set it to false.\n\n  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') throw new TypeError('invalid ext.preferredEncrypt');else if (!ext.preferredEncrypt) ext.preferredEncrypt = false; // direction is optional. If unset set it to sendrecv.\n\n  if (ext.direction && typeof ext.direction !== 'string') throw new TypeError('invalid ext.direction');else if (!ext.direction) ext.direction = 'sendrecv';\n}\n\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpParameters(params) {\n  if (_typeof(params) !== 'object') throw new TypeError('params is not an object'); // mid is optional.\n\n  if (params.mid && typeof params.mid !== 'string') throw new TypeError('params.mid is not a string'); // codecs is mandatory.\n\n  if (!Array.isArray(params.codecs)) throw new TypeError('missing params.codecs');\n\n  var _iterator4 = _createForOfIteratorHelper(params.codecs),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var codec = _step4.value;\n      validateRtpCodecParameters(codec);\n    } // headerExtensions is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) throw new TypeError('params.headerExtensions is not an array');else if (!params.headerExtensions) params.headerExtensions = [];\n\n  var _iterator5 = _createForOfIteratorHelper(params.headerExtensions),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var ext = _step5.value;\n      validateRtpHeaderExtensionParameters(ext);\n    } // encodings is optional. If unset, fill with an empty array.\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (params.encodings && !Array.isArray(params.encodings)) throw new TypeError('params.encodings is not an array');else if (!params.encodings) params.encodings = [];\n\n  var _iterator6 = _createForOfIteratorHelper(params.encodings),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var encoding = _step6.value;\n      validateRtpEncodingParameters(encoding);\n    } // rtcp is optional. If unset, fill with an empty object.\n\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  if (params.rtcp && _typeof(params.rtcp) !== 'object') throw new TypeError('params.rtcp is not an object');else if (!params.rtcp) params.rtcp = {};\n  validateRtcpParameters(params.rtcp);\n}\n\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecParameters(codec) {\n  var MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (_typeof(codec) !== 'object') throw new TypeError('codec is not an object'); // mimeType is mandatory.\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  var mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType'); // payloadType is mandatory.\n\n  if (typeof codec.payloadType !== 'number') throw new TypeError('missing codec.payloadType'); // clockRate is mandatory.\n\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');\n  var kind = mimeTypeMatch[1].toLowerCase(); // channels is optional. If unset, set it to 1 (just if audio).\n\n  if (kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || _typeof(codec.parameters) !== 'object') codec.parameters = {};\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(codec.parameters); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(\"invalid codec parameter [key:\".concat(key, \"s, value:\").concat(value, \"]\"));\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n\n  var _iterator7 = _createForOfIteratorHelper(codec.rtcpFeedback),\n      _step7;\n\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var fb = _step7.value;\n      validateRtcpFeedback(fb);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\n\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtensionParameters(ext) {\n  if (_typeof(ext) !== 'object') throw new TypeError('ext is not an object'); // uri is mandatory.\n\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri'); // id is mandatory.\n\n  if (typeof ext.id !== 'number') throw new TypeError('missing ext.id'); // encrypt is optional. If unset set it to false.\n\n  if (ext.encrypt && typeof ext.encrypt !== 'boolean') throw new TypeError('invalid ext.encrypt');else if (!ext.encrypt) ext.encrypt = false; // parameters is optional. If unset, set it to an empty object.\n\n  if (!ext.parameters || _typeof(ext.parameters) !== 'object') ext.parameters = {};\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(ext.parameters); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var value = ext.parameters[key];\n\n    if (value === undefined) {\n      ext.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') throw new TypeError('invalid header extension parameter');\n  }\n}\n\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpEncodingParameters(encoding) {\n  if (_typeof(encoding) !== 'object') throw new TypeError('encoding is not an object'); // ssrc is optional.\n\n  if (encoding.ssrc && typeof encoding.ssrc !== 'number') throw new TypeError('invalid encoding.ssrc'); // rid is optional.\n\n  if (encoding.rid && typeof encoding.rid !== 'string') throw new TypeError('invalid encoding.rid'); // rtx is optional.\n\n  if (encoding.rtx && _typeof(encoding.rtx) !== 'object') {\n    throw new TypeError('invalid encoding.rtx');\n  } else if (encoding.rtx) {\n    // RTX ssrc is mandatory if rtx is present.\n    if (typeof encoding.rtx.ssrc !== 'number') throw new TypeError('missing encoding.rtx.ssrc');\n  } // dtx is optional. If unset set it to false.\n\n\n  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') encoding.dtx = false; // scalabilityMode is optional.\n\n  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') throw new TypeError('invalid encoding.scalabilityMode');\n}\n\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpParameters(rtcp) {\n  if (_typeof(rtcp) !== 'object') throw new TypeError('rtcp is not an object'); // cname is optional.\n\n  if (rtcp.cname && typeof rtcp.cname !== 'string') throw new TypeError('invalid rtcp.cname'); // reducedSize is optional. If unset set it to true.\n\n  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') rtcp.reducedSize = true;\n}\n\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpCapabilities(caps) {\n  if (_typeof(caps) !== 'object') throw new TypeError('caps is not an object'); // numStreams is mandatory.\n\n  if (!caps.numStreams || _typeof(caps.numStreams) !== 'object') throw new TypeError('missing caps.numStreams');\n  validateNumSctpStreams(caps.numStreams);\n}\n\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateNumSctpStreams(numStreams) {\n  if (_typeof(numStreams) !== 'object') throw new TypeError('numStreams is not an object'); // OS is mandatory.\n\n  if (typeof numStreams.OS !== 'number') throw new TypeError('missing numStreams.OS'); // MIS is mandatory.\n\n  if (typeof numStreams.MIS !== 'number') throw new TypeError('missing numStreams.MIS');\n}\n\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpParameters(params) {\n  if (_typeof(params) !== 'object') throw new TypeError('params is not an object'); // port is mandatory.\n\n  if (typeof params.port !== 'number') throw new TypeError('missing params.port'); // OS is mandatory.\n\n  if (typeof params.OS !== 'number') throw new TypeError('missing params.OS'); // MIS is mandatory.\n\n  if (typeof params.MIS !== 'number') throw new TypeError('missing params.MIS'); // maxMessageSize is mandatory.\n\n  if (typeof params.maxMessageSize !== 'number') throw new TypeError('missing params.maxMessageSize');\n}\n\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpStreamParameters(params) {\n  if (_typeof(params) !== 'object') throw new TypeError('params is not an object'); // streamId is mandatory.\n\n  if (typeof params.streamId !== 'number') throw new TypeError('missing params.streamId'); // ordered is optional.\n\n  var orderedGiven = false;\n  if (typeof params.ordered === 'boolean') orderedGiven = true;else params.ordered = true; // maxPacketLifeTime is optional.\n\n  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') throw new TypeError('invalid params.maxPacketLifeTime'); // maxRetransmits is optional.\n\n  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') throw new TypeError('invalid params.maxRetransmits');\n  if (params.maxPacketLifeTime && params.maxRetransmits) throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n\n  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    params.ordered = false;\n  } // priority is optional.\n\n\n  if (params.priority && typeof params.priority !== 'string') throw new TypeError('invalid params.priority'); // label is optional.\n\n  if (params.label && typeof params.label !== 'string') throw new TypeError('invalid params.label'); // protocol is optional.\n\n  if (params.protocol && typeof params.protocol !== 'string') throw new TypeError('invalid params.protocol');\n}\n\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\n\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n  var extendedRtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  }; // Match media codecs and keep the order preferred by remoteCaps.\n\n  var _iterator8 = _createForOfIteratorHelper(remoteCaps.codecs || []),\n      _step8;\n\n  try {\n    var _loop = function _loop() {\n      var remoteCodec = _step8.value;\n      if (isRtxCodec(remoteCodec)) return \"continue\";\n      var matchingLocalCodec = (localCaps.codecs || []).find(function (localCodec) {\n        return matchCodecs(localCodec, remoteCodec, {\n          strict: true,\n          modify: true\n        });\n      });\n      if (!matchingLocalCodec) return \"continue\";\n      var extendedCodec = {\n        mimeType: matchingLocalCodec.mimeType,\n        kind: matchingLocalCodec.kind,\n        clockRate: matchingLocalCodec.clockRate,\n        channels: matchingLocalCodec.channels,\n        localPayloadType: matchingLocalCodec.preferredPayloadType,\n        localRtxPayloadType: undefined,\n        remotePayloadType: remoteCodec.preferredPayloadType,\n        remoteRtxPayloadType: undefined,\n        localParameters: matchingLocalCodec.parameters,\n        remoteParameters: remoteCodec.parameters,\n        rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n      };\n      extendedRtpCapabilities.codecs.push(extendedCodec);\n    };\n\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    } // Match RTX codecs.\n\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  var _iterator9 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step9;\n\n  try {\n    var _loop2 = function _loop2() {\n      var extendedCodec = _step9.value;\n      var matchingLocalRtxCodec = localCaps.codecs.find(function (localCodec) {\n        return isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType;\n      });\n      var matchingRemoteRtxCodec = remoteCaps.codecs.find(function (remoteCodec) {\n        return isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType;\n      });\n\n      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n      }\n    };\n\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      _loop2();\n    } // Match header extensions.\n\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  var _iterator10 = _createForOfIteratorHelper(remoteCaps.headerExtensions),\n      _step10;\n\n  try {\n    var _loop3 = function _loop3() {\n      var remoteExt = _step10.value;\n      var matchingLocalExt = localCaps.headerExtensions.find(function (localExt) {\n        return matchHeaderExtensions(localExt, remoteExt);\n      });\n      if (!matchingLocalExt) return \"continue\";\n      var extendedExt = {\n        kind: remoteExt.kind,\n        uri: remoteExt.uri,\n        sendId: matchingLocalExt.preferredId,\n        recvId: remoteExt.preferredId,\n        encrypt: matchingLocalExt.preferredEncrypt,\n        direction: 'sendrecv'\n      };\n\n      switch (remoteExt.direction) {\n        case 'sendrecv':\n          extendedExt.direction = 'sendrecv';\n          break;\n\n        case 'recvonly':\n          extendedExt.direction = 'sendonly';\n          break;\n\n        case 'sendonly':\n          extendedExt.direction = 'recvonly';\n          break;\n\n        case 'inactive':\n          extendedExt.direction = 'inactive';\n          break;\n      }\n\n      extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    };\n\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _ret2 = _loop3();\n\n      if (_ret2 === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return extendedRtpCapabilities;\n}\n\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\n\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n  var rtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n\n  var _iterator11 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var extendedCodec = _step11.value;\n      var codec = {\n        mimeType: extendedCodec.mimeType,\n        kind: extendedCodec.kind,\n        preferredPayloadType: extendedCodec.remotePayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.localParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpCapabilities.codecs.push(codec); // Add RTX codec.\n\n      if (!extendedCodec.remoteRtxPayloadType) continue;\n      var rtxCodec = {\n        mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n        kind: extendedCodec.kind,\n        preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.remotePayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpCapabilities.codecs.push(rtxCodec); // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var extendedExtension = _step12.value;\n\n      // Ignore RTP extensions not valid for receiving.\n      if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {\n        continue;\n      }\n\n      var ext = {\n        kind: extendedExtension.kind,\n        uri: extendedExtension.uri,\n        preferredId: extendedExtension.recvId,\n        preferredEncrypt: extendedExtension.encrypt,\n        direction: extendedExtension.direction\n      };\n      rtpCapabilities.headerExtensions.push(ext);\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return rtpCapabilities;\n}\n\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\n\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n  var rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  var _iterator13 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var extendedCodec = _step13.value;\n      if (extendedCodec.kind !== kind) continue;\n      var codec = {\n        mimeType: extendedCodec.mimeType,\n        payloadType: extendedCodec.localPayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.localParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpParameters.codecs.push(codec); // Add RTX codec.\n\n      if (extendedCodec.localRtxPayloadType) {\n        var rtxCodec = {\n          mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n          payloadType: extendedCodec.localRtxPayloadType,\n          clockRate: extendedCodec.clockRate,\n          parameters: {\n            apt: extendedCodec.localPayloadType\n          },\n          rtcpFeedback: []\n        };\n        rtpParameters.codecs.push(rtxCodec);\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var _iterator14 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var extendedExtension = _step14.value;\n\n      // Ignore RTP extensions of a different kind and those not valid for sending.\n      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n        continue;\n      }\n\n      var ext = {\n        uri: extendedExtension.uri,\n        id: extendedExtension.sendId,\n        encrypt: extendedExtension.encrypt,\n        parameters: {}\n      };\n      rtpParameters.headerExtensions.push(ext);\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\n\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n  var rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  var _iterator15 = _createForOfIteratorHelper(extendedRtpCapabilities.codecs),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var extendedCodec = _step15.value;\n      if (extendedCodec.kind !== kind) continue;\n      var _codec3 = {\n        mimeType: extendedCodec.mimeType,\n        payloadType: extendedCodec.localPayloadType,\n        clockRate: extendedCodec.clockRate,\n        channels: extendedCodec.channels,\n        parameters: extendedCodec.remoteParameters,\n        rtcpFeedback: extendedCodec.rtcpFeedback\n      };\n      rtpParameters.codecs.push(_codec3); // Add RTX codec.\n\n      if (extendedCodec.localRtxPayloadType) {\n        var rtxCodec = {\n          mimeType: \"\".concat(extendedCodec.kind, \"/rtx\"),\n          payloadType: extendedCodec.localRtxPayloadType,\n          clockRate: extendedCodec.clockRate,\n          parameters: {\n            apt: extendedCodec.localPayloadType\n          },\n          rtcpFeedback: []\n        };\n        rtpParameters.codecs.push(rtxCodec);\n      }\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  var _iterator16 = _createForOfIteratorHelper(extendedRtpCapabilities.headerExtensions),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var extendedExtension = _step16.value;\n\n      // Ignore RTP extensions of a different kind and those not valid for sending.\n      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n        continue;\n      }\n\n      var ext = {\n        uri: extendedExtension.uri,\n        id: extendedExtension.sendId,\n        encrypt: extendedExtension.encrypt,\n        parameters: {}\n      };\n      rtpParameters.headerExtensions.push(ext);\n    } // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  if (rtpParameters.headerExtensions.some(function (ext) {\n    return ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01';\n  })) {\n    var _iterator17 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step17;\n\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var codec = _step17.value;\n        codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'goog-remb';\n        });\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n  } else if (rtpParameters.headerExtensions.some(function (ext) {\n    return ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time';\n  })) {\n    var _iterator18 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var _codec = _step18.value;\n        _codec.rtcpFeedback = (_codec.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'transport-cc';\n        });\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n  } else {\n    var _iterator19 = _createForOfIteratorHelper(rtpParameters.codecs),\n        _step19;\n\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var _codec2 = _step19.value;\n        _codec2.rtcpFeedback = (_codec2.rtcpFeedback || []).filter(function (fb) {\n          return fb.type !== 'transport-cc' && fb.type !== 'goog-remb';\n        });\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\n\nfunction reduceCodecs(codecs, capCodec) {\n  var filteredCodecs = []; // If no capability codec is given, take the first one (and RTX).\n\n  if (!capCodec) {\n    filteredCodecs.push(codecs[0]);\n    if (isRtxCodec(codecs[1])) filteredCodecs.push(codecs[1]);\n  } // Otherwise look for a compatible set of codecs.\n  else {\n      for (var idx = 0; idx < codecs.length; ++idx) {\n        if (matchCodecs(codecs[idx], capCodec)) {\n          filteredCodecs.push(codecs[idx]);\n          if (isRtxCodec(codecs[idx + 1])) filteredCodecs.push(codecs[idx + 1]);\n          break;\n        }\n      }\n\n      if (filteredCodecs.length === 0) throw new TypeError('no matching codec found');\n    }\n\n  return filteredCodecs;\n}\n\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\n\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n  // Clone given reference video RTP parameters.\n  videoRtpParameters = utils_1.clone(videoRtpParameters); // This may throw.\n\n  validateRtpParameters(videoRtpParameters);\n  var rtpParameters = {\n    mid: RTP_PROBATOR_MID,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [{\n      ssrc: RTP_PROBATOR_SSRC\n    }],\n    rtcp: {\n      cname: 'probator'\n    }\n  };\n  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n  return rtpParameters;\n}\n\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\n\nfunction canSend(kind, extendedRtpCapabilities) {\n  return extendedRtpCapabilities.codecs.some(function (codec) {\n    return codec.kind === kind;\n  });\n}\n\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\n\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n  // This may throw.\n  validateRtpParameters(rtpParameters);\n  if (rtpParameters.codecs.length === 0) return false;\n  var firstMediaCodec = rtpParameters.codecs[0];\n  return extendedRtpCapabilities.codecs.some(function (codec) {\n    return codec.remotePayloadType === firstMediaCodec.payloadType;\n  });\n}\n\nexports.canReceive = canReceive;\n\nfunction isRtxCodec(codec) {\n  if (!codec) return false;\n  return /.+\\/rtx$/i.test(codec.mimeType);\n}\n\nfunction matchCodecs(aCodec, bCodec) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$strict = _ref.strict,\n      strict = _ref$strict === void 0 ? false : _ref$strict,\n      _ref$modify = _ref.modify,\n      modify = _ref$modify === void 0 ? false : _ref$modify;\n\n  var aMimeType = aCodec.mimeType.toLowerCase();\n  var bMimeType = bCodec.mimeType.toLowerCase();\n  if (aMimeType !== bMimeType) return false;\n  if (aCodec.clockRate !== bCodec.clockRate) return false;\n  if (aCodec.channels !== bCodec.channels) return false; // Per codec special checks.\n\n  switch (aMimeType) {\n    case 'video/h264':\n      {\n        var aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n        var bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n        if (aPacketizationMode !== bPacketizationMode) return false; // If strict matching check profile-level-id.\n\n        if (strict) {\n          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) return false;\n          var selectedProfileLevelId;\n\n          try {\n            selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n          } catch (error) {\n            return false;\n          }\n\n          if (modify) {\n            if (selectedProfileLevelId) aCodec.parameters['profile-level-id'] = selectedProfileLevelId;else delete aCodec.parameters['profile-level-id'];\n          }\n        }\n\n        break;\n      }\n\n    case 'video/vp9':\n      {\n        // If strict matching check profile-id.\n        if (strict) {\n          var aProfileId = aCodec.parameters['profile-id'] || 0;\n          var bProfileId = bCodec.parameters['profile-id'] || 0;\n          if (aProfileId !== bProfileId) return false;\n        }\n\n        break;\n      }\n  }\n\n  return true;\n}\n\nfunction matchHeaderExtensions(aExt, bExt) {\n  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;\n  if (aExt.uri !== bExt.uri) return false;\n  return true;\n}\n\nfunction reduceRtcpFeedback(codecA, codecB) {\n  var reducedRtcpFeedback = [];\n\n  var _iterator20 = _createForOfIteratorHelper(codecA.rtcpFeedback || []),\n      _step20;\n\n  try {\n    var _loop4 = function _loop4() {\n      var aFb = _step20.value;\n      var matchingBFb = (codecB.rtcpFeedback || []).find(function (bFb) {\n        return bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter);\n      });\n      if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);\n    };\n\n    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n      _loop4();\n    }\n  } catch (err) {\n    _iterator20.e(err);\n  } finally {\n    _iterator20.f();\n  }\n\n  return reducedRtcpFeedback;\n}\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/ortc.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/scalabilityModes.js":
/*!***************************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/scalabilityModes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\\\d{0,1})T([1-9]\\\\d{0,1})');\n\nfunction parse(scalabilityMode) {\n  var match = ScalabilityModeRegex.exec(scalabilityMode || '');\n\n  if (match) {\n    return {\n      spatialLayers: Number(match[1]),\n      temporalLayers: Number(match[2])\n    };\n  } else {\n    return {\n      spatialLayers: 1,\n      temporalLayers: 1\n    };\n  }\n}\n\nexports.parse = parse;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/scalabilityModes.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/types.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/types.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__export(__webpack_require__(/*! ./Device */ \"./node_modules/mediasoup-client/lib/Device.js\"));\n\n__export(__webpack_require__(/*! ./Transport */ \"./node_modules/mediasoup-client/lib/Transport.js\"));\n\n__export(__webpack_require__(/*! ./Producer */ \"./node_modules/mediasoup-client/lib/Producer.js\"));\n\n__export(__webpack_require__(/*! ./Consumer */ \"./node_modules/mediasoup-client/lib/Consumer.js\"));\n\n__export(__webpack_require__(/*! ./DataProducer */ \"./node_modules/mediasoup-client/lib/DataProducer.js\"));\n\n__export(__webpack_require__(/*! ./DataConsumer */ \"./node_modules/mediasoup-client/lib/DataConsumer.js\"));\n\n__export(__webpack_require__(/*! ./handlers/HandlerInterface */ \"./node_modules/mediasoup-client/lib/handlers/HandlerInterface.js\"));\n\n__export(__webpack_require__(/*! ./errors */ \"./node_modules/mediasoup-client/lib/errors.js\"));\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/types.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/mediasoup-client/lib/utils.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Clones the given object/array.\n *\n * @param {Object|Array} obj\n *\n * @returns {Object|Array}\n */\n\nfunction clone(data) {\n  if (_typeof(data) !== 'object') return {};\n  return JSON.parse(JSON.stringify(data));\n}\n\nexports.clone = clone;\n/**\n * Generates a random positive integer.\n */\n\nfunction generateRandomNumber() {\n  return Math.round(Math.random() * 10000000);\n}\n\nexports.generateRandomNumber = generateRandomNumber;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/lib/utils.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/mediasoup-client/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/debug/src/common.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug[\"default\"] = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/mediasoup-client/node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n    newDebug.log = this.log;\n    return newDebug;\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @return {String} namespaces\n  * @api public\n  */\n\n\n  function disable() {\n    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {\n      return '-' + namespace;\n    }))).join(',');\n    createDebug.enable('');\n    return namespaces;\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Convert regexp to namespace\n  *\n  * @param {RegExp} regxep\n  * @return {String} namespace\n  * @api private\n  */\n\n\n  function toNamespace(regexp) {\n    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/mediasoup-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mediasoup-client/node_modules/ms/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///./node_modules/mediasoup-client/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar R = (typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\n\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\nmodule.exports = EventEmitter; // Backwards-compat with node 0.10.x\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + _typeof(listener));\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function get() {\n    return defaultMaxListeners;\n  },\n  set: function set(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    } // At least give some kind of context to the user\n\n\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) {\n      ReflectApply(listeners[i], this, args);\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    } // Check for listener leak\n\n\n    m = _getMaxListeners(target);\n\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true; // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n\n  return this;\n};\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) {\n    list[index] = list[index + 1];\n  }\n\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/EnhancedEventEmitter.js":
/*!****************************************************************!*\
  !*** ./node_modules/protoo-client/lib/EnhancedEventEmitter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _require = __webpack_require__(/*! events */ \"./node_modules/node-libs-browser/node_modules/events/events.js\"),\n    EventEmitter = _require.EventEmitter;\n\nvar Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(EnhancedEventEmitter, _EventEmitter);\n\n  var _super = _createSuper(EnhancedEventEmitter);\n\n  function EnhancedEventEmitter(logger) {\n    var _this;\n\n    _classCallCheck(this, EnhancedEventEmitter);\n\n    _this = _super.call(this);\n\n    _this.setMaxListeners(Infinity);\n\n    _this._logger = logger || new Logger('EnhancedEventEmitter');\n    return _this;\n  }\n\n  _createClass(EnhancedEventEmitter, [{\n    key: \"safeEmit\",\n    value: function safeEmit(event) {\n      try {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        this.emit.apply(this, [event].concat(args));\n      } catch (error) {\n        this._logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);\n      }\n    }\n  }, {\n    key: \"safeEmitAsPromise\",\n    value: function () {\n      var _safeEmitAsPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(event) {\n        var _this2 = this;\n\n        var _len2,\n            args,\n            _key2,\n            _args = arguments;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                  args[_key2 - 1] = _args[_key2];\n                }\n\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this2.safeEmit.apply(_this2, [event].concat(args, [resolve, reject]));\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function safeEmitAsPromise(_x) {\n        return _safeEmitAsPromise.apply(this, arguments);\n      }\n\n      return safeEmitAsPromise;\n    }()\n  }]);\n\n  return EnhancedEventEmitter;\n}(EventEmitter);\n\nmodule.exports = EnhancedEventEmitter;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/EnhancedEventEmitter.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Logger.js":
/*!**************************************************!*\
  !*** ./node_modules/protoo-client/lib/Logger.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/protoo-client/node_modules/debug/src/browser.js\");\n\nvar APP_NAME = 'protoo-client';\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(prefix) {\n    _classCallCheck(this, Logger);\n\n    if (prefix) {\n      this._debug = debug(\"\".concat(APP_NAME, \":\").concat(prefix));\n      this._warn = debug(\"\".concat(APP_NAME, \":WARN:\").concat(prefix));\n      this._error = debug(\"\".concat(APP_NAME, \":ERROR:\").concat(prefix));\n    } else {\n      this._debug = debug(APP_NAME);\n      this._warn = debug(\"\".concat(APP_NAME, \":WARN\"));\n      this._error = debug(\"\".concat(APP_NAME, \":ERROR\"));\n    }\n    /* eslint-disable no-console */\n\n\n    this._debug.log = console.info.bind(console);\n    this._warn.log = console.warn.bind(console);\n    this._error.log = console.error.bind(console);\n    /* eslint-enable no-console */\n  }\n\n  _createClass(Logger, [{\n    key: \"debug\",\n    get: function get() {\n      return this._debug;\n    }\n  }, {\n    key: \"warn\",\n    get: function get() {\n      return this._warn;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Logger;\n}();\n\nmodule.exports = Logger;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Logger.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Message.js":
/*!***************************************************!*\
  !*** ./node_modules/protoo-client/lib/Message.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\n\nvar _require = __webpack_require__(/*! ./utils */ \"./node_modules/protoo-client/lib/utils.js\"),\n    generateRandomNumber = _require.generateRandomNumber;\n\nvar logger = new Logger('Message');\n\nvar Message = /*#__PURE__*/function () {\n  function Message() {\n    _classCallCheck(this, Message);\n  }\n\n  _createClass(Message, null, [{\n    key: \"parse\",\n    value: function parse(raw) {\n      var object;\n      var message = {};\n\n      try {\n        object = JSON.parse(raw);\n      } catch (error) {\n        logger.error('parse() | invalid JSON: %s', error);\n        return;\n      }\n\n      if (_typeof(object) !== 'object' || Array.isArray(object)) {\n        logger.error('parse() | not an object');\n        return;\n      } // Request.\n\n\n      if (object.request) {\n        message.request = true;\n\n        if (typeof object.method !== 'string') {\n          logger.error('parse() | missing/invalid method field');\n          return;\n        }\n\n        if (typeof object.id !== 'number') {\n          logger.error('parse() | missing/invalid id field');\n          return;\n        }\n\n        message.id = object.id;\n        message.method = object.method;\n        message.data = object.data || {};\n      } // Response.\n      else if (object.response) {\n          message.response = true;\n\n          if (typeof object.id !== 'number') {\n            logger.error('parse() | missing/invalid id field');\n            return;\n          }\n\n          message.id = object.id; // Success.\n\n          if (object.ok) {\n            message.ok = true;\n            message.data = object.data || {};\n          } // Error.\n          else {\n              message.ok = false;\n              message.errorCode = object.errorCode;\n              message.errorReason = object.errorReason;\n            }\n        } // Notification.\n        else if (object.notification) {\n            message.notification = true;\n\n            if (typeof object.method !== 'string') {\n              logger.error('parse() | missing/invalid method field');\n              return;\n            }\n\n            message.method = object.method;\n            message.data = object.data || {};\n          } // Invalid.\n          else {\n              logger.error('parse() | missing request/response field');\n              return;\n            }\n\n      return message;\n    }\n  }, {\n    key: \"createRequest\",\n    value: function createRequest(method, data) {\n      var request = {\n        request: true,\n        id: generateRandomNumber(),\n        method: method,\n        data: data || {}\n      };\n      return request;\n    }\n  }, {\n    key: \"createSuccessResponse\",\n    value: function createSuccessResponse(request, data) {\n      var response = {\n        response: true,\n        id: request.id,\n        ok: true,\n        data: data || {}\n      };\n      return response;\n    }\n  }, {\n    key: \"createErrorResponse\",\n    value: function createErrorResponse(request, errorCode, errorReason) {\n      var response = {\n        response: true,\n        id: request.id,\n        ok: false,\n        errorCode: errorCode,\n        errorReason: errorReason\n      };\n      return response;\n    }\n  }, {\n    key: \"createNotification\",\n    value: function createNotification(method, data) {\n      var notification = {\n        notification: true,\n        method: method,\n        data: data || {}\n      };\n      return notification;\n    }\n  }]);\n\n  return Message;\n}();\n\nmodule.exports = Message;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Message.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Peer.js":
/*!************************************************!*\
  !*** ./node_modules/protoo-client/lib/Peer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/protoo-client/lib/EnhancedEventEmitter.js\");\n\nvar Message = __webpack_require__(/*! ./Message */ \"./node_modules/protoo-client/lib/Message.js\");\n\nvar logger = new Logger('Peer');\n\nvar Peer = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(Peer, _EnhancedEventEmitter);\n\n  var _super = _createSuper(Peer);\n\n  /**\n   * @param {protoo.Transport} transport\n   *\n   * @emits open\n   * @emits {currentAttempt: Number} failed\n   * @emits disconnected\n   * @emits close\n   * @emits {request: protoo.Request, accept: Function, reject: Function} request\n   * @emits {notification: protoo.Notification} notification\n   */\n  function Peer(transport) {\n    var _this;\n\n    _classCallCheck(this, Peer);\n\n    _this = _super.call(this, logger);\n    logger.debug('constructor()'); // Closed flag.\n    // @type {Boolean}\n\n    _this._closed = false; // Transport.\n    // @type {protoo.Transport}\n\n    _this._transport = transport; // Connected flag.\n    // @type {Boolean}\n\n    _this._connected = false; // Custom data object.\n    // @type {Object}\n\n    _this._data = {}; // Map of pending sent request objects indexed by request id.\n    // @type {Map<Number, Object>}\n\n    _this._sents = new Map(); // Handle transport.\n\n    _this._handleTransport();\n\n    return _this;\n  }\n  /**\n   * Whether the Peer is closed.\n   *\n   * @returns {Boolean}\n   */\n\n\n  _createClass(Peer, [{\n    key: \"close\",\n\n    /**\n     * Close this Peer and its Transport.\n     */\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()');\n      this._closed = true;\n      this._connected = false; // Close Transport.\n\n      this._transport.close(); // Close every pending sent.\n\n\n      var _iterator = _createForOfIteratorHelper(this._sents.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var sent = _step.value;\n          sent.close();\n        } // Emit 'close' event.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.safeEmit('close');\n    }\n    /**\n     * Send a protoo request to the server-side Room.\n     *\n     * @param {String} method\n     * @param {Object} [data]\n     *\n     * @async\n     * @returns {Object} The response data Object if a success response is received.\n     */\n\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(method) {\n        var _this2 = this;\n\n        var data,\n            request,\n            _args = arguments;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;\n                request = Message.createRequest(method, data);\n\n                this._logger.debug('request() [method:%s, id:%s]', method, request.id); // This may throw.\n\n\n                _context.next = 5;\n                return this._transport.send(request);\n\n              case 5:\n                return _context.abrupt(\"return\", new Promise(function (pResolve, pReject) {\n                  var timeout = 1500 * (15 + 0.1 * _this2._sents.size);\n                  var sent = {\n                    id: request.id,\n                    method: request.method,\n                    resolve: function resolve(data2) {\n                      if (!_this2._sents[\"delete\"](request.id)) return;\n                      clearTimeout(sent.timer);\n                      pResolve(data2);\n                    },\n                    reject: function reject(error) {\n                      if (!_this2._sents[\"delete\"](request.id)) return;\n                      clearTimeout(sent.timer);\n                      pReject(error);\n                    },\n                    timer: setTimeout(function () {\n                      if (!_this2._sents[\"delete\"](request.id)) return;\n                      pReject(new Error('request timeout'));\n                    }, timeout),\n                    close: function close() {\n                      clearTimeout(sent.timer);\n                      pReject(new Error('peer closed'));\n                    }\n                  }; // Add sent stuff to the map.\n\n                  _this2._sents.set(request.id, sent);\n                }));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function request(_x) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n    /**\n     * Send a protoo notification to the server-side Room.\n     *\n     * @param {String} method\n     * @param {Object} [data]\n     *\n     * @async\n     */\n\n  }, {\n    key: \"notify\",\n    value: function () {\n      var _notify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(method) {\n        var data,\n            notification,\n            _args2 = arguments;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                data = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : undefined;\n                notification = Message.createNotification(method, data);\n\n                this._logger.debug('notify() [method:%s]', method); // This may throw.\n\n\n                _context2.next = 5;\n                return this._transport.send(notification);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function notify(_x2) {\n        return _notify.apply(this, arguments);\n      }\n\n      return notify;\n    }()\n  }, {\n    key: \"_handleTransport\",\n    value: function _handleTransport() {\n      var _this3 = this;\n\n      if (this._transport.closed) {\n        this._closed = true;\n        setTimeout(function () {\n          if (_this3._closed) return;\n          _this3._connected = false;\n\n          _this3.safeEmit('close');\n        });\n        return;\n      }\n\n      this._transport.on('open', function () {\n        if (_this3._closed) return;\n        logger.debug('emit \"open\"');\n        _this3._connected = true;\n\n        _this3.safeEmit('open');\n      });\n\n      this._transport.on('disconnected', function () {\n        if (_this3._closed) return;\n        logger.debug('emit \"disconnected\"');\n        _this3._connected = false;\n\n        _this3.safeEmit('disconnected');\n      });\n\n      this._transport.on('failed', function (currentAttempt) {\n        if (_this3._closed) return;\n        logger.debug('emit \"failed\" [currentAttempt:%s]', currentAttempt);\n        _this3._connected = false;\n\n        _this3.safeEmit('failed', currentAttempt);\n      });\n\n      this._transport.on('close', function () {\n        if (_this3._closed) return;\n        _this3._closed = true;\n        logger.debug('emit \"close\"');\n        _this3._connected = false;\n\n        _this3.safeEmit('close');\n      });\n\n      this._transport.on('message', function (message) {\n        if (message.request) _this3._handleRequest(message);else if (message.response) _this3._handleResponse(message);else if (message.notification) _this3._handleNotification(message);\n      });\n    }\n  }, {\n    key: \"_handleRequest\",\n    value: function _handleRequest(request) {\n      var _this4 = this;\n\n      try {\n        this.emit('request', // Request.\n        request, // accept() function.\n        function (data) {\n          var response = Message.createSuccessResponse(request, data);\n\n          _this4._transport.send(response)[\"catch\"](function () {});\n        }, // reject() function.\n        function (errorCode, errorReason) {\n          if (errorCode instanceof Error) {\n            errorCode = 500;\n            errorReason = String(errorCode);\n          } else if (typeof errorCode === 'number' && errorReason instanceof Error) {\n            errorReason = String(errorReason);\n          }\n\n          var response = Message.createErrorResponse(request, errorCode, errorReason);\n\n          _this4._transport.send(response)[\"catch\"](function () {});\n        });\n      } catch (error) {\n        var response = Message.createErrorResponse(request, 500, String(error));\n\n        this._transport.send(response)[\"catch\"](function () {});\n      }\n    }\n  }, {\n    key: \"_handleResponse\",\n    value: function _handleResponse(response) {\n      var sent = this._sents.get(response.id);\n\n      if (!sent) {\n        logger.error('received response does not match any sent request [id:%s]', response.id);\n        return;\n      }\n\n      if (response.ok) {\n        sent.resolve(response.data);\n      } else {\n        var error = new Error(response.errorReason);\n        error.code = response.errorCode;\n        sent.reject(error);\n      }\n    }\n  }, {\n    key: \"_handleNotification\",\n    value: function _handleNotification(notification) {\n      this.safeEmit('notification', notification);\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n    /**\n     * Whether the Peer is connected.\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected;\n    }\n    /**\n     * App custom data.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n    /**\n     * Invalid setter.\n     */\n    ,\n    set: function set(data) // eslint-disable-line no-unused-vars\n    {\n      throw new Error('cannot override data object');\n    }\n  }]);\n\n  return Peer;\n}(EnhancedEventEmitter);\n\nmodule.exports = Peer;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Peer.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _require = __webpack_require__(/*! ../package.json */ \"./node_modules/protoo-client/package.json\"),\n    version = _require.version;\n\nvar Peer = __webpack_require__(/*! ./Peer */ \"./node_modules/protoo-client/lib/Peer.js\");\n\nvar WebSocketTransport = __webpack_require__(/*! ./transports/WebSocketTransport */ \"./node_modules/protoo-client/lib/transports/WebSocketTransport.js\");\n/**\n * Expose mediasoup-client version.\n *\n * @type {String}\n */\n\n\nexports.version = version;\n/**\n * Expose Peer class.\n *\n * @type {Class}\n */\n\nexports.Peer = Peer;\n/**\n * Expose WebSocketTransport class.\n *\n * @type {Class}\n */\n\nexports.WebSocketTransport = WebSocketTransport;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/transports/WebSocketTransport.js":
/*!*************************************************************************!*\
  !*** ./node_modules/protoo-client/lib/transports/WebSocketTransport.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar W3CWebSocket = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket;\n\nvar retry = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\n\nvar Logger = __webpack_require__(/*! ../Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\n\nvar EnhancedEventEmitter = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./node_modules/protoo-client/lib/EnhancedEventEmitter.js\");\n\nvar Message = __webpack_require__(/*! ../Message */ \"./node_modules/protoo-client/lib/Message.js\");\n\nvar WS_SUBPROTOCOL = 'protoo';\nvar DEFAULT_RETRY_OPTIONS = {\n  retries: 10,\n  factor: 2,\n  minTimeout: 1 * 1000,\n  maxTimeout: 8 * 1000\n};\nvar logger = new Logger('WebSocketTransport');\n\nvar WebSocketTransport = /*#__PURE__*/function (_EnhancedEventEmitter) {\n  _inherits(WebSocketTransport, _EnhancedEventEmitter);\n\n  var _super = _createSuper(WebSocketTransport);\n\n  /**\n   * @param {String} url - WebSocket URL.\n   * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.\n   */\n  function WebSocketTransport(url, options) {\n    var _this;\n\n    _classCallCheck(this, WebSocketTransport);\n\n    _this = _super.call(this, logger);\n    logger.debug('constructor() [url:%s, options:%o]', url, options); // Closed flag.\n    // @type {Boolean}\n\n    _this._closed = false; // WebSocket URL.\n    // @type {String}\n\n    _this._url = url; // Options.\n    // @type {Object}\n\n    _this._options = options || {}; // WebSocket instance.\n    // @type {WebSocket}\n\n    _this._ws = null; // Run the WebSocket.\n\n    _this._runWebSocket();\n\n    return _this;\n  }\n\n  _createClass(WebSocketTransport, [{\n    key: \"close\",\n    value: function close() {\n      if (this._closed) return;\n      logger.debug('close()'); // Don't wait for the WebSocket 'close' event, do it now.\n\n      this._closed = true;\n      this.safeEmit('close');\n\n      try {\n        this._ws.onopen = null;\n        this._ws.onclose = null;\n        this._ws.onerror = null;\n        this._ws.onmessage = null;\n\n        this._ws.close();\n      } catch (error) {\n        logger.error('close() | error closing the WebSocket: %o', error);\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(message) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._closed) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('transport closed');\n\n              case 2:\n                _context.prev = 2;\n\n                this._ws.send(JSON.stringify(message));\n\n                _context.next = 10;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](2);\n                logger.warn('send() failed:%o', _context.t0);\n                throw _context.t0;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 6]]);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"_runWebSocket\",\n    value: function _runWebSocket() {\n      var _this2 = this;\n\n      var operation = retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n      var wasConnected = false;\n      operation.attempt(function (currentAttempt) {\n        if (_this2._closed) {\n          operation.stop();\n          return;\n        }\n\n        logger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);\n        _this2._ws = new W3CWebSocket(_this2._url, WS_SUBPROTOCOL, _this2._options.origin, _this2._options.headers, _this2._options.requestOptions, _this2._options.clientConfig);\n\n        _this2._ws.onopen = function () {\n          if (_this2._closed) return;\n          wasConnected = true; // Emit 'open' event.\n\n          _this2.safeEmit('open');\n        };\n\n        _this2._ws.onclose = function (event) {\n          if (_this2._closed) return;\n          logger.warn('WebSocket \"close\" event [wasClean:%s, code:%s, reason:\"%s\"]', event.wasClean, event.code, event.reason); // Don't retry if code is 4000 (closed by the server).\n\n          if (event.code !== 4000) {\n            // If it was not connected, try again.\n            if (!wasConnected) {\n              _this2.safeEmit('failed', currentAttempt);\n\n              if (_this2._closed) return;\n              if (operation.retry(true)) return;\n            } // If it was connected, start from scratch.\n            else {\n                operation.stop();\n\n                _this2.safeEmit('disconnected');\n\n                if (_this2._closed) return;\n\n                _this2._runWebSocket();\n\n                return;\n              }\n          }\n\n          _this2._closed = true; // Emit 'close' event.\n\n          _this2.safeEmit('close');\n        };\n\n        _this2._ws.onerror = function () {\n          if (_this2._closed) return;\n          logger.error('WebSocket \"error\" event');\n        };\n\n        _this2._ws.onmessage = function (event) {\n          if (_this2._closed) return;\n          var message = Message.parse(event.data);\n          if (!message) return;\n\n          if (_this2.listenerCount('message') === 0) {\n            logger.error('no listeners for WebSocket \"message\" event, ignoring received message');\n            return;\n          } // Emit 'message' event.\n\n\n          _this2.safeEmit('message', message);\n        };\n      });\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._closed;\n    }\n  }]);\n\n  return WebSocketTransport;\n}(EnhancedEventEmitter);\n\nmodule.exports = WebSocketTransport;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/transports/WebSocketTransport.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/lib/utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Generates a random positive integer.\n *\n * @returns {Number}\n */\nexports.generateRandomNumber = function () {\n  return Math.round(Math.random() * 10000000);\n};\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/utils.js?");

/***/ }),

/***/ "./node_modules/protoo-client/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/protoo-client/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/protoo-client/node_modules/debug/src/common.js\")(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protoo-client/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/protoo-client/node_modules/debug/src/common.js":
/*!*********************************************************************!*\
  !*** ./node_modules/protoo-client/node_modules/debug/src/common.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug[\"default\"] = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/protoo-client/node_modules/ms/index.js\");\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n    newDebug.log = this.log;\n    return newDebug;\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @return {String} namespaces\n  * @api public\n  */\n\n\n  function disable() {\n    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {\n      return '-' + namespace;\n    }))).join(',');\n    createDebug.enable('');\n    return namespaces;\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Convert regexp to namespace\n  *\n  * @param {RegExp} regxep\n  * @return {String} namespace\n  * @api private\n  */\n\n\n  function toNamespace(regexp) {\n    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n//# sourceURL=webpack:///./node_modules/protoo-client/node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/protoo-client/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/protoo-client/node_modules/ms/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n\n  var type = _typeof(val);\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options[\"long\"] ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n\n  return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n//# sourceURL=webpack:///./node_modules/protoo-client/node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/protoo-client/package.json":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/package.json ***!
  \*************************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, optionalDependencies, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_args\\\":[[\\\"protoo-client@4.0.4\\\",\\\"/home/ubuntu/networked-aframe\\\"]],\\\"_from\\\":\\\"protoo-client@4.0.4\\\",\\\"_id\\\":\\\"protoo-client@4.0.4\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-+WZUJJTlBSTWYeNu0Tv8SGI3kjettLvr2IUdBsAfioi0Szf8peeky79h6li7gThA3pIpNC+A+IuCUWaK7MlFfQ==\\\",\\\"_location\\\":\\\"/protoo-client\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"protoo-client@4.0.4\\\",\\\"name\\\":\\\"protoo-client\\\",\\\"escapedName\\\":\\\"protoo-client\\\",\\\"rawSpec\\\":\\\"4.0.4\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"4.0.4\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/protoo-client/-/protoo-client-4.0.4.tgz\\\",\\\"_spec\\\":\\\"4.0.4\\\",\\\"_where\\\":\\\"/home/ubuntu/networked-aframe\\\",\\\"author\\\":{\\\"name\\\":\\\"Iaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/ibc/protoo/issues\\\"},\\\"dependencies\\\":{\\\"debug\\\":\\\"^4.1.1\\\",\\\"events\\\":\\\"^3.1.0\\\",\\\"retry\\\":\\\"^0.12.0\\\",\\\"websocket\\\":\\\"^1.0.31\\\"},\\\"description\\\":\\\"protoo JavaScript client module\\\",\\\"devDependencies\\\":{\\\"eslint\\\":\\\"^5.16.0\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=8.0.0\\\"},\\\"homepage\\\":\\\"https://protoojs.org\\\",\\\"keywords\\\":[\\\"nodejs\\\",\\\"browser\\\",\\\"websocket\\\"],\\\"license\\\":\\\"MIT\\\",\\\"main\\\":\\\"lib/index.js\\\",\\\"name\\\":\\\"protoo-client\\\",\\\"optionalDependencies\\\":{\\\"websocket\\\":\\\"^1.0.31\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/ibc/protoo.git\\\"},\\\"scripts\\\":{\\\"lint\\\":\\\"eslint -c .eslintrc.js lib\\\"},\\\"version\\\":\\\"4.0.4\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/protoo-client/package.json?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack:///./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function (options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n    forever: options && options.forever,\n    unref: options && options.unref,\n    maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function (options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  } // sort the array numerically ascending\n\n\n  timeouts.sort(function (a, b) {\n    return a - b;\n  });\n  return timeouts;\n};\n\nexports.createTimeout = function (attempt, opts) {\n  var random = opts.randomize ? Math.random() + 1 : 1;\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n  return timeout;\n};\n\nexports.wrap = function (obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op = exports.operation(options);\n      var args = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n      args.push(function (err) {\n        if (op.retry(err)) {\n          return;\n        }\n\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n\n        callback.apply(this, arguments);\n      });\n      op.attempt(function () {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n\n    obj[method].options = options;\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = {\n      forever: options\n    };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\n\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function () {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts;\n};\n\nRetryOperation.prototype.stop = function () {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function (err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n\n  var currentTime = new Date().getTime();\n\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function () {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function () {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n        self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n    timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function (fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function () {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype[\"try\"] = function (fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function (fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype[\"try\"];\n\nRetryOperation.prototype.errors = function () {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function () {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function () {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{\n    name: 'name'\n  }],\n  i: [{\n    name: 'description'\n  }],\n  u: [{\n    name: 'uri'\n  }],\n  e: [{\n    name: 'email'\n  }],\n  p: [{\n    name: 'phone'\n  }],\n  z: [{\n    name: 'timezones'\n  }],\n  // TODO: this one can actually be parsed properly...\n  r: [{\n    name: 'repeats'\n  }],\n  // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [{\n    // a=rtpmap:110 opus/48000/2\n    push: 'rtp',\n    reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n    names: ['payload', 'codec', 'rate', 'encoding'],\n    format: function format(o) {\n      return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\n    }\n  }, {\n    // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n    // a=fmtp:111 minptime=10; useinbandfec=1\n    push: 'fmtp',\n    reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n    names: ['payload', 'config'],\n    format: 'fmtp:%d %s'\n  }, {\n    // a=control:streamid=0\n    name: 'control',\n    reg: /^control:(.*)/,\n    format: 'control:%s'\n  }, {\n    // a=rtcp:65179 IN IP4 193.84.77.194\n    name: 'rtcp',\n    reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n    names: ['port', 'netType', 'ipVer', 'address'],\n    format: function format(o) {\n      return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\n    }\n  }, {\n    // a=rtcp-fb:98 trr-int 100\n    push: 'rtcpFbTrrInt',\n    reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n    names: ['payload', 'value'],\n    format: 'rtcp-fb:%d trr-int %d'\n  }, {\n    // a=rtcp-fb:98 nack rpsi\n    push: 'rtcpFb',\n    reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n    names: ['payload', 'type', 'subtype'],\n    format: function format(o) {\n      return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\n    }\n  }, {\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n    // a=extmap:1/recvonly URI-gps-string\n    // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n    push: 'ext',\n    reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n    names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n    format: function format(o) {\n      return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n    }\n  }, {\n    // a=extmap-allow-mixed\n    name: 'extmapAllowMixed',\n    reg: /^(extmap-allow-mixed)/\n  }, {\n    // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n    push: 'crypto',\n    reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n    names: ['id', 'suite', 'config', 'sessionConfig'],\n    format: function format(o) {\n      return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\n    }\n  }, {\n    // a=setup:actpass\n    name: 'setup',\n    reg: /^setup:(\\w*)/,\n    format: 'setup:%s'\n  }, {\n    // a=connection:new\n    name: 'connectionType',\n    reg: /^connection:(new|existing)/,\n    format: 'connection:%s'\n  }, {\n    // a=mid:1\n    name: 'mid',\n    reg: /^mid:([^\\s]*)/,\n    format: 'mid:%s'\n  }, {\n    // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n    name: 'msid',\n    reg: /^msid:(.*)/,\n    format: 'msid:%s'\n  }, {\n    // a=ptime:20\n    name: 'ptime',\n    reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n    format: 'ptime:%d'\n  }, {\n    // a=maxptime:60\n    name: 'maxptime',\n    reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n    format: 'maxptime:%d'\n  }, {\n    // a=sendrecv\n    name: 'direction',\n    reg: /^(sendrecv|recvonly|sendonly|inactive)/\n  }, {\n    // a=ice-lite\n    name: 'icelite',\n    reg: /^(ice-lite)/\n  }, {\n    // a=ice-ufrag:F7gI\n    name: 'iceUfrag',\n    reg: /^ice-ufrag:(\\S*)/,\n    format: 'ice-ufrag:%s'\n  }, {\n    // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n    name: 'icePwd',\n    reg: /^ice-pwd:(\\S*)/,\n    format: 'ice-pwd:%s'\n  }, {\n    // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n    name: 'fingerprint',\n    reg: /^fingerprint:(\\S*) (\\S*)/,\n    names: ['type', 'hash'],\n    format: 'fingerprint:%s %s'\n  }, {\n    // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n    // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n    // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n    // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n    // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n    push: 'candidates',\n    reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n    names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n    format: function format(o) {\n      var str = 'candidate:%s %d %s %d %s %d typ %s';\n      str += o.raddr != null ? ' raddr %s rport %d' : '%v%v'; // NB: candidate has three optional chunks, so %void middles one if it's missing\n\n      str += o.tcptype != null ? ' tcptype %s' : '%v';\n\n      if (o.generation != null) {\n        str += ' generation %d';\n      }\n\n      str += o['network-id'] != null ? ' network-id %d' : '%v';\n      str += o['network-cost'] != null ? ' network-cost %d' : '%v';\n      return str;\n    }\n  }, {\n    // a=end-of-candidates (keep after the candidates line for readability)\n    name: 'endOfCandidates',\n    reg: /^(end-of-candidates)/\n  }, {\n    // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n    name: 'remoteCandidates',\n    reg: /^remote-candidates:(.*)/,\n    format: 'remote-candidates:%s'\n  }, {\n    // a=ice-options:google-ice\n    name: 'iceOptions',\n    reg: /^ice-options:(\\S*)/,\n    format: 'ice-options:%s'\n  }, {\n    // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n    push: 'ssrcs',\n    reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n    names: ['id', 'attribute', 'value'],\n    format: function format(o) {\n      var str = 'ssrc:%d';\n\n      if (o.attribute != null) {\n        str += ' %s';\n\n        if (o.value != null) {\n          str += ':%s';\n        }\n      }\n\n      return str;\n    }\n  }, {\n    // a=ssrc-group:FEC 1 2\n    // a=ssrc-group:FEC-FR 3004364195 1080772241\n    push: 'ssrcGroups',\n    // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n    reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n    names: ['semantics', 'ssrcs'],\n    format: 'ssrc-group:%s %s'\n  }, {\n    // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n    name: 'msidSemantic',\n    reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n    names: ['semantic', 'token'],\n    format: 'msid-semantic: %s %s' // space after ':' is not accidental\n\n  }, {\n    // a=group:BUNDLE audio video\n    push: 'groups',\n    reg: /^group:(\\w*) (.*)/,\n    names: ['type', 'mids'],\n    format: 'group:%s %s'\n  }, {\n    // a=rtcp-mux\n    name: 'rtcpMux',\n    reg: /^(rtcp-mux)/\n  }, {\n    // a=rtcp-rsize\n    name: 'rtcpRsize',\n    reg: /^(rtcp-rsize)/\n  }, {\n    // a=sctpmap:5000 webrtc-datachannel 1024\n    name: 'sctpmap',\n    reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n    names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n    format: function format(o) {\n      return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\n    }\n  }, {\n    // a=x-google-flag:conference\n    name: 'xGoogleFlag',\n    reg: /^x-google-flag:([^\\s]*)/,\n    format: 'x-google-flag:%s'\n  }, {\n    // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n    push: 'rids',\n    reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n    names: ['id', 'direction', 'params'],\n    format: function format(o) {\n      return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\n    }\n  }, {\n    // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n    // a=imageattr:* send [x=800,y=640] recv *\n    // a=imageattr:100 recv [x=320,y=240]\n    push: 'imageattrs',\n    reg: new RegExp( // a=imageattr:97\n    '^imageattr:(\\\\d+|\\\\*)' + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n    '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' + // recv [x=330,y=250]\n    '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\n    names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n    format: function format(o) {\n      return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n    }\n  }, {\n    // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n    // a=simulcast:recv 1;4,5 send 6;7\n    name: 'simulcast',\n    reg: new RegExp( // a=simulcast:\n    '^simulcast:' + // send 1,2,3;~4,~5\n    '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' + // space + recv 6;~7,~8\n    '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' + // end\n    '$'),\n    names: ['dir1', 'list1', 'dir2', 'list2'],\n    format: function format(o) {\n      return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n    }\n  }, {\n    // old simulcast draft 03 (implemented by Firefox)\n    //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n    // a=simulcast: recv pt=97;98 send pt=97\n    // a=simulcast: send rid=5;6;7 paused=6,7\n    name: 'simulcast_03',\n    reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n    names: ['value'],\n    format: 'simulcast: %s'\n  }, {\n    // a=framerate:25\n    // a=framerate:29.97\n    name: 'framerate',\n    reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n    format: 'framerate:%s'\n  }, {\n    // RFC4570\n    // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n    name: 'sourceFilter',\n    reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n    names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n    format: 'source-filter: %s %s %s %s %s'\n  }, {\n    // a=bundle-only\n    name: 'bundleOnly',\n    reg: /^(bundle-only)/\n  }, {\n    // a=label:1\n    name: 'label',\n    reg: /^label:(.+)/,\n    format: 'label:%s'\n  }, {\n    // RFC version 26 for SCTP over DTLS\n    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n    name: 'sctpPort',\n    reg: /^sctp-port:(\\d+)$/,\n    format: 'sctp-port:%s'\n  }, {\n    // RFC version 26 for SCTP over DTLS\n    // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n    name: 'maxMessageSize',\n    reg: /^max-message-size:(\\d+)$/,\n    format: 'max-message-size:%s'\n  }, {\n    // RFC7273\n    // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n    push: 'tsRefClocks',\n    reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n    names: ['clksrc', 'clksrcExt'],\n    format: function format(o) {\n      return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n    }\n  }, {\n    // RFC7273\n    // a=mediaclk:direct=963214424\n    name: 'mediaClk',\n    reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n    names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n    format: function format(o) {\n      var str = 'mediaclk:';\n      str += o.id != null ? 'id=%s %s' : '%v%s';\n      str += o.mediaClockValue != null ? '=%s' : '';\n      str += o.rateNumerator != null ? ' rate=%s' : '';\n      str += o.rateDenominator != null ? '/%s' : '';\n      return str;\n    }\n  }, {\n    // a=keywds:keywords\n    name: 'keywords',\n    reg: /^keywds:(.+)$/,\n    format: 'keywds:%s'\n  }, {\n    // a=content:main\n    name: 'content',\n    reg: /^content:(.+)/,\n    format: 'content:%s'\n  }, // BFCP https://tools.ietf.org/html/rfc4583\n  {\n    // a=floorctrl:c-s\n    name: 'bfcpFloorCtrl',\n    reg: /^floorctrl:(c-only|s-only|c-s)/,\n    format: 'floorctrl:%s'\n  }, {\n    // a=confid:1\n    name: 'bfcpConfId',\n    reg: /^confid:(\\d+)/,\n    format: 'confid:%s'\n  }, {\n    // a=userid:1\n    name: 'bfcpUserId',\n    reg: /^userid:(\\d+)/,\n    format: 'userid:%s'\n  }, {\n    // a=floorid:1\n    name: 'bfcpFloorId',\n    reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n    names: ['id', 'mStream'],\n    format: 'floorid:%s mstrm:%s'\n  }, {\n    // any a= that we don't understand is kept verbatim on media.invalid\n    push: 'invalid',\n    names: ['value']\n  }]\n}; // set sensible defaults to avoid polluting the grammar with boring details\n\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\n\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toIntIfInt = function toIntIfInt(v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function attachProperties(match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  } else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i + 1] != null) {\n        location[names[i]] = toIntIfInt(match[i + 1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function parseReg(obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  } else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n\n  var keyLocation = obj.push ? {} : // blank object that will be pushed\n  needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {},\n      media = [],\n      location = session; // points at where properties go under (one of the above)\n  // parse lines we understand\n\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n\n    if (type === 'm') {\n      media.push({\n        rtp: [],\n        fmtp: []\n      });\n      location = media[media.length - 1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n  session.media = media; // link it up\n\n  return session;\n};\n\nvar paramReducer = function paramReducer(acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n}; // For backward compatibility - alias will be removed in 3.0.0\n\n\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid,\n          paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\"); // customized util.format - discards excess arguments and can void middle ones\n\n\nvar formatRegExp = /%[sdv%]/g;\n\nvar format = function format(formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n\n    var arg = args[i];\n    i += 1;\n\n    switch (x) {\n      case '%%':\n        return '%';\n\n      case '%s':\n        return String(arg);\n\n      case '%d':\n        return Number(arg);\n\n      case '%v':\n        return '';\n    }\n  }); // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function makeLine(type, obj, location) {\n  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n  var args = [type + '=' + str];\n\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      } else {\n        // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  } else {\n    args.push(location[obj.name]);\n  }\n\n  return format.apply(null, args);\n}; // RFC specified order\n// TODO: extend this with all the rest\n\n\nvar defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\nmodule.exports = function (session, opts) {\n  opts = opts || {}; // ensure certain properties exist\n\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = []; // loop through outerOrder for matching properties on session\n\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      } else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  }); // then for each media line, follow the innerOrder\n\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        } else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/bytesToUuid.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/bytesToUuid.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\n  return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();\n}\n\nvar _default = bytesToUuid;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function get() {\n    return _v[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function get() {\n    return _v2[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function get() {\n    return _v3[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function get() {\n    return _v4[\"default\"];\n  }\n});\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/esm-browser/v1.js\"));\n\nvar _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/esm-browser/v3.js\"));\n\nvar _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/esm-browser/v4.js\"));\n\nvar _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/esm-browser/v5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/index.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/md5.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/sha1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\"));\n\nvar _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-browser/bytesToUuid.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _bytesToUuid[\"default\"])(b);\n}\n\nvar _default = v1;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/v1.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\"));\n\nvar _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/esm-browser/md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar v3 = (0, _v[\"default\"])('v3', 0x30, _md[\"default\"]);\nvar _default = v3;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/v3.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-browser/bytesToUuid.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  var bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nvar URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var off = buf && offset || 0;\n    if (typeof value === 'string') value = stringToBytes(value);\n    if (typeof namespace === 'string') namespace = uuidToBytes(namespace);\n\n    if (!Array.isArray(value)) {\n      throw TypeError('value must be an array of bytes');\n    }\n\n    if (!Array.isArray(namespace) || namespace.length !== 16) {\n      throw TypeError('namespace must be uuid string or an Array of 16 byte values');\n    } // Per 4.3\n\n\n    var bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      for (var idx = 0; idx < 16; ++idx) {\n        buf[off + idx] = bytes[idx];\n      }\n    }\n\n    return buf || (0, _bytesToUuid[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/v35.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\"));\n\nvar _bytesToUuid = _interopRequireDefault(__webpack_require__(/*! ./bytesToUuid.js */ \"./node_modules/uuid/dist/esm-browser/bytesToUuid.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction v4(options, buf, offset) {\n  if (typeof options === 'string') {\n    buf = options === 'binary' ? new Uint8Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    var start = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[start + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _bytesToUuid[\"default\"])(rnds);\n}\n\nvar _default = v4;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\"));\n\nvar _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/esm-browser/sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar v5 = (0, _v[\"default\"])('v5', 0x50, _sha[\"default\"]);\nvar _default = v5;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack:///./node_modules/uuid/dist/esm-browser/v5.js?");

/***/ }),

/***/ "./node_modules/uuidv4/build/lib/uuidv4.js":
/*!*************************************************!*\
  !*** ./node_modules/uuidv4/build/lib/uuidv4.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonSchema = exports.fromString = exports.empty = exports.isUuid = exports.regex = exports.uuid = void 0;\n\nvar uuid_1 = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\");\n\nvar uuidv4 = function uuidv4() {\n  return uuid_1.v4();\n};\n\nexports.uuid = uuidv4;\nvar regex = {\n  v4: /(?:^[0-9a-f]{8}\\x2D[0-9a-f]{4}\\x2D4[0-9a-f]{3}\\x2D[0-9a-f]{4}\\x2D[0-9a-f]{12}$)|(?:^0{8}\\x2D0{4}\\x2D0{4}\\x2D0{4}\\x2D0{12}$)/,\n  v5: /(?:^[0-9a-f]{8}\\x2D[0-9a-f]{4}\\x2D5[0-9a-f]{3}\\x2D[0-9a-f]{4}\\x2D[0-9a-f]{12}$)|(?:^0{8}\\x2D0{4}\\x2D0{4}\\x2D0{4}\\x2D0{12}$)/\n};\nexports.regex = regex;\nvar jsonSchema = {\n  /* eslint-disable @typescript-eslint/no-base-to-string */\n  v4: {\n    type: 'string',\n    pattern: regex.v4.toString().slice(1, -1)\n  },\n  v5: {\n    type: 'string',\n    pattern: regex.v5.toString().slice(1, -1)\n  }\n  /* eslint-enable @typescript-eslint/no-base-to-string */\n\n};\nexports.jsonSchema = jsonSchema;\n\nvar isUuid = function isUuid(value) {\n  return regex.v4.test(value) || regex.v5.test(value);\n};\n\nexports.isUuid = isUuid;\n\nvar empty = function empty() {\n  return '00000000-0000-0000-0000-000000000000';\n};\n\nexports.empty = empty;\n\nvar fromString = function fromString(text) {\n  var namespace = 'bb5d0ffa-9a4c-4d7c-8fc2-0a7d2220ba45';\n  var uuidFromString = uuid_1.v5(text, namespace);\n  return uuidFromString;\n};\n\nexports.fromString = fromString;\n\n//# sourceURL=webpack:///./node_modules/uuidv4/build/lib/uuidv4.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _globalThis;\n\ntry {\n  _globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n} catch (error) {} finally {\n  if (!_globalThis && typeof window !== 'undefined') {\n    _globalThis = window;\n  }\n\n  if (!_globalThis) {\n    throw new Error('Could not determine global this');\n  }\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\n\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\n\n\nfunction W3CWebSocket(uri, protocols) {\n  var native_instance;\n\n  if (protocols) {\n    native_instance = new NativeWebSocket(uri, protocols);\n  } else {\n    native_instance = new NativeWebSocket(uri);\n  }\n  /**\n   * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n   * class). Since it is an Object it will be returned as it is when creating an\n   * instance of W3CWebSocket via 'new W3CWebSocket()'.\n   *\n   * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n   */\n\n\n  return native_instance;\n}\n\nif (NativeWebSocket) {\n  ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function (prop) {\n    Object.defineProperty(W3CWebSocket, prop, {\n      get: function get() {\n        return NativeWebSocket[prop];\n      }\n    });\n  });\n}\n/**\n * Module exports.\n */\n\n\nmodule.exports = {\n  'w3cwebsocket': NativeWebSocket ? W3CWebSocket : null,\n  'version': websocket_version\n};\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/browser.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _optional, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, browser, bugs, config, contributors, dependencies, description, devDependencies, directories, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_args\\\":[[\\\"websocket@1.0.31\\\",\\\"/home/ubuntu/networked-aframe\\\"]],\\\"_from\\\":\\\"websocket@1.0.31\\\",\\\"_id\\\":\\\"websocket@1.0.31\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-VAouplvGKPiKFDTeCCO65vYHsyay8DqoBSlzIO3fayrfOgU94lQN5a1uWVnFrMLceTJw/+fQXR5PGbUVRaHshQ==\\\",\\\"_location\\\":\\\"/websocket\\\",\\\"_optional\\\":true,\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"websocket@1.0.31\\\",\\\"name\\\":\\\"websocket\\\",\\\"escapedName\\\":\\\"websocket\\\",\\\"rawSpec\\\":\\\"1.0.31\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"1.0.31\\\"},\\\"_requiredBy\\\":[\\\"/protoo-client\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/websocket/-/websocket-1.0.31.tgz\\\",\\\"_spec\\\":\\\"1.0.31\\\",\\\"_where\\\":\\\"/home/ubuntu/networked-aframe\\\",\\\"author\\\":{\\\"name\\\":\\\"Brian McKelvey\\\",\\\"email\\\":\\\"theturtle32@gmail.com\\\",\\\"url\\\":\\\"https://github.com/theturtle32\\\"},\\\"browser\\\":\\\"lib/browser.js\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/theturtle32/WebSocket-Node/issues\\\"},\\\"config\\\":{\\\"verbose\\\":false},\\\"contributors\\\":[{\\\"name\\\":\\\"Iaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\",\\\"url\\\":\\\"http://dev.sipdoc.net\\\"}],\\\"dependencies\\\":{\\\"debug\\\":\\\"^2.2.0\\\",\\\"es5-ext\\\":\\\"^0.10.50\\\",\\\"nan\\\":\\\"^2.14.0\\\",\\\"typedarray-to-buffer\\\":\\\"^3.1.5\\\",\\\"yaeti\\\":\\\"^0.0.6\\\"},\\\"description\\\":\\\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\\\",\\\"devDependencies\\\":{\\\"buffer-equal\\\":\\\"^1.0.0\\\",\\\"faucet\\\":\\\"^0.0.1\\\",\\\"gulp\\\":\\\"^4.0.2\\\",\\\"gulp-jshint\\\":\\\"^2.0.4\\\",\\\"jshint\\\":\\\"^2.0.0\\\",\\\"jshint-stylish\\\":\\\"^2.2.1\\\",\\\"tape\\\":\\\"^4.9.1\\\"},\\\"directories\\\":{\\\"lib\\\":\\\"./lib\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=0.10.0\\\"},\\\"homepage\\\":\\\"https://github.com/theturtle32/WebSocket-Node\\\",\\\"keywords\\\":[\\\"websocket\\\",\\\"websockets\\\",\\\"socket\\\",\\\"networking\\\",\\\"comet\\\",\\\"push\\\",\\\"RFC-6455\\\",\\\"realtime\\\",\\\"server\\\",\\\"client\\\"],\\\"license\\\":\\\"Apache-2.0\\\",\\\"main\\\":\\\"index\\\",\\\"name\\\":\\\"websocket\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/theturtle32/WebSocket-Node.git\\\"},\\\"scripts\\\":{\\\"gulp\\\":\\\"gulp\\\",\\\"install\\\":\\\"(node-gyp rebuild 2> builderror.log) || (exit 0)\\\",\\\"test\\\":\\\"faucet test/unit\\\"},\\\"version\\\":\\\"1.0.31\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/websocket/package.json?");

/***/ }),

/***/ "./src/ChildEntityCache.js":
/*!*********************************!*\
  !*** ./src/ChildEntityCache.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ChildEntityCache = /*#__PURE__*/function () {\n  function ChildEntityCache() {\n    _classCallCheck(this, ChildEntityCache);\n\n    this.dict = {};\n  }\n\n  _createClass(ChildEntityCache, [{\n    key: \"addChild\",\n    value: function addChild(parentNetworkId, childData) {\n      if (!this.hasParent(parentNetworkId)) {\n        this.dict[parentNetworkId] = [];\n      }\n\n      this.dict[parentNetworkId].push(childData);\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren(parentNetworkId) {\n      if (!this.hasParent(parentNetworkId)) {\n        return [];\n      }\n\n      var children = this.dict[parentNetworkId];\n      delete this.dict[parentNetworkId];\n      return children;\n    }\n    /* Private */\n\n  }, {\n    key: \"hasParent\",\n    value: function hasParent(parentId) {\n      return !!this.dict[parentId];\n    }\n  }]);\n\n  return ChildEntityCache;\n}();\n\nmodule.exports = ChildEntityCache;\n\n//# sourceURL=webpack:///./src/ChildEntityCache.js?");

/***/ }),

/***/ "./src/DeepEquals.js":
/*!***************************!*\
  !*** ./src/DeepEquals.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Patched version of fast-deep-equal which does not\n// allocate memory via calling Object.keys\n//\n// https://github.com/epoberezkin/fast-deep-equal/blob/master/index.js\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {\n    var arrA = isArray(a),\n        arrB = isArray(b),\n        i,\n        length,\n        key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n    var dateA = a instanceof Date,\n        dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n    var regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n    var keys = keyList(a);\n    length = keys.length;\n    if (length !== keyList(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!hasProp.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a !== a && b !== b;\n};\n\n//# sourceURL=webpack:///./src/DeepEquals.js?");

/***/ }),

/***/ "./src/NafIndex.js":
/*!*************************!*\
  !*** ./src/NafIndex.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar options = __webpack_require__(/*! ./options */ \"./src/options.js\");\n\nvar utils = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nvar NafLogger = __webpack_require__(/*! ./NafLogger */ \"./src/NafLogger.js\");\n\nvar Schemas = __webpack_require__(/*! ./Schemas */ \"./src/Schemas.js\");\n\nvar NetworkEntities = __webpack_require__(/*! ./NetworkEntities */ \"./src/NetworkEntities.js\");\n\nvar NetworkConnection = __webpack_require__(/*! ./NetworkConnection */ \"./src/NetworkConnection.js\");\n\nvar AdapterFactory = __webpack_require__(/*! ./adapters/AdapterFactory */ \"./src/adapters/AdapterFactory.js\");\n\nvar naf = {};\nnaf.app = '';\nnaf.room = '';\nnaf.clientId = '';\nnaf.options = options;\nnaf.utils = utils;\nnaf.log = new NafLogger();\nnaf.schemas = new Schemas();\nnaf.version = \"0.7.1\";\nnaf.adapters = new AdapterFactory();\nvar entities = new NetworkEntities();\nvar connection = new NetworkConnection(entities);\nnaf.connection = connection;\nnaf.entities = entities;\nmodule.exports = window.NAF = naf;\n\n//# sourceURL=webpack:///./src/NafIndex.js?");

/***/ }),

/***/ "./src/NafLogger.js":
/*!**************************!*\
  !*** ./src/NafLogger.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*eslint no-console: \"off\" */\nvar NafLogger = /*#__PURE__*/function () {\n  function NafLogger() {\n    _classCallCheck(this, NafLogger);\n\n    this.debug = false;\n  }\n\n  _createClass(NafLogger, [{\n    key: \"setDebug\",\n    value: function setDebug(debug) {\n      this.debug = debug;\n    }\n  }, {\n    key: \"write\",\n    value: function write() {\n      if (this.debug) {\n        console.log.apply(this, arguments);\n      }\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      console.warn.apply(this, arguments);\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      console.error.apply(this, arguments);\n    }\n  }]);\n\n  return NafLogger;\n}();\n\nmodule.exports = NafLogger;\n\n//# sourceURL=webpack:///./src/NafLogger.js?");

/***/ }),

/***/ "./src/NetworkConnection.js":
/*!**********************************!*\
  !*** ./src/NetworkConnection.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global NAF */\nvar ReservedDataType = {\n  Update: 'u',\n  UpdateMulti: 'um',\n  Remove: 'r'\n};\n\nvar NetworkConnection = /*#__PURE__*/function () {\n  function NetworkConnection(networkEntities) {\n    _classCallCheck(this, NetworkConnection);\n\n    this.entities = networkEntities;\n    this.setupDefaultDataSubscriptions();\n    this.connectedClients = {};\n    this.activeDataChannels = {};\n  }\n\n  _createClass(NetworkConnection, [{\n    key: \"setNetworkAdapter\",\n    value: function setNetworkAdapter(adapter) {\n      this.adapter = adapter;\n    }\n  }, {\n    key: \"setupDefaultDataSubscriptions\",\n    value: function setupDefaultDataSubscriptions() {\n      this.dataChannelSubs = {};\n      this.dataChannelSubs[ReservedDataType.Update] = this.entities.updateEntity.bind(this.entities);\n      this.dataChannelSubs[ReservedDataType.UpdateMulti] = this.entities.updateEntityMulti.bind(this.entities);\n      this.dataChannelSubs[ReservedDataType.Remove] = this.entities.removeRemoteEntity.bind(this.entities);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(serverUrl, appName, roomName) {\n      var enableAudio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      NAF.app = appName;\n      NAF.room = roomName;\n      this.adapter.setServerUrl(serverUrl);\n      this.adapter.setApp(appName);\n      this.adapter.setRoom(roomName);\n      var webrtcOptions = {\n        audio: enableAudio,\n        video: false,\n        datachannel: true\n      };\n      this.adapter.setWebRtcOptions(webrtcOptions);\n      this.adapter.setServerConnectListeners(this.connectSuccess.bind(this), this.connectFailure.bind(this));\n      this.adapter.setDataChannelListeners(this.dataChannelOpen.bind(this), this.dataChannelClosed.bind(this), this.receivedData.bind(this));\n      this.adapter.setRoomOccupantListener(this.occupantsReceived.bind(this));\n      return this.adapter.connect();\n    }\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(callback) {\n      this.onConnectCallback = callback;\n\n      if (this.isConnected()) {\n        callback();\n      } else {\n        document.body.addEventListener('connected', callback, false);\n      }\n    }\n  }, {\n    key: \"connectSuccess\",\n    value: function connectSuccess(clientId) {\n      NAF.log.write('Networked-Aframe Client ID:', clientId);\n      NAF.clientId = clientId;\n      var evt = new CustomEvent('connected', {\n        'detail': {\n          clientId: clientId\n        }\n      });\n      document.body.dispatchEvent(evt);\n    }\n  }, {\n    key: \"connectFailure\",\n    value: function connectFailure(errorCode, message) {\n      NAF.log.error(errorCode, \"failure to connect\");\n    }\n  }, {\n    key: \"occupantsReceived\",\n    value: function occupantsReceived(occupantList) {\n      var prevConnectedClients = Object.assign({}, this.connectedClients);\n      this.connectedClients = occupantList;\n      this.checkForDisconnectingClients(prevConnectedClients, occupantList);\n      this.checkForConnectingClients(occupantList);\n    }\n  }, {\n    key: \"checkForDisconnectingClients\",\n    value: function checkForDisconnectingClients(oldOccupantList, newOccupantList) {\n      for (var id in oldOccupantList) {\n        var clientFound = newOccupantList[id];\n\n        if (!clientFound) {\n          NAF.log.write('Closing stream to ', id);\n          this.adapter.closeStreamConnection(id);\n        }\n      }\n    } // Some adapters will handle this internally\n\n  }, {\n    key: \"checkForConnectingClients\",\n    value: function checkForConnectingClients(occupantList) {\n      for (var id in occupantList) {\n        var startConnection = this.isNewClient(id) && this.adapter.shouldStartConnectionTo(occupantList[id]);\n\n        if (startConnection) {\n          NAF.log.write('Opening datachannel to ', id);\n          this.adapter.startStreamConnection(id);\n        }\n      }\n    }\n  }, {\n    key: \"getConnectedClients\",\n    value: function getConnectedClients() {\n      return this.connectedClients;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return !!NAF.clientId;\n    }\n  }, {\n    key: \"isMineAndConnected\",\n    value: function isMineAndConnected(clientId) {\n      return this.isConnected() && NAF.clientId === clientId;\n    }\n  }, {\n    key: \"isNewClient\",\n    value: function isNewClient(clientId) {\n      return !this.isConnectedTo(clientId);\n    }\n  }, {\n    key: \"isConnectedTo\",\n    value: function isConnectedTo(clientId) {\n      return this.adapter.getConnectStatus(clientId) === NAF.adapters.IS_CONNECTED;\n    }\n  }, {\n    key: \"dataChannelOpen\",\n    value: function dataChannelOpen(clientId) {\n      NAF.log.write('Opened data channel from ' + clientId);\n      this.activeDataChannels[clientId] = true;\n      this.entities.completeSync(clientId, true);\n      var evt = new CustomEvent('clientConnected', {\n        detail: {\n          clientId: clientId\n        }\n      });\n      document.body.dispatchEvent(evt);\n    }\n  }, {\n    key: \"dataChannelClosed\",\n    value: function dataChannelClosed(clientId) {\n      NAF.log.write('Closed data channel from ' + clientId);\n      this.activeDataChannels[clientId] = false;\n      this.entities.removeEntitiesOfClient(clientId);\n      var evt = new CustomEvent('clientDisconnected', {\n        detail: {\n          clientId: clientId\n        }\n      });\n      document.body.dispatchEvent(evt);\n    }\n  }, {\n    key: \"hasActiveDataChannel\",\n    value: function hasActiveDataChannel(clientId) {\n      return !!(this.activeDataChannels[clientId] && this.activeDataChannels[clientId]);\n    }\n  }, {\n    key: \"broadcastData\",\n    value: function broadcastData(dataType, data) {\n      this.adapter.broadcastData(dataType, data);\n    }\n  }, {\n    key: \"broadcastDataGuaranteed\",\n    value: function broadcastDataGuaranteed(dataType, data) {\n      this.adapter.broadcastDataGuaranteed(dataType, data);\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(toClientId, dataType, data, guaranteed) {\n      if (this.hasActiveDataChannel(toClientId)) {\n        if (guaranteed) {\n          this.adapter.sendDataGuaranteed(toClientId, dataType, data);\n        } else {\n          this.adapter.sendData(toClientId, dataType, data);\n        }\n      } else {// console.error(\"NOT-CONNECTED\", \"not connected to \" + toClient);\n      }\n    }\n  }, {\n    key: \"sendDataGuaranteed\",\n    value: function sendDataGuaranteed(toClientId, dataType, data) {\n      this.sendData(toClientId, dataType, data, true);\n    }\n  }, {\n    key: \"subscribeToDataChannel\",\n    value: function subscribeToDataChannel(dataType, callback) {\n      if (this.isReservedDataType(dataType)) {\n        NAF.log.error('NetworkConnection@subscribeToDataChannel: ' + dataType + ' is a reserved dataType. Choose another');\n        return;\n      }\n\n      this.dataChannelSubs[dataType] = callback;\n    }\n  }, {\n    key: \"unsubscribeToDataChannel\",\n    value: function unsubscribeToDataChannel(dataType) {\n      if (this.isReservedDataType(dataType)) {\n        NAF.log.error('NetworkConnection@unsubscribeToDataChannel: ' + dataType + ' is a reserved dataType. Choose another');\n        return;\n      }\n\n      delete this.dataChannelSubs[dataType];\n    }\n  }, {\n    key: \"isReservedDataType\",\n    value: function isReservedDataType(dataType) {\n      return dataType == ReservedDataType.Update || dataType == ReservedDataType.Remove;\n    }\n  }, {\n    key: \"receivedData\",\n    value: function receivedData(fromClientId, dataType, data, source) {\n      if (this.dataChannelSubs[dataType]) {\n        this.dataChannelSubs[dataType](fromClientId, dataType, data, source);\n      } else {\n        NAF.log.write('NetworkConnection@receivedData: ' + dataType + ' has not been subscribed to yet. Call subscribeToDataChannel()');\n      }\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function getServerTime() {\n      return this.adapter.getServerTime();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.entities.removeRemoteEntities();\n      this.adapter.disconnect();\n      NAF.app = '';\n      NAF.room = '';\n      NAF.clientId = '';\n      this.connectedClients = {};\n      this.activeDataChannels = {};\n      this.adapter = null;\n      this.setupDefaultDataSubscriptions();\n      document.body.removeEventListener('connected', this.onConnectCallback);\n    }\n  }]);\n\n  return NetworkConnection;\n}();\n\nmodule.exports = NetworkConnection;\n\n//# sourceURL=webpack:///./src/NetworkConnection.js?");

/***/ }),

/***/ "./src/NetworkEntities.js":
/*!********************************!*\
  !*** ./src/NetworkEntities.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global NAF */\nvar ChildEntityCache = __webpack_require__(/*! ./ChildEntityCache */ \"./src/ChildEntityCache.js\");\n\nvar NetworkEntities = /*#__PURE__*/function () {\n  function NetworkEntities() {\n    _classCallCheck(this, NetworkEntities);\n\n    this.entities = {};\n    this.childCache = new ChildEntityCache();\n    this.onRemoteEntityCreatedEvent = new Event('remoteEntityCreated');\n    this._persistentFirstSyncs = {};\n  }\n\n  _createClass(NetworkEntities, [{\n    key: \"registerEntity\",\n    value: function registerEntity(networkId, entity) {\n      this.entities[networkId] = entity;\n    }\n  }, {\n    key: \"createRemoteEntity\",\n    value: function createRemoteEntity(entityData) {\n      NAF.log.write('Creating remote entity', entityData);\n      var networkId = entityData.networkId;\n      var el = NAF.schemas.getCachedTemplate(entityData.template);\n      el.setAttribute('id', 'naf-' + networkId);\n      this.initPosition(el, entityData.components);\n      this.initRotation(el, entityData.components);\n      this.addNetworkComponent(el, entityData);\n      this.registerEntity(networkId, el);\n      return el;\n    }\n  }, {\n    key: \"initPosition\",\n    value: function initPosition(entity, componentData) {\n      var hasPosition = componentData['position'];\n\n      if (hasPosition) {\n        var position = componentData.position;\n        entity.setAttribute('position', position);\n      }\n    }\n  }, {\n    key: \"initRotation\",\n    value: function initRotation(entity, componentData) {\n      var hasRotation = componentData['rotation'];\n\n      if (hasRotation) {\n        var rotation = componentData.rotation;\n        entity.setAttribute('rotation', rotation);\n      }\n    }\n  }, {\n    key: \"addNetworkComponent\",\n    value: function addNetworkComponent(entity, entityData) {\n      var networkData = {\n        template: entityData.template,\n        creator: entityData.creator,\n        owner: entityData.owner,\n        networkId: entityData.networkId,\n        persistent: entityData.persistent\n      };\n      entity.setAttribute('networked', networkData);\n      entity.firstUpdateData = entityData;\n    }\n  }, {\n    key: \"updateEntityMulti\",\n    value: function updateEntityMulti(client, dataType, entityDatas, source) {\n      if (NAF.options.syncSource && source !== NAF.options.syncSource) return;\n\n      for (var i = 0, l = entityDatas.d.length; i < l; i++) {\n        this.updateEntity(client, 'u', entityDatas.d[i], source);\n      }\n    }\n  }, {\n    key: \"updateEntity\",\n    value: function updateEntity(client, dataType, entityData, source) {\n      if (NAF.options.syncSource && source !== NAF.options.syncSource) return;\n      var networkId = entityData.networkId;\n\n      if (this.hasEntity(networkId)) {\n        this.entities[networkId].components.networked.networkUpdate(entityData);\n      } else if (entityData.isFirstSync) {\n        if (NAF.options.firstSyncSource && source !== NAF.options.firstSyncSource) {\n          NAF.log.write('Ignoring first sync from disallowed source', source);\n        } else {\n          if (entityData.persistent) {\n            // If we receive a firstSync for a persistent entity that we don't have yet,\n            // we assume the scene will create it at some point, so stash the update for later use.\n            this._persistentFirstSyncs[networkId] = entityData;\n          } else {\n            this.receiveFirstUpdateFromEntity(entityData);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"receiveFirstUpdateFromEntity\",\n    value: function receiveFirstUpdateFromEntity(entityData) {\n      var parent = entityData.parent;\n      var networkId = entityData.networkId;\n      var parentNotCreatedYet = parent && !this.hasEntity(parent);\n\n      if (parentNotCreatedYet) {\n        this.childCache.addChild(parent, entityData);\n      } else {\n        var remoteEntity = this.createRemoteEntity(entityData);\n        this.createAndAppendChildren(networkId, remoteEntity);\n        this.addEntityToPage(remoteEntity, parent);\n      }\n    }\n  }, {\n    key: \"createAndAppendChildren\",\n    value: function createAndAppendChildren(parentId, parentEntity) {\n      var children = this.childCache.getChildren(parentId);\n\n      for (var i = 0; i < children.length; i++) {\n        var childEntityData = children[i];\n        var childId = childEntityData.networkId;\n\n        if (this.hasEntity(childId)) {\n          NAF.log.warn('Tried to instantiate entity multiple times', childId, childEntityData, 'Existing entity:', this.getEntity(childId));\n          continue;\n        }\n\n        var childEntity = this.createRemoteEntity(childEntityData);\n        this.createAndAppendChildren(childId, childEntity);\n        parentEntity.appendChild(childEntity);\n      }\n    }\n  }, {\n    key: \"addEntityToPage\",\n    value: function addEntityToPage(entity, parentId) {\n      if (this.hasEntity(parentId)) {\n        this.addEntityToParent(entity, parentId);\n      } else {\n        this.addEntityToSceneRoot(entity);\n      }\n    }\n  }, {\n    key: \"addEntityToParent\",\n    value: function addEntityToParent(entity, parentId) {\n      var parentEl = document.getElementById('naf-' + parentId);\n      parentEl.appendChild(entity);\n    }\n  }, {\n    key: \"addEntityToSceneRoot\",\n    value: function addEntityToSceneRoot(el) {\n      var scene = document.querySelector('a-scene');\n      scene.appendChild(el);\n    }\n  }, {\n    key: \"completeSync\",\n    value: function completeSync(targetClientId, isFirstSync) {\n      for (var id in this.entities) {\n        if (this.entities[id]) {\n          this.entities[id].components.networked.syncAll(targetClientId, isFirstSync);\n        }\n      }\n    }\n  }, {\n    key: \"removeRemoteEntity\",\n    value: function removeRemoteEntity(toClient, dataType, data, source) {\n      if (NAF.options.syncSource && source !== NAF.options.syncSource) return;\n      var id = data.networkId;\n      return this.removeEntity(id);\n    }\n  }, {\n    key: \"removeEntitiesOfClient\",\n    value: function removeEntitiesOfClient(clientId) {\n      var entityList = [];\n\n      for (var id in this.entities) {\n        var entityCreator = NAF.utils.getCreator(this.entities[id]);\n\n        if (entityCreator === clientId) {\n          var persists = void 0;\n          var component = this.entities[id].getAttribute('networked');\n\n          if (component && component.persistent) {\n            persists = NAF.utils.takeOwnership(this.entities[id]);\n          }\n\n          if (!persists) {\n            var entity = this.removeEntity(id);\n            entityList.push(entity);\n          }\n        }\n      }\n\n      return entityList;\n    }\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity(id) {\n      this.forgetPersistentFirstSync(id);\n\n      if (this.hasEntity(id)) {\n        var entity = this.entities[id];\n        this.forgetEntity(id);\n        entity.parentNode.removeChild(entity);\n        return entity;\n      } else {\n        NAF.log.error(\"Tried to remove entity I don't have.\");\n        return null;\n      }\n    }\n  }, {\n    key: \"forgetEntity\",\n    value: function forgetEntity(id) {\n      delete this.entities[id];\n      this.forgetPersistentFirstSync(id);\n    }\n  }, {\n    key: \"getPersistentFirstSync\",\n    value: function getPersistentFirstSync(id) {\n      return this._persistentFirstSyncs[id];\n    }\n  }, {\n    key: \"forgetPersistentFirstSync\",\n    value: function forgetPersistentFirstSync(id) {\n      delete this._persistentFirstSyncs[id];\n    }\n  }, {\n    key: \"getEntity\",\n    value: function getEntity(id) {\n      if (this.entities[id]) {\n        return this.entities[id];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasEntity\",\n    value: function hasEntity(id) {\n      return !!this.entities[id];\n    }\n  }, {\n    key: \"removeRemoteEntities\",\n    value: function removeRemoteEntities() {\n      this.childCache = new ChildEntityCache();\n\n      for (var id in this.entities) {\n        var owner = this.entities[id].getAttribute('networked').owner;\n\n        if (owner != NAF.clientId) {\n          this.removeEntity(id);\n        }\n      }\n    }\n  }]);\n\n  return NetworkEntities;\n}();\n\nmodule.exports = NetworkEntities;\n\n//# sourceURL=webpack:///./src/NetworkEntities.js?");

/***/ }),

/***/ "./src/Schemas.js":
/*!************************!*\
  !*** ./src/Schemas.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global NAF */\nvar Schemas = /*#__PURE__*/function () {\n  function Schemas() {\n    _classCallCheck(this, Schemas);\n\n    this.schemaDict = {};\n    this.templateCache = {};\n  }\n\n  _createClass(Schemas, [{\n    key: \"createDefaultSchema\",\n    value: function createDefaultSchema(name) {\n      return {\n        template: name,\n        components: ['position', 'rotation']\n      };\n    }\n  }, {\n    key: \"add\",\n    value: function add(schema) {\n      if (this.validateSchema(schema)) {\n        this.schemaDict[schema.template] = schema;\n        var templateEl = document.querySelector(schema.template);\n\n        if (!templateEl) {\n          NAF.log.error(\"Template el not found for \".concat(schema.template, \", make sure NAF.schemas.add is called after <a-scene> is defined.\"));\n          return;\n        }\n\n        if (!this.validateTemplate(schema, templateEl)) {\n          return;\n        }\n\n        this.templateCache[schema.template] = document.importNode(templateEl.content, true);\n      } else {\n        NAF.log.error('Schema not valid: ', schema);\n        NAF.log.error('See https://github.com/haydenjameslee/networked-aframe#syncing-custom-components');\n      }\n    }\n  }, {\n    key: \"getCachedTemplate\",\n    value: function getCachedTemplate(template) {\n      if (!this.templateIsCached(template)) {\n        if (this.templateExistsInScene(template)) {\n          this.add(this.createDefaultSchema(template));\n        } else {\n          NAF.log.error(\"Template el for \".concat(template, \" is not in the scene, add the template to <a-assets> and register with NAF.schemas.add.\"));\n        }\n      }\n\n      return this.templateCache[template].firstElementChild.cloneNode(true);\n    }\n  }, {\n    key: \"templateIsCached\",\n    value: function templateIsCached(template) {\n      return !!this.templateCache[template];\n    }\n  }, {\n    key: \"getComponents\",\n    value: function getComponents(template) {\n      var components = ['position', 'rotation'];\n\n      if (this.hasTemplate(template)) {\n        components = this.schemaDict[template].components;\n      }\n\n      return components;\n    }\n  }, {\n    key: \"hasTemplate\",\n    value: function hasTemplate(template) {\n      return !!this.schemaDict[template];\n    }\n  }, {\n    key: \"templateExistsInScene\",\n    value: function templateExistsInScene(templateSelector) {\n      var el = document.querySelector(templateSelector);\n      return el && this.isTemplateTag(el);\n    }\n  }, {\n    key: \"validateSchema\",\n    value: function validateSchema(schema) {\n      return !!(schema['template'] && schema['components']);\n    }\n  }, {\n    key: \"validateTemplate\",\n    value: function validateTemplate(schema, el) {\n      if (!this.isTemplateTag(el)) {\n        NAF.log.error(\"Template for \".concat(schema.template, \" is not a <template> tag. Instead found: \").concat(el.tagName));\n        return false;\n      } else if (!this.templateHasOneOrZeroChildren(el)) {\n        NAF.log.error(\"Template for \".concat(schema.template, \" has more than one child. Templates must have one direct child element, no more. Template found:\"), el);\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: \"isTemplateTag\",\n    value: function isTemplateTag(el) {\n      return el.tagName.toLowerCase() === 'template';\n    }\n  }, {\n    key: \"templateHasOneOrZeroChildren\",\n    value: function templateHasOneOrZeroChildren(el) {\n      return el.content.childElementCount < 2;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(template) {\n      delete this.schemaDict[template];\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.schemaDict = {};\n    }\n  }]);\n\n  return Schemas;\n}();\n\nmodule.exports = Schemas;\n\n//# sourceURL=webpack:///./src/Schemas.js?");

/***/ }),

/***/ "./src/adapters/AdapterFactory.js":
/*!****************************************!*\
  !*** ./src/adapters/AdapterFactory.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WebrtcAdapter = __webpack_require__(/*! ./naf-webrtc-adapter */ \"./src/adapters/naf-webrtc-adapter.js\");\n\nvar SocketioAdapter = __webpack_require__(/*! ./naf-socketio-adapter */ \"./src/adapters/naf-socketio-adapter.js\");\n\nvar NWClientApiAdapter = __webpack_require__(/*! ./naf-nwclientapi-adapter */ \"./src/adapters/naf-nwclientapi-adapter.js\");\n\nvar AdapterFactory = /*#__PURE__*/function () {\n  function AdapterFactory() {\n    _classCallCheck(this, AdapterFactory);\n\n    this.adapters = {\n      \"socketio\": SocketioAdapter,\n      \"webrtc\": WebrtcAdapter,\n      \"nwclientapi\": NWClientApiAdapter\n    };\n    this.IS_CONNECTED = AdapterFactory.IS_CONNECTED;\n    this.CONNECTING = AdapterFactory.CONNECTING;\n    this.NOT_CONNECTED = AdapterFactory.NOT_CONNECTED;\n  }\n\n  _createClass(AdapterFactory, [{\n    key: \"register\",\n    value: function register(adapterName, AdapterClass) {\n      this.adapters[adapterName] = AdapterClass;\n    }\n  }, {\n    key: \"make\",\n    value: function make(adapterName) {\n      var name = adapterName.toLowerCase();\n\n      if (this.adapters[name]) {\n        var AdapterClass = this.adapters[name];\n        return new AdapterClass();\n      } else if (name === 'easyrtc' || name == 'wseasyrtc') {\n        throw new Error(\"Adapter: \" + adapterName + \" not registered. EasyRTC support was removed in Networked-Aframe 0.7.0.\" + \" To use the deprecated EasyRTC adapter see https://github.com/networked-aframe/naf-easyrtc-adapter\");\n      } else {\n        throw new Error(\"Adapter: \" + adapterName + \" not registered. Please use NAF.adapters.register() to register this adapter.\");\n      }\n    }\n  }]);\n\n  return AdapterFactory;\n}();\n\nAdapterFactory.IS_CONNECTED = \"IS_CONNECTED\";\nAdapterFactory.CONNECTING = \"CONNECTING\";\nAdapterFactory.NOT_CONNECTED = \"NOT_CONNECTED\";\nmodule.exports = AdapterFactory;\n\n//# sourceURL=webpack:///./src/adapters/AdapterFactory.js?");

/***/ }),

/***/ "./src/adapters/naf-nwclientapi-adapter.js":
/*!*************************************************!*\
  !*** ./src/adapters/naf-nwclientapi-adapter.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar mediasoupClient = __webpack_require__(/*! mediasoup-client */ \"./node_modules/mediasoup-client/lib/index.js\");\n\nvar protooClient = __webpack_require__(/*! protoo-client */ \"./node_modules/protoo-client/lib/index.js\");\n\nvar newDebug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n\nvar _require = __webpack_require__(/*! uuidv4 */ \"./node_modules/uuidv4/build/lib/uuidv4.js\"),\n    uuid = _require.uuid; // NOTE this adapter does not properly fire the onOccupantsReceived events since those are only needed for\n// data channels, which are not yet supported. To fire that event, this class would need to keep a list of\n// occupants around and manage it.\n//\n// Used for VP9 webcam video.\n//const VIDEO_KSVC_ENCODINGS = [{ scalabilityMode: \"S3T3_KEY\" }];\n// Used for VP9 desktop sharing.\n//const VIDEO_SVC_ENCODINGS = [{ scalabilityMode: \"S3T3\", dtx: true }];\n// TODO\n// - look into requestConsumerKeyframe\n// - look into applyNetworkThrottle\n// SFU todo\n// - remove active speaker stuff\n// - remove score stuff\n// Based upon mediasoup-demo RoomClient\n\n\nvar debug = newDebug(\"naf-nwclientapi-adapter:debug\"); //const warn = newDebug(\"naf-dialog-adapter:warn\");\n\nvar error = newDebug(\"naf-nwclientapi-adapter:error\");\nvar info = newDebug(\"naf-nwclientapi-adapter:info\");\nvar PC_PROPRIETARY_CONSTRAINTS = {\n  optional: [{\n    googDscp: true\n  }]\n};\n\nvar NWClientAPIAdapter = /*#__PURE__*/function () {\n  function NWClientAPIAdapter() {\n    _classCallCheck(this, NWClientAPIAdapter);\n\n    this._forceTcp = false;\n    this._timeOffsets = [];\n    this._occupants = {};\n    this._micProducer = null;\n    this._videoProducer = null;\n    this._mediaStreams = {};\n    this._localMediaStream = null;\n    this._consumers = new Map();\n    this._frozenUpdates = new Map();\n    this._pendingMediaRequests = new Map();\n    this._micEnabled = true;\n    this._initialAudioConsumerPromise = null;\n    this._initialAudioConsumerResolvers = new Map();\n    this._serverTimeRequests = 0;\n    this._avgTimeOffset = 0;\n    this._blockedClients = new Map();\n    this.type = \"dialog\";\n    this.occupants = []; // This is a public field\n\n    this._clientId = uuid();\n    this._pendingBroadcasts = [];\n  }\n\n  _createClass(NWClientAPIAdapter, [{\n    key: \"setForceTcp\",\n    value: function setForceTcp(forceTcp) {\n      this._forceTcp = forceTcp;\n    }\n  }, {\n    key: \"setServerUrl\",\n    value: function setServerUrl(url) {\n      this._serverUrl = url;\n    }\n  }, {\n    key: \"setJoinToken\",\n    value: function setJoinToken(joinToken) {\n      this._joinToken = joinToken;\n    }\n  }, {\n    key: \"setPeerConnectionConfig\",\n    value: function setPeerConnectionConfig(peerConnectionConfig) {\n      if (peerConnectionConfig.iceServers) {\n        this._iceServers = peerConnectionConfig.iceServers;\n      }\n\n      if (peerConnectionConfig.iceTransportPolicy) {\n        this._iceTransportPolicy = peerConnectionConfig.iceTransportPolicy;\n      }\n    }\n  }, {\n    key: \"setApp\",\n    value: function setApp() {}\n  }, {\n    key: \"setRoom\",\n    value: function setRoom(roomId) {\n      this._roomId = roomId;\n    }\n  }, {\n    key: \"setClientId\",\n    value: function setClientId(clientId) {\n      this._clientId = clientId;\n    }\n  }, {\n    key: \"setServerConnectListeners\",\n    value: function setServerConnectListeners(successListener, failureListener) {\n      this._connectSuccess = successListener;\n      this._connectFailure = failureListener;\n    }\n  }, {\n    key: \"setRoomOccupantListener\",\n    value: function setRoomOccupantListener(occupantListener) {\n      this._onOccupantsChanged = occupantListener;\n    }\n  }, {\n    key: \"setDataChannelListeners\",\n    value: function setDataChannelListeners(openListener, closedListener, messageListener) {\n      this._onOccupantConnected = openListener;\n      this._onOccupantDisconnected = closedListener;\n      this._onOccupantMessage = messageListener;\n    }\n  }, {\n    key: \"dumpConsumers\",\n    value: function dumpConsumers() {\n      if (this._consumers.size) {\n        console.log('consumers:');\n\n        var _iterator = _createForOfIteratorHelper(this._consumers.entries()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n            console.log(entry[0], entry[1]);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var _this = this;\n\n        var urlWithParams, protooTransport;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                urlWithParams = new URL(this._serverUrl);\n                urlWithParams.searchParams.append(\"roomId\", this._roomId);\n                urlWithParams.searchParams.append(\"peerId\", this._clientId);\n                protooTransport = new protooClient.WebSocketTransport(urlWithParams.toString());\n                this._protoo = new protooClient.Peer(protooTransport);\n                _context3.next = 7;\n                return new Promise(function (res) {\n                  _this._protoo.on(\"open\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            console.log('protoo opened. about to join room');\n                            _this._closed = false;\n                            _context.next = 4;\n                            return _this._joinRoom();\n\n                          case 4:\n                            res();\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  })));\n                });\n\n              case 7:\n                this._protoo.on(\"disconnected\", function () {\n                  return _this.disconnect();\n                });\n\n                this._protoo.on(\"close\", function () {\n                  return _this.disconnect();\n                }); // eslint-disable-next-line no-unused-vars\n\n\n                this._protoo.on(\"request\", /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(request, accept, reject) {\n                    var _request$data, peerId, producerId, id, kind, rtpParameters, appData, consumer, initialAudioResolver;\n\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            debug('proto \"request\" event [method:%s, data:%o]', request.method, request.data);\n                            _context2.t0 = request.method;\n                            _context2.next = _context2.t0 === \"newConsumer\" ? 4 : 23;\n                            break;\n\n                          case 4:\n                            _request$data = request.data, peerId = _request$data.peerId, producerId = _request$data.producerId, id = _request$data.id, kind = _request$data.kind, rtpParameters = _request$data.rtpParameters, appData = _request$data.appData;\n                            _context2.prev = 5;\n                            console.log('creating a consumer on the transport');\n                            _context2.next = 9;\n                            return _this._recvTransport.consume({\n                              id: id,\n                              producerId: producerId,\n                              kind: kind,\n                              rtpParameters: rtpParameters,\n                              appData: _objectSpread(_objectSpread({}, appData), {}, {\n                                peerId: peerId\n                              }) // Trick.\n\n                            });\n\n                          case 9:\n                            consumer = _context2.sent;\n\n                            // Store in the map.\n                            _this._consumers.set(consumer.id, consumer);\n\n                            _this.dumpConsumers();\n\n                            consumer.on(\"transportclose\", function () {\n                              return _this.removeConsumer(consumer.id);\n                            }); // We are ready. Answer the protoo request so the server will\n                            // resume this Consumer (which was paused for now if video).\n\n                            accept();\n\n                            _this.resolvePendingMediaRequestForTrack(peerId, consumer.track);\n\n                            if (kind === \"audio\") {\n                              initialAudioResolver = _this._initialAudioConsumerResolvers.get(peerId);\n\n                              if (initialAudioResolver) {\n                                initialAudioResolver();\n\n                                _this._initialAudioConsumerResolvers[\"delete\"](peerId);\n                              }\n                            }\n\n                            _context2.next = 22;\n                            break;\n\n                          case 18:\n                            _context2.prev = 18;\n                            _context2.t1 = _context2[\"catch\"](5);\n                            error('\"newConsumer\" request failed:%o', _context2.t1);\n                            throw _context2.t1;\n\n                          case 22:\n                            return _context2.abrupt(\"break\", 23);\n\n                          case 23:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[5, 18]]);\n                  }));\n\n                  return function (_x, _x2, _x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n                this._protoo.on(\"notification\", function (notification) {\n                  debug('proto \"notification\" event [method:%s, data:%o]', notification.method, notification.data);\n\n                  switch (notification.method) {\n                    case \"newPeer\":\n                      {\n                        var peer = notification.data;\n\n                        _this._onOccupantConnected(peer.id);\n\n                        _this.occupants.push(peer.id);\n\n                        break;\n                      }\n\n                    case \"peerClosed\":\n                      {\n                        var peerId = notification.data.peerId;\n\n                        _this._onOccupantDisconnected(peerId);\n\n                        var pendingMediaRequests = _this._pendingMediaRequests.get(peerId);\n\n                        if (pendingMediaRequests) {\n                          var msg = \"The user disconnected before the media stream was resolved.\";\n                          info(msg);\n\n                          if (pendingMediaRequests.audio) {\n                            pendingMediaRequests.audio.resolve(null);\n                          }\n\n                          if (pendingMediaRequests.video) {\n                            pendingMediaRequests.video.resolve(null);\n                          }\n\n                          _this._pendingMediaRequests[\"delete\"](peerId);\n                        } // Resolve initial audio resolver since this person left.\n\n\n                        var initialAudioResolver = _this._initialAudioConsumerResolvers.get(peerId);\n\n                        if (initialAudioResolver) {\n                          initialAudioResolver();\n\n                          _this._initialAudioConsumerResolvers[\"delete\"](peerId);\n                        }\n\n                        _this.occupants = _this.occupants.filter(function (id) {\n                          return id !== peerId;\n                        });\n                        break;\n                      }\n\n                    case \"consumerClosed\":\n                      {\n                        var consumerId = notification.data.consumerId;\n\n                        var consumer = _this._consumers.get(consumerId);\n\n                        if (!consumer) break;\n                        consumer.close();\n\n                        _this.removeConsumer(consumer.id);\n\n                        break;\n                      }\n\n                    case \"peerBlocked\":\n                      {\n                        var _peerId = notification.data.peerId;\n                        document.body.dispatchEvent(new CustomEvent(\"blocked\", {\n                          detail: {\n                            clientId: _peerId\n                          }\n                        }));\n                        break;\n                      }\n\n                    case \"peerUnblocked\":\n                      {\n                        var _peerId2 = notification.data.peerId;\n                        document.body.dispatchEvent(new CustomEvent(\"unblocked\", {\n                          detail: {\n                            clientId: _peerId2\n                          }\n                        }));\n                        break;\n                      }\n\n                    case \"newBroadcastData\":\n                      {\n                        var _notification$data = notification.data,\n                            clientId = _notification$data.clientId,\n                            dataType = _notification$data.dataType,\n                            data = _notification$data.data;\n\n                        _this._onOccupantMessage(clientId, dataType, data, null);\n\n                        break;\n                      }\n                  }\n                });\n\n                _context3.next = 13;\n                return Promise.all([this.updateTimeOffset(), this._initialAudioConsumerPromise]);\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"shouldStartConnectionTo\",\n    value: function shouldStartConnectionTo() {\n      return true;\n    }\n  }, {\n    key: \"startStreamConnection\",\n    value: function startStreamConnection() {}\n  }, {\n    key: \"closeStreamConnection\",\n    value: function closeStreamConnection() {}\n  }, {\n    key: \"resolvePendingMediaRequestForTrack\",\n    value: function resolvePendingMediaRequestForTrack(clientId, track) {\n      var requests = this._pendingMediaRequests.get(clientId);\n\n      if (requests && requests[track.kind]) {\n        var resolve = requests[track.kind].resolve;\n        delete requests[track.kind];\n        resolve(new MediaStream([track]));\n      }\n\n      if (requests && Object.keys(requests).length === 0) {\n        this._pendingMediaRequests[\"delete\"](clientId);\n      }\n    }\n  }, {\n    key: \"removeConsumer\",\n    value: function removeConsumer(consumerId) {\n      this._consumers[\"delete\"](consumerId);\n    }\n  }, {\n    key: \"getConnectStatus\",\n    value: function getConnectStatus()\n    /*clientId*/\n    {\n      return this._protoo.connected ? NAF.adapters.IS_CONNECTED : NAF.adapters.NOT_CONNECTED;\n    }\n  }, {\n    key: \"getMediaStream\",\n    value: function getMediaStream(clientId) {\n      var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"audio\";\n      var track;\n\n      if (this._clientId === clientId) {\n        if (kind === \"audio\" && this._micProducer) {\n          track = this._micProducer.track;\n        } else if (kind === \"video\" && this._videoProducer) {\n          track = this._videoProducer.track;\n        }\n      } else {\n        this._consumers.forEach(function (consumer) {\n          if (consumer.appData.peerId === clientId && kind == consumer.track.kind) {\n            track = consumer.track;\n          }\n        });\n      }\n\n      if (track) {\n        debug(\"Already had \".concat(kind, \" for \").concat(clientId));\n        return Promise.resolve(new MediaStream([track]));\n      } else {\n        debug(\"Waiting on \".concat(kind, \" for \").concat(clientId));\n\n        if (!this._pendingMediaRequests.has(clientId)) {\n          this._pendingMediaRequests.set(clientId, {});\n        }\n\n        var requests = this._pendingMediaRequests.get(clientId);\n\n        var promise = new Promise(function (resolve, reject) {\n          return requests[kind] = {\n            resolve: resolve,\n            reject: reject\n          };\n        });\n        requests[kind].promise = promise;\n        promise[\"catch\"](function (e) {\n          return console.warn(\"\".concat(clientId, \" getMediaStream Error\"), e);\n        });\n        return promise;\n      }\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function getServerTime() {\n      return Date.now() + this._avgTimeOffset;\n    }\n  }, {\n    key: \"sendDataToAllOccupants\",\n    value: function sendDataToAllOccupants(data) {\n      if (this._protoo && this._protoo.connected) {\n        for (var i = 0; i < this._pendingBroadcasts.length; i++) {\n          this._protoo.request(\"broadcastDataToPeers\", this._pendingBroadcasts[i]);\n        }\n\n        this._pendingBroadcasts.length = 0;\n\n        this._protoo.request(\"broadcastDataToPeers\", data);\n      } else {\n        this._pendingBroadcasts.push(data);\n      }\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(clientId, dataType, data) {\n      // TODO: provide unreliable transport\n      // this.unreliableTransport(clientId, dataType, data);\n      //this.sendDataGuaranteed(clientId, dataType, data);\n      this.sendDataToAllOccupants({\n        clientId: this._clientId,\n        dataType: dataType,\n        data: data\n      });\n    }\n  }, {\n    key: \"sendDataGuaranteed\",\n    value: function sendDataGuaranteed(clientId, dataType, data) {\n      //this.reliableTransport(clientId, dataType, data);\n      this.sendDataToAllOccupants({\n        clientId: this._clientId,\n        dataType: dataType,\n        data: data\n      });\n    }\n  }, {\n    key: \"broadcastData\",\n    value: function broadcastData(dataType, data) {\n      this.sendDataToAllOccupants({\n        clientId: this._clientId,\n        dataType: dataType,\n        data: data\n      });\n    }\n  }, {\n    key: \"broadcastDataGuaranteed\",\n    value: function broadcastDataGuaranteed(dataType, data) {\n      this.sendDataToAllOccupants({\n        clientId: this._clientId,\n        dataType: dataType,\n        data: data\n      });\n    }\n  }, {\n    key: \"setReconnectionListeners\",\n    value: function setReconnectionListeners(reconnectingListener, reconnectedListener, reconnectionErrorListener) {\n      this._reconnectingListener = reconnectingListener;\n      this._reconnectedListener = reconnectedListener;\n      this._reconnectionErrorListener = reconnectionErrorListener;\n    }\n  }, {\n    key: \"syncOccupants\",\n    value: function syncOccupants() {// Not implemented\n    }\n  }, {\n    key: \"_joinRoom\",\n    value: function () {\n      var _joinRoom2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        var routerRtpCapabilities, sendTransportInfo, recvTransportInfo, _yield$this$_protoo$r, peers, audioConsumerPromises, _loop, i, _ret;\n\n        return regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                debug(\"_joinRoom()\");\n                _context5.prev = 1;\n                this._mediasoupDevice = new mediasoupClient.Device({});\n                _context5.next = 5;\n                return this._protoo.request(\"getRouterRtpCapabilities\");\n\n              case 5:\n                routerRtpCapabilities = _context5.sent;\n                _context5.next = 8;\n                return this._mediasoupDevice.load({\n                  routerRtpCapabilities: routerRtpCapabilities\n                });\n\n              case 8:\n                _context5.next = 10;\n                return this._protoo.request(\"createWebRtcTransport\", {\n                  forceTcp: this._forceTcp,\n                  producing: true,\n                  consuming: false,\n                  sctpCapabilities: undefined\n                });\n\n              case 10:\n                sendTransportInfo = _context5.sent;\n                this._sendTransport = this._mediasoupDevice.createSendTransport({\n                  id: sendTransportInfo.id,\n                  iceParameters: sendTransportInfo.iceParameters,\n                  iceCandidates: sendTransportInfo.iceCandidates,\n                  dtlsParameters: sendTransportInfo.dtlsParameters,\n                  sctpParameters: sendTransportInfo.sctpParameters,\n                  iceServers: this._iceServers,\n                  iceTransportPolicy: this._iceTransportPolicy,\n                  proprietaryConstraints: PC_PROPRIETARY_CONSTRAINTS\n                });\n\n                this._sendTransport.on(\"connect\", function (_ref3, callback, errback // eslint-disable-line no-shadow\n                ) {\n                  var dtlsParameters = _ref3.dtlsParameters;\n\n                  _this2._protoo.request(\"connectWebRtcTransport\", {\n                    transportId: _this2._sendTransport.id,\n                    dtlsParameters: dtlsParameters\n                  }).then(callback)[\"catch\"](errback);\n                });\n\n                this._sendTransport.on(\"produce\", /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(_ref4, callback, errback) {\n                    var kind, rtpParameters, appData, _yield$_this2$_protoo, id;\n\n                    return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            kind = _ref4.kind, rtpParameters = _ref4.rtpParameters, appData = _ref4.appData;\n                            _context4.prev = 1;\n                            _context4.next = 4;\n                            return _this2._protoo.request(\"produce\", {\n                              transportId: _this2._sendTransport.id,\n                              kind: kind,\n                              rtpParameters: rtpParameters,\n                              appData: appData\n                            });\n\n                          case 4:\n                            _yield$_this2$_protoo = _context4.sent;\n                            id = _yield$_this2$_protoo.id;\n                            callback({\n                              id: id\n                            });\n                            _context4.next = 12;\n                            break;\n\n                          case 9:\n                            _context4.prev = 9;\n                            _context4.t0 = _context4[\"catch\"](1);\n                            errback(_context4.t0);\n\n                          case 12:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, null, [[1, 9]]);\n                  }));\n\n                  return function (_x4, _x5, _x6) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }()); // Create mediasoup Transport for sending (unless we don't want to consume).\n\n\n                _context5.next = 16;\n                return this._protoo.request(\"createWebRtcTransport\", {\n                  forceTcp: this._forceTcp,\n                  producing: false,\n                  consuming: true,\n                  sctpCapabilities: undefined\n                });\n\n              case 16:\n                recvTransportInfo = _context5.sent;\n                this._recvTransport = this._mediasoupDevice.createRecvTransport({\n                  id: recvTransportInfo.id,\n                  iceParameters: recvTransportInfo.iceParameters,\n                  iceCandidates: recvTransportInfo.iceCandidates,\n                  dtlsParameters: recvTransportInfo.dtlsParameters,\n                  sctpParameters: recvTransportInfo.sctpParameters,\n                  iceServers: this._iceServers\n                });\n\n                this._recvTransport.on(\"connect\", function (_ref6, callback, errback // eslint-disable-line no-shadow\n                ) {\n                  var dtlsParameters = _ref6.dtlsParameters;\n\n                  _this2._protoo.request(\"connectWebRtcTransport\", {\n                    transportId: _this2._recvTransport.id,\n                    dtlsParameters: dtlsParameters\n                  }).then(callback)[\"catch\"](errback);\n                });\n\n                _context5.next = 21;\n                return this._protoo.request(\"join\", {\n                  displayName: this._clientId,\n                  device: this._device,\n                  rtpCapabilities: this._mediasoupDevice.rtpCapabilities,\n                  sctpCapabilities: this._useDataChannel ? this._mediasoupDevice.sctpCapabilities : undefined,\n                  token: this._joinToken\n                });\n\n              case 21:\n                _yield$this$_protoo$r = _context5.sent;\n                peers = _yield$this$_protoo$r.peers;\n                audioConsumerPromises = [];\n                this.occupants = []; // Create a promise that will be resolved once we attach to all the initial consumers.\n                // This will gate the connection flow until all voices will be heard.\n\n                _loop = function _loop(i) {\n                  var peerId = peers[i].id;\n\n                  _this2.occupants.push(peerId);\n\n                  if (!peers[i].hasProducers) return \"continue\";\n                  audioConsumerPromises.push(new Promise(function (res) {\n                    return _this2._initialAudioConsumerResolvers.set(peerId, res);\n                  }));\n                };\n\n                i = 0;\n\n              case 27:\n                if (!(i < peers.length)) {\n                  _context5.next = 34;\n                  break;\n                }\n\n                _ret = _loop(i);\n\n                if (!(_ret === \"continue\")) {\n                  _context5.next = 31;\n                  break;\n                }\n\n                return _context5.abrupt(\"continue\", 31);\n\n              case 31:\n                i++;\n                _context5.next = 27;\n                break;\n\n              case 34:\n                this._connectSuccess(this._clientId);\n\n                this._initialAudioConsumerPromise = Promise.all(audioConsumerPromises);\n\n                if (this._localMediaStream) {\n                  this.createMissingProducers(this._localMediaStream);\n                }\n\n                _context5.next = 43;\n                break;\n\n              case 39:\n                _context5.prev = 39;\n                _context5.t0 = _context5[\"catch\"](1);\n                error(\"_joinRoom() failed:%o\", _context5.t0);\n                this.disconnect();\n\n              case 43:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 39]]);\n      }));\n\n      function _joinRoom() {\n        return _joinRoom2.apply(this, arguments);\n      }\n\n      return _joinRoom;\n    }()\n  }, {\n    key: \"setLocalMediaStream\",\n    value: function setLocalMediaStream(stream) {\n      this.createMissingProducers(stream);\n    }\n  }, {\n    key: \"createMissingProducers\",\n    value: function createMissingProducers(stream) {\n      var _this3 = this;\n\n      if (!this._sendTransport) return;\n      var sawAudio = false;\n      var sawVideo = false;\n      stream.getTracks().forEach( /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(track) {\n          return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (!(track.kind === \"audio\")) {\n                    _context6.next = 14;\n                    break;\n                  }\n\n                  sawAudio = true; // TODO multiple audio tracks?\n\n                  if (!_this3._micProducer) {\n                    _context6.next = 6;\n                    break;\n                  }\n\n                  if (_this3._micProducer.track !== track) {\n                    _this3._micProducer.track.stop();\n\n                    _this3._micProducer.replaceTrack(track);\n                  }\n\n                  _context6.next = 12;\n                  break;\n\n                case 6:\n                  if (!_this3._micEnabled) {\n                    track.enabled = false;\n                  } // stopTracks = false because otherwise the track will end during a temporary disconnect\n\n\n                  _context6.next = 9;\n                  return _this3._sendTransport.produce({\n                    track: track,\n                    stopTracks: false,\n                    codecOptions: {\n                      opusStereo: false,\n                      opusDtx: true\n                    }\n                  });\n\n                case 9:\n                  _this3._micProducer = _context6.sent;\n\n                  _this3._micProducer.on(\"transportclose\", function () {\n                    return _this3._micProducer = null;\n                  });\n\n                  if (!_this3._micEnabled) {\n                    _this3._micProducer.pause();\n                  }\n\n                case 12:\n                  _context6.next = 23;\n                  break;\n\n                case 14:\n                  sawVideo = true;\n\n                  if (!_this3._videoProducer) {\n                    _context6.next = 19;\n                    break;\n                  }\n\n                  if (_this3._videoProducer.track !== track) {\n                    _this3._videoProducer.track.stop();\n\n                    _this3._videoProducer.replaceTrack(track);\n                  }\n\n                  _context6.next = 23;\n                  break;\n\n                case 19:\n                  _context6.next = 21;\n                  return _this3._sendTransport.produce({\n                    track: track,\n                    stopTracks: false,\n                    codecOptions: {\n                      videoGoogleStartBitrate: 1000\n                    }\n                  });\n\n                case 21:\n                  _this3._videoProducer = _context6.sent;\n\n                  _this3._videoProducer.on(\"transportclose\", function () {\n                    return _this3._videoProducer = null;\n                  });\n\n                case 23:\n                  _this3.resolvePendingMediaRequestForTrack(_this3._clientId, track);\n\n                case 24:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6);\n        }));\n\n        return function (_x7) {\n          return _ref7.apply(this, arguments);\n        };\n      }());\n\n      if (!sawAudio && this._micProducer) {\n        this._micProducer.close();\n\n        this._protoo.request(\"closeProducer\", {\n          producerId: this._micProducer.id\n        });\n\n        this._micProducer = null;\n      }\n\n      if (!sawVideo && this._videoProducer) {\n        this._videoProducer.close();\n\n        this._protoo.request(\"closeProducer\", {\n          producerId: this._videoProducer.id\n        });\n\n        this._videoProducer = null;\n      }\n\n      this._localMediaStream = stream;\n    }\n  }, {\n    key: \"enableMicrophone\",\n    value: function enableMicrophone(enabled) {\n      if (this._micProducer) {\n        if (enabled) {\n          this._micProducer.resume();\n        } else {\n          this._micProducer.pause();\n        }\n      }\n\n      this._micEnabled = enabled;\n    }\n  }, {\n    key: \"setWebRtcOptions\",\n    value: function setWebRtcOptions() {// Not implemented\n    }\n  }, {\n    key: \"isDisconnected\",\n    value: function isDisconnected() {\n      return !this._protoo.connected;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this._closed) return;\n      this._closed = true;\n\n      for (var i = 0; i < this.occupants.length; i++) {\n        var peerId = this.occupants[i];\n        if (peerId === this._clientId) continue;\n\n        this._onOccupantDisconnected(peerId);\n      }\n\n      this.occupants = [];\n      debug(\"disconnect()\"); // Close protoo Peer, though may already be closed if this is happening due to websocket breakdown\n\n      if (this._protoo && this._protoo.connected) {\n        this._protoo.close();\n      } // Close mediasoup Transports.\n\n\n      if (this._sendTransport) this._sendTransport.close();\n      if (this._recvTransport) this._recvTransport.close();\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect() {\n      var _this4 = this;\n\n      // Dispose of all networked entities and other resources tied to the session.\n      this.disconnect();\n      this.connect().then(function () {\n        _this4.reconnectionDelay = _this4.initialReconnectionDelay;\n        _this4.reconnectionAttempts = 0;\n\n        if (_this4._reconnectedListener) {\n          _this4._reconnectedListener();\n        }\n      })[\"catch\"](function (error) {\n        _this4.reconnectionDelay += 1000;\n        _this4.reconnectionAttempts++;\n\n        if (_this4.reconnectionAttempts > _this4.maxReconnectionAttempts && _this4._reconnectionErrorListener) {\n          return _this4._reconnectionErrorListener(new Error(\"Connection could not be reestablished, exceeded maximum number of reconnection attempts.\"));\n        }\n\n        console.warn(\"Error during reconnect, retrying.\");\n        console.warn(error);\n\n        if (_this4._reconnectingListener) {\n          _this4._reconnectingListener(_this4.reconnectionDelay);\n        }\n\n        _this4.reconnectionTimeout = setTimeout(function () {\n          return _this4.reconnect();\n        }, _this4.reconnectionDelay);\n      });\n    }\n  }, {\n    key: \"kick\",\n    value: function kick(clientId, permsToken) {\n      return this._protoo.request(\"kick\", {\n        room_id: this.room,\n        user_id: clientId,\n        token: permsToken\n      }).then(function () {\n        document.body.dispatchEvent(new CustomEvent(\"kicked\", {\n          detail: {\n            clientId: clientId\n          }\n        }));\n      });\n    }\n  }, {\n    key: \"block\",\n    value: function block(clientId) {\n      var _this5 = this;\n\n      return this._protoo.request(\"block\", {\n        whom: clientId\n      }).then(function () {\n        _this5._blockedClients.set(clientId, true);\n\n        document.body.dispatchEvent(new CustomEvent(\"blocked\", {\n          detail: {\n            clientId: clientId\n          }\n        }));\n      });\n    }\n  }, {\n    key: \"unblock\",\n    value: function unblock(clientId) {\n      var _this6 = this;\n\n      return this._protoo.request(\"unblock\", {\n        whom: clientId\n      }).then(function () {\n        _this6._blockedClients[\"delete\"](clientId);\n\n        document.body.dispatchEvent(new CustomEvent(\"unblocked\", {\n          detail: {\n            clientId: clientId\n          }\n        }));\n      });\n    }\n  }, {\n    key: \"updateTimeOffset\",\n    value: function () {\n      var _updateTimeOffset = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n        var _this7 = this;\n\n        var clientSentTime, res, precision, serverReceivedTime, clientReceivedTime, serverTime, timeOffset;\n        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this.isDisconnected()) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 2:\n                clientSentTime = Date.now();\n                _context7.next = 5;\n                return fetch(document.location.href, {\n                  method: \"HEAD\",\n                  cache: \"no-cache\"\n                });\n\n              case 5:\n                res = _context7.sent;\n                precision = 1000;\n                serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + precision / 2;\n                clientReceivedTime = Date.now();\n                serverTime = serverReceivedTime + (clientReceivedTime - clientSentTime) / 2;\n                timeOffset = serverTime - clientReceivedTime;\n                this._serverTimeRequests++;\n\n                if (this._serverTimeRequests <= 10) {\n                  this._timeOffsets.push(timeOffset);\n                } else {\n                  this._timeOffsets[this._serverTimeRequests % 10] = timeOffset;\n                }\n\n                this._avgTimeOffset = this._timeOffsets.reduce(function (acc, offset) {\n                  return acc += offset;\n                }, 0) / this._timeOffsets.length;\n\n                if (this._serverTimeRequests > 10) {\n                  debug(\"new server time offset: \".concat(this._avgTimeOffset, \"ms\"));\n                  setTimeout(function () {\n                    return _this7.updateTimeOffset();\n                  }, 5 * 60 * 1000); // Sync clock every 5 minutes.\n                } else {\n                  this.updateTimeOffset();\n                }\n\n              case 15:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function updateTimeOffset() {\n        return _updateTimeOffset.apply(this, arguments);\n      }\n\n      return updateTimeOffset;\n    }()\n  }, {\n    key: \"toggleFreeze\",\n    value: function toggleFreeze() {\n      if (this.frozen) {\n        this.unfreeze();\n      } else {\n        this.freeze();\n      }\n    }\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      this.frozen = true;\n    }\n  }, {\n    key: \"unfreeze\",\n    value: function unfreeze() {\n      this.frozen = false;\n      this.flushPendingUpdates();\n    }\n  }, {\n    key: \"storeMessage\",\n    value: function storeMessage(message) {\n      if (message.dataType === \"um\") {\n        // UpdateMulti\n        for (var i = 0, l = message.data.d.length; i < l; i++) {\n          this.storeSingleMessage(message, i);\n        }\n      } else {\n        this.storeSingleMessage(message);\n      }\n    }\n  }, {\n    key: \"storeSingleMessage\",\n    value: function storeSingleMessage(message, index) {\n      var data = index !== undefined ? message.data.d[index] : message.data;\n      var dataType = message.dataType;\n      var networkId = data.networkId;\n\n      if (!this._frozenUpdates.has(networkId)) {\n        this._frozenUpdates.set(networkId, message);\n      } else {\n        var storedMessage = this._frozenUpdates.get(networkId);\n\n        var storedData = storedMessage.dataType === \"um\" ? this.dataForUpdateMultiMessage(networkId, storedMessage) : storedMessage.data; // Avoid updating components if the entity data received did not come from the current owner.\n\n        var isOutdatedMessage = data.lastOwnerTime < storedData.lastOwnerTime;\n        var isContemporaneousMessage = data.lastOwnerTime === storedData.lastOwnerTime;\n\n        if (isOutdatedMessage || isContemporaneousMessage && storedData.owner > data.owner) {\n          return;\n        }\n\n        if (dataType === \"r\") {\n          var createdWhileFrozen = storedData && storedData.isFirstSync;\n\n          if (createdWhileFrozen) {\n            // If the entity was created and deleted while frozen, don't bother conveying anything to the consumer.\n            this._frozenUpdates[\"delete\"](networkId);\n          } else {\n            // Delete messages override any other messages for this entity\n            this._frozenUpdates.set(networkId, message);\n          }\n        } else {\n          // merge in component updates\n          if (storedData.components && data.components) {\n            Object.assign(storedData.components, data.components);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"onDataChannelMessage\",\n    value: function onDataChannelMessage(e, source) {\n      this.onData(JSON.parse(e.data), source);\n    }\n  }, {\n    key: \"onData\",\n    value: function onData(message, source) {\n      if (debug.enabled) {\n        debug(\"DC in: \".concat(message));\n      }\n\n      if (!message.dataType) return;\n      message.source = source;\n\n      if (this.frozen) {\n        this.storeMessage(message);\n      } else {\n        this._onOccupantMessage(null, message.dataType, message.data, message.source);\n      }\n    }\n  }, {\n    key: \"getPendingData\",\n    value: function getPendingData(networkId, message) {\n      if (!message) return null;\n      var data = message.dataType === \"um\" ? this.dataForUpdateMultiMessage(networkId, message) : message.data; // Ignore messages from users that we may have blocked while frozen.\n\n      if (data.owner && this._blockedClients.has(data.owner)) return null;\n      return data;\n    } // Used externally\n\n  }, {\n    key: \"getPendingDataForNetworkId\",\n    value: function getPendingDataForNetworkId(networkId) {\n      return this.getPendingData(networkId, this._frozenUpdates.get(networkId));\n    }\n  }, {\n    key: \"flushPendingUpdates\",\n    value: function flushPendingUpdates() {\n      var _iterator2 = _createForOfIteratorHelper(this._frozenUpdates),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              networkId = _step2$value[0],\n              message = _step2$value[1];\n\n          var data = this.getPendingData(networkId, message);\n          if (!data) continue; // Override the data type on \"um\" messages types, since we extract entity updates from \"um\" messages into\n          // individual frozenUpdates in storeSingleMessage.\n\n          var dataType = message.dataType === \"um\" ? \"u\" : message.dataType;\n\n          this._onOccupantMessage(null, dataType, data, message.source);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._frozenUpdates.clear();\n    }\n  }, {\n    key: \"dataForUpdateMultiMessage\",\n    value: function dataForUpdateMultiMessage(networkId, message) {\n      // \"d\" is an array of entity datas, where each item in the array represents a unique entity and contains\n      // metadata for the entity, and an array of components that have been updated on the entity.\n      // This method finds the data corresponding to the given networkId.\n      for (var i = 0, l = message.data.d.length; i < l; i++) {\n        var data = message.data.d[i];\n\n        if (data.networkId === networkId) {\n          return data;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return NWClientAPIAdapter;\n}(); //NAF.adapters.register(\"dialog\", DialogAdapter);\n\n\nmodule.exports = NWClientAPIAdapter;\n\n//# sourceURL=webpack:///./src/adapters/naf-nwclientapi-adapter.js?");

/***/ }),

/***/ "./src/adapters/naf-socketio-adapter.js":
/*!**********************************************!*\
  !*** ./src/adapters/naf-socketio-adapter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global NAF, io */\n\n/**\n * SocketIO Adapter (socketio)\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\nvar SocketioAdapter = /*#__PURE__*/function () {\n  function SocketioAdapter() {\n    _classCallCheck(this, SocketioAdapter);\n\n    if (io === undefined) console.warn('It looks like socket.io has not been loaded before SocketioAdapter. Please do that.');\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n    this.myId = null;\n    this.occupants = {}; // id -> joinTimestamp\n\n    this.connectedClients = [];\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  _createClass(SocketioAdapter, [{\n    key: \"setServerUrl\",\n    value: function setServerUrl(wsUrl) {\n      this.wsUrl = wsUrl;\n    }\n  }, {\n    key: \"setApp\",\n    value: function setApp(appName) {\n      this.app = appName;\n    }\n  }, {\n    key: \"setRoom\",\n    value: function setRoom(roomName) {\n      this.room = roomName;\n    }\n  }, {\n    key: \"setWebRtcOptions\",\n    value: function setWebRtcOptions(options) {// No WebRTC support\n    }\n  }, {\n    key: \"setServerConnectListeners\",\n    value: function setServerConnectListeners(successListener, failureListener) {\n      this.connectSuccess = successListener;\n      this.connectFailure = failureListener;\n    }\n  }, {\n    key: \"setRoomOccupantListener\",\n    value: function setRoomOccupantListener(occupantListener) {\n      this.occupantListener = occupantListener;\n    }\n  }, {\n    key: \"setDataChannelListeners\",\n    value: function setDataChannelListeners(openListener, closedListener, messageListener) {\n      this.openListener = openListener;\n      this.closedListener = closedListener;\n      this.messageListener = messageListener;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var self = this;\n      this.updateTimeOffset().then(function () {\n        if (!self.wsUrl || self.wsUrl === \"/\") {\n          if (location.protocol === \"https:\") {\n            self.wsUrl = \"wss://\" + location.host;\n          } else {\n            self.wsUrl = \"ws://\" + location.host;\n          }\n        }\n\n        NAF.log.write(\"Attempting to connect to socket.io\");\n        var socket = self.socket = io(self.wsUrl);\n        socket.on(\"connect\", function () {\n          NAF.log.write(\"User connected\", socket.id);\n          self.myId = socket.id;\n          self.joinRoom();\n        });\n        socket.on(\"connectSuccess\", function (data) {\n          var joinedTime = data.joinedTime;\n          self.myRoomJoinTime = joinedTime;\n          NAF.log.write(\"Successfully joined room\", self.room, \"at server time\", joinedTime);\n          self.connectSuccess(self.myId);\n        });\n        socket.on(\"error\", function (err) {\n          console.error(\"Socket connection failure\", err);\n          self.connectFailure();\n        });\n        socket.on(\"occupantsChanged\", function (data) {\n          var occupants = data.occupants;\n          NAF.log.write('occupants changed', data);\n          self.receivedOccupants(occupants);\n        });\n\n        function receiveData(packet) {\n          var from = packet.from;\n          var type = packet.type;\n          var data = packet.data;\n          self.messageListener(from, type, data);\n        }\n\n        socket.on(\"send\", receiveData);\n        socket.on(\"broadcast\", receiveData);\n      });\n    }\n  }, {\n    key: \"joinRoom\",\n    value: function joinRoom() {\n      NAF.log.write(\"Joining room\", this.room);\n      this.socket.emit(\"joinRoom\", {\n        room: this.room\n      });\n    }\n  }, {\n    key: \"receivedOccupants\",\n    value: function receivedOccupants(occupants) {\n      delete occupants[this.myId];\n      this.occupants = occupants;\n      this.occupantListener(occupants);\n    }\n  }, {\n    key: \"shouldStartConnectionTo\",\n    value: function shouldStartConnectionTo(client) {\n      return true;\n    }\n  }, {\n    key: \"startStreamConnection\",\n    value: function startStreamConnection(remoteId) {\n      this.connectedClients.push(remoteId);\n      this.openListener(remoteId);\n    }\n  }, {\n    key: \"closeStreamConnection\",\n    value: function closeStreamConnection(clientId) {\n      this.connectedClients = this.connectedClients.filter(function (c) {\n        return c != clientId;\n      });\n      this.closedListener(clientId);\n    }\n  }, {\n    key: \"getConnectStatus\",\n    value: function getConnectStatus(clientId) {\n      var connected = this.connectedClients.indexOf(clientId) != -1;\n\n      if (connected) {\n        return NAF.adapters.IS_CONNECTED;\n      } else {\n        return NAF.adapters.NOT_CONNECTED;\n      }\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(to, type, data) {\n      this.sendDataGuaranteed(to, type, data);\n    }\n  }, {\n    key: \"sendDataGuaranteed\",\n    value: function sendDataGuaranteed(to, type, data) {\n      var packet = {\n        from: this.myId,\n        to: to,\n        type: type,\n        data: data,\n        sending: true\n      };\n\n      if (this.socket) {\n        this.socket.emit(\"send\", packet);\n      } else {\n        NAF.log.warn('SocketIO socket not created yet');\n      }\n    }\n  }, {\n    key: \"broadcastData\",\n    value: function broadcastData(type, data) {\n      this.broadcastDataGuaranteed(type, data);\n    }\n  }, {\n    key: \"broadcastDataGuaranteed\",\n    value: function broadcastDataGuaranteed(type, data) {\n      var packet = {\n        from: this.myId,\n        type: type,\n        data: data,\n        broadcasting: true\n      };\n\n      if (this.socket) {\n        this.socket.emit(\"broadcast\", packet);\n      } else {\n        NAF.log.warn('SocketIO socket not created yet');\n      }\n    }\n  }, {\n    key: \"getMediaStream\",\n    value: function getMediaStream(clientId) {// Do not support WebRTC\n    }\n  }, {\n    key: \"updateTimeOffset\",\n    value: function updateTimeOffset() {\n      var _this = this;\n\n      var clientSentTime = Date.now() + this.avgTimeOffset;\n      return fetch(document.location.href, {\n        method: \"HEAD\",\n        cache: \"no-cache\"\n      }).then(function (res) {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + precision / 2;\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + (clientReceivedTime - clientSentTime) / 2;\n        var timeOffset = serverTime - clientReceivedTime;\n        _this.serverTimeRequests++;\n\n        if (_this.serverTimeRequests <= 10) {\n          _this.timeOffsets.push(timeOffset);\n        } else {\n          _this.timeOffsets[_this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        _this.avgTimeOffset = _this.timeOffsets.reduce(function (acc, offset) {\n          return acc += offset;\n        }, 0) / _this.timeOffsets.length;\n\n        if (_this.serverTimeRequests > 10) {\n          setTimeout(function () {\n            return _this.updateTimeOffset();\n          }, 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          _this.updateTimeOffset();\n        }\n      });\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function getServerTime() {\n      return new Date().getTime() + this.avgTimeOffset;\n    }\n  }]);\n\n  return SocketioAdapter;\n}(); // NAF.adapters.register(\"socketio\", SocketioAdapter);\n\n\nmodule.exports = SocketioAdapter;\n\n//# sourceURL=webpack:///./src/adapters/naf-socketio-adapter.js?");

/***/ }),

/***/ "./src/adapters/naf-webrtc-adapter.js":
/*!********************************************!*\
  !*** ./src/adapters/naf-webrtc-adapter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* global NAF, io */\nvar WebRtcPeer = /*#__PURE__*/function () {\n  function WebRtcPeer(localId, remoteId, sendSignalFunc) {\n    _classCallCheck(this, WebRtcPeer);\n\n    this.localId = localId;\n    this.remoteId = remoteId;\n    this.sendSignalFunc = sendSignalFunc;\n    this.open = false;\n    this.channelLabel = \"networked-aframe-channel\";\n    this.pc = this.createPeerConnection();\n    this.channel = null;\n  }\n\n  _createClass(WebRtcPeer, [{\n    key: \"setDatachannelListeners\",\n    value: function setDatachannelListeners(openListener, closedListener, messageListener, trackListener) {\n      this.openListener = openListener;\n      this.closedListener = closedListener;\n      this.messageListener = messageListener;\n      this.trackListener = trackListener;\n    }\n  }, {\n    key: \"offer\",\n    value: function offer(options) {\n      var self = this; // reliable: false - UDP\n\n      this.setupChannel(this.pc.createDataChannel(this.channelLabel, {\n        reliable: false\n      })); // If there are errors with Safari implement this:\n      // https://github.com/OpenVidu/openvidu/blob/master/openvidu-browser/src/OpenViduInternal/WebRtcPeer/WebRtcPeer.ts#L154\n\n      if (options.sendAudio) {\n        options.localAudioStream.getTracks().forEach(function (track) {\n          return self.pc.addTrack(track, options.localAudioStream);\n        });\n      }\n\n      this.pc.createOffer(function (sdp) {\n        self.handleSessionDescription(sdp);\n      }, function (error) {\n        NAF.log.error(\"WebRtcPeer.offer: \" + error);\n      }, {\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: false\n      });\n    }\n  }, {\n    key: \"handleSignal\",\n    value: function handleSignal(signal) {\n      // ignores signal if it isn't for me\n      if (this.localId !== signal.to || this.remoteId !== signal.from) return;\n\n      switch (signal.type) {\n        case \"offer\":\n          this.handleOffer(signal);\n          break;\n\n        case \"answer\":\n          this.handleAnswer(signal);\n          break;\n\n        case \"candidate\":\n          this.handleCandidate(signal);\n          break;\n\n        default:\n          NAF.log.error(\"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type);\n          break;\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(type, data) {\n      if (this.channel === null || this.channel.readyState !== \"open\") {\n        return;\n      }\n\n      this.channel.send(JSON.stringify({\n        type: type,\n        data: data\n      }));\n    }\n  }, {\n    key: \"getStatus\",\n    value: function getStatus() {\n      if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\n\n      switch (this.channel.readyState) {\n        case \"open\":\n          return WebRtcPeer.IS_CONNECTED;\n\n        case \"connecting\":\n          return WebRtcPeer.CONNECTING;\n\n        case \"closing\":\n        case \"closed\":\n        default:\n          return WebRtcPeer.NOT_CONNECTED;\n      }\n    }\n    /*\n     * Privates\n     */\n\n  }, {\n    key: \"createPeerConnection\",\n    value: function createPeerConnection() {\n      var self = this;\n      var RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection;\n\n      if (RTCPeerConnection === undefined) {\n        throw new Error(\"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\");\n      }\n\n      var pc = new RTCPeerConnection({\n        iceServers: WebRtcPeer.ICE_SERVERS\n      });\n\n      pc.onicecandidate = function (event) {\n        if (event.candidate) {\n          self.sendSignalFunc({\n            from: self.localId,\n            to: self.remoteId,\n            type: \"candidate\",\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            candidate: event.candidate.candidate\n          });\n        }\n      }; // Note: seems like channel.onclose hander is unreliable on some platforms,\n      //       so also tries to detect disconnection here.\n\n\n      pc.oniceconnectionstatechange = function () {\n        if (self.open && pc.iceConnectionState === \"disconnected\") {\n          self.open = false;\n          self.closedListener(self.remoteId);\n        }\n      };\n\n      pc.ontrack = function (e) {\n        self.trackListener(self.remoteId, e.streams[0]);\n      };\n\n      return pc;\n    }\n  }, {\n    key: \"setupChannel\",\n    value: function setupChannel(channel) {\n      var self = this;\n      this.channel = channel; // received data from a remote peer\n\n      this.channel.onmessage = function (event) {\n        var data = JSON.parse(event.data);\n        self.messageListener(self.remoteId, data.type, data.data);\n      }; // connected with a remote peer\n\n\n      this.channel.onopen = function (_event) {\n        self.open = true;\n        self.openListener(self.remoteId);\n      }; // disconnected with a remote peer\n\n\n      this.channel.onclose = function (_event) {\n        if (!self.open) return;\n        self.open = false;\n        self.closedListener(self.remoteId);\n      }; // error occurred with a remote peer\n\n\n      this.channel.onerror = function (error) {\n        NAF.log.error(\"WebRtcPeer.channel.onerror: \" + error);\n      };\n    }\n  }, {\n    key: \"handleOffer\",\n    value: function handleOffer(message) {\n      var self = this;\n\n      this.pc.ondatachannel = function (event) {\n        self.setupChannel(event.channel);\n      };\n\n      this.setRemoteDescription(message);\n      this.pc.createAnswer(function (sdp) {\n        self.handleSessionDescription(sdp);\n      }, function (error) {\n        NAF.log.error(\"WebRtcPeer.handleOffer: \" + error);\n      });\n    }\n  }, {\n    key: \"handleAnswer\",\n    value: function handleAnswer(message) {\n      this.setRemoteDescription(message);\n    }\n  }, {\n    key: \"handleCandidate\",\n    value: function handleCandidate(message) {\n      var RTCIceCandidate = window.RTCIceCandidate || window.webkitRTCIceCandidate || window.mozRTCIceCandidate;\n      this.pc.addIceCandidate(new RTCIceCandidate(message), function () {}, function (error) {\n        NAF.log.error(\"WebRtcPeer.handleCandidate: \" + error);\n      });\n    }\n  }, {\n    key: \"handleSessionDescription\",\n    value: function handleSessionDescription(sdp) {\n      this.pc.setLocalDescription(sdp, function () {}, function (error) {\n        NAF.log.error(\"WebRtcPeer.handleSessionDescription: \" + error);\n      });\n      this.sendSignalFunc({\n        from: this.localId,\n        to: this.remoteId,\n        type: sdp.type,\n        sdp: sdp.sdp\n      });\n    }\n  }, {\n    key: \"setRemoteDescription\",\n    value: function setRemoteDescription(message) {\n      var RTCSessionDescription = window.RTCSessionDescription || window.webkitRTCSessionDescription || window.mozRTCSessionDescription || window.msRTCSessionDescription;\n      this.pc.setRemoteDescription(new RTCSessionDescription(message), function () {}, function (error) {\n        NAF.log.error(\"WebRtcPeer.setRemoteDescription: \" + error);\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.pc) {\n        this.pc.close();\n      }\n    }\n  }]);\n\n  return WebRtcPeer;\n}();\n\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\nWebRtcPeer.CONNECTING = \"CONNECTING\";\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\nWebRtcPeer.ICE_SERVERS = [{\n  urls: \"stun:stun1.l.google.com:19302\"\n}, {\n  urls: \"stun:stun2.l.google.com:19302\"\n}, {\n  urls: \"stun:stun3.l.google.com:19302\"\n}, {\n  urls: \"stun:stun4.l.google.com:19302\"\n}];\n/**\n * Native WebRTC Adapter (native-webrtc)\n * For use with uws-server.js\n * networked-scene: serverURL needs to be ws://localhost:8080 when running locally\n */\n\nvar WebrtcAdapter = /*#__PURE__*/function () {\n  function WebrtcAdapter() {\n    _classCallCheck(this, WebrtcAdapter);\n\n    if (io === undefined) console.warn('It looks like socket.io has not been loaded before WebrtcAdapter. Please do that.');\n    this.app = \"default\";\n    this.room = \"default\";\n    this.occupantListener = null;\n    this.myRoomJoinTime = null;\n    this.myId = null;\n    this.peers = {}; // id -> WebRtcPeer\n\n    this.occupants = {}; // id -> joinTimestamp\n\n    this.audioStreams = {};\n    this.pendingAudioRequest = {};\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  _createClass(WebrtcAdapter, [{\n    key: \"setServerUrl\",\n    value: function setServerUrl(wsUrl) {\n      this.wsUrl = wsUrl;\n    }\n  }, {\n    key: \"setApp\",\n    value: function setApp(appName) {\n      this.app = appName;\n    }\n  }, {\n    key: \"setRoom\",\n    value: function setRoom(roomName) {\n      this.room = roomName;\n    }\n  }, {\n    key: \"setWebRtcOptions\",\n    value: function setWebRtcOptions(options) {\n      if (options.datachannel === false) {\n        NAF.log.error(\"WebrtcAdapter.setWebRtcOptions: datachannel must be true.\");\n      }\n\n      if (options.audio === true) {\n        this.sendAudio = true;\n      }\n\n      if (options.video === true) {\n        NAF.log.warn(\"WebrtcAdapter does not support video yet.\");\n      }\n    }\n  }, {\n    key: \"setServerConnectListeners\",\n    value: function setServerConnectListeners(successListener, failureListener) {\n      this.connectSuccess = successListener;\n      this.connectFailure = failureListener;\n    }\n  }, {\n    key: \"setRoomOccupantListener\",\n    value: function setRoomOccupantListener(occupantListener) {\n      this.occupantListener = occupantListener;\n    }\n  }, {\n    key: \"setDataChannelListeners\",\n    value: function setDataChannelListeners(openListener, closedListener, messageListener) {\n      this.openListener = openListener;\n      this.closedListener = closedListener;\n      this.messageListener = messageListener;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var self = this;\n      this.updateTimeOffset().then(function () {\n        if (!self.wsUrl || self.wsUrl === \"/\") {\n          if (location.protocol === \"https:\") {\n            self.wsUrl = \"wss://\" + location.host;\n          } else {\n            self.wsUrl = \"ws://\" + location.host;\n          }\n        }\n\n        NAF.log.write(\"Attempting to connect to socket.io\");\n        var socket = self.socket = io(self.wsUrl);\n        socket.on(\"connect\", function () {\n          NAF.log.write(\"User connected\", socket.id);\n          self.myId = socket.id;\n          self.joinRoom();\n        });\n        socket.on(\"connectSuccess\", function (data) {\n          var joinedTime = data.joinedTime;\n          self.myRoomJoinTime = joinedTime;\n          NAF.log.write(\"Successfully joined room\", self.room, \"at server time\", joinedTime);\n\n          if (self.sendAudio) {\n            var mediaConstraints = {\n              audio: true,\n              video: false\n            };\n            navigator.mediaDevices.getUserMedia(mediaConstraints).then(function (localStream) {\n              self.storeAudioStream(self.myId, localStream);\n              self.connectSuccess(self.myId);\n              localStream.getTracks().forEach(function (track) {\n                Object.keys(self.peers).forEach(function (peerId) {\n                  self.peers[peerId].pc.addTrack(track, localStream);\n                });\n              });\n            })[\"catch\"](function (e) {\n              NAF.log.error(e);\n              console.error(\"Microphone is disabled due to lack of permissions\");\n              self.sendAudio = false;\n              self.connectSuccess(self.myId);\n            });\n          } else {\n            self.connectSuccess(self.myId);\n          }\n        });\n        socket.on(\"error\", function (err) {\n          console.error(\"Socket connection failure\", err);\n          self.connectFailure();\n        });\n        socket.on(\"occupantsChanged\", function (data) {\n          var occupants = data.occupants;\n          NAF.log.write('occupants changed', data);\n          self.receivedOccupants(occupants);\n        });\n\n        function receiveData(packet) {\n          var from = packet.from;\n          var type = packet.type;\n          var data = packet.data;\n\n          if (type === 'ice-candidate') {\n            self.peers[from].handleSignal(data);\n            return;\n          }\n\n          self.messageListener(from, type, data);\n        }\n\n        socket.on(\"send\", receiveData);\n        socket.on(\"broadcast\", receiveData);\n      });\n    }\n  }, {\n    key: \"joinRoom\",\n    value: function joinRoom() {\n      NAF.log.write(\"Joining room\", this.room);\n      this.socket.emit(\"joinRoom\", {\n        room: this.room\n      });\n    }\n  }, {\n    key: \"receivedOccupants\",\n    value: function receivedOccupants(occupants) {\n      var _this = this;\n\n      delete occupants[this.myId];\n      this.occupants = occupants;\n      var self = this;\n      var localId = this.myId;\n\n      var _loop = function _loop(key) {\n        var remoteId = key;\n        if (_this.peers[remoteId]) return \"continue\";\n        var peer = new WebRtcPeer(localId, remoteId, function (data) {\n          self.socket.emit('send', {\n            from: localId,\n            to: remoteId,\n            type: 'ice-candidate',\n            data: data,\n            sending: true\n          });\n        });\n        peer.setDatachannelListeners(self.openListener, self.closedListener, self.messageListener, self.trackListener.bind(self));\n        self.peers[remoteId] = peer;\n      };\n\n      for (var key in occupants) {\n        var _ret = _loop(key);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      this.occupantListener(occupants);\n    }\n  }, {\n    key: \"shouldStartConnectionTo\",\n    value: function shouldStartConnectionTo(client) {\n      return (this.myRoomJoinTime || 0) <= (client || 0);\n    }\n  }, {\n    key: \"startStreamConnection\",\n    value: function startStreamConnection(remoteId) {\n      var _this2 = this;\n\n      NAF.log.write('starting offer process');\n\n      if (this.sendAudio) {\n        this.getMediaStream(this.myId).then(function (stream) {\n          var options = {\n            sendAudio: true,\n            localAudioStream: stream\n          };\n\n          _this2.peers[remoteId].offer(options);\n        });\n      } else {\n        this.peers[remoteId].offer({});\n      }\n    }\n  }, {\n    key: \"closeStreamConnection\",\n    value: function closeStreamConnection(clientId) {\n      NAF.log.write('closeStreamConnection', clientId, this.peers);\n      this.peers[clientId].close();\n      delete this.peers[clientId];\n      delete this.occupants[clientId];\n      this.closedListener(clientId);\n    }\n  }, {\n    key: \"getConnectStatus\",\n    value: function getConnectStatus(clientId) {\n      var peer = this.peers[clientId];\n      if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\n\n      switch (peer.getStatus()) {\n        case WebRtcPeer.IS_CONNECTED:\n          return NAF.adapters.IS_CONNECTED;\n\n        case WebRtcPeer.CONNECTING:\n          return NAF.adapters.CONNECTING;\n\n        case WebRtcPeer.NOT_CONNECTED:\n        default:\n          return NAF.adapters.NOT_CONNECTED;\n      }\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(to, type, data) {\n      this.peers[to].send(type, data);\n    }\n  }, {\n    key: \"sendDataGuaranteed\",\n    value: function sendDataGuaranteed(to, type, data) {\n      var packet = {\n        from: this.myId,\n        to: to,\n        type: type,\n        data: data,\n        sending: true\n      };\n      this.socket.emit(\"send\", packet);\n    }\n  }, {\n    key: \"broadcastData\",\n    value: function broadcastData(type, data) {\n      for (var clientId in this.peers) {\n        this.sendData(clientId, type, data);\n      }\n    }\n  }, {\n    key: \"broadcastDataGuaranteed\",\n    value: function broadcastDataGuaranteed(type, data) {\n      var packet = {\n        from: this.myId,\n        type: type,\n        data: data,\n        broadcasting: true\n      };\n      this.socket.emit(\"broadcast\", packet);\n    }\n  }, {\n    key: \"storeAudioStream\",\n    value: function storeAudioStream(clientId, stream) {\n      this.audioStreams[clientId] = stream;\n\n      if (this.pendingAudioRequest[clientId]) {\n        NAF.log.write(\"Received pending audio for \" + clientId);\n        this.pendingAudioRequest[clientId](stream);\n        delete this.pendingAudioRequest[clientId](stream);\n      }\n    }\n  }, {\n    key: \"trackListener\",\n    value: function trackListener(clientId, stream) {\n      this.storeAudioStream(clientId, stream);\n    }\n  }, {\n    key: \"getMediaStream\",\n    value: function getMediaStream(clientId) {\n      var self = this;\n\n      if (this.audioStreams[clientId]) {\n        NAF.log.write(\"Already had audio for \" + clientId);\n        return Promise.resolve(this.audioStreams[clientId]);\n      } else {\n        NAF.log.write(\"Waiting on audio for \" + clientId);\n        return new Promise(function (resolve) {\n          self.pendingAudioRequest[clientId] = resolve;\n        });\n      }\n    }\n  }, {\n    key: \"updateTimeOffset\",\n    value: function updateTimeOffset() {\n      var _this3 = this;\n\n      var clientSentTime = Date.now() + this.avgTimeOffset;\n      return fetch(document.location.href, {\n        method: \"HEAD\",\n        cache: \"no-cache\"\n      }).then(function (res) {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + precision / 2;\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + (clientReceivedTime - clientSentTime) / 2;\n        var timeOffset = serverTime - clientReceivedTime;\n        _this3.serverTimeRequests++;\n\n        if (_this3.serverTimeRequests <= 10) {\n          _this3.timeOffsets.push(timeOffset);\n        } else {\n          _this3.timeOffsets[_this3.serverTimeRequests % 10] = timeOffset;\n        }\n\n        _this3.avgTimeOffset = _this3.timeOffsets.reduce(function (acc, offset) {\n          return acc += offset;\n        }, 0) / _this3.timeOffsets.length;\n\n        if (_this3.serverTimeRequests > 10) {\n          setTimeout(function () {\n            return _this3.updateTimeOffset();\n          }, 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          _this3.updateTimeOffset();\n        }\n      });\n    }\n  }, {\n    key: \"getServerTime\",\n    value: function getServerTime() {\n      return new Date().getTime() + this.avgTimeOffset;\n    }\n  }]);\n\n  return WebrtcAdapter;\n}(); // NAF.adapters.register(\"native-webrtc\", WebrtcAdapter);\n\n\nmodule.exports = WebrtcAdapter;\n\n//# sourceURL=webpack:///./src/adapters/naf-webrtc-adapter.js?");

/***/ }),

/***/ "./src/components/networked-audio-source.js":
/*!**************************************************!*\
  !*** ./src/components/networked-audio-source.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global AFRAME, NAF, THREE */\nvar naf = __webpack_require__(/*! ../NafIndex */ \"./src/NafIndex.js\");\n\nAFRAME.registerComponent('networked-audio-source', {\n  schema: {\n    positional: {\n      \"default\": true\n    },\n    distanceModel: {\n      \"default\": \"inverse\",\n      oneOf: [\"linear\", \"inverse\", \"exponential\"]\n    },\n    maxDistance: {\n      \"default\": 10000\n    },\n    refDistance: {\n      \"default\": 1\n    },\n    rolloffFactor: {\n      \"default\": 1\n    }\n  },\n  init: function init() {\n    var _this = this;\n\n    this.listener = null;\n    this.stream = null;\n    this._setMediaStream = this._setMediaStream.bind(this);\n    NAF.utils.getNetworkedEntity(this.el).then(function (networkedEl) {\n      var ownerId = networkedEl.components.networked.data.owner;\n\n      if (ownerId) {\n        NAF.connection.adapter.getMediaStream(ownerId).then(_this._setMediaStream)[\"catch\"](function (e) {\n          return naf.log.error(\"Error getting media stream for \".concat(ownerId), e);\n        });\n      } else {// Correctly configured local entity, perhaps do something here for enabling debug audio loopback\n      }\n    });\n  },\n  update: function update() {\n    this._setPannerProperties();\n  },\n  _setMediaStream: function _setMediaStream(newStream) {\n    if (!this.sound) {\n      this.setupSound();\n    }\n\n    if (newStream != this.stream) {\n      if (this.stream) {\n        this.sound.disconnect();\n      }\n\n      if (newStream) {\n        // Chrome seems to require a MediaStream be attached to an AudioElement before AudioNodes work correctly\n        // We don't want to do this in other browsers, particularly in Safari, which actually plays the audio despite\n        // setting the volume to 0.\n        if (/chrome/i.test(navigator.userAgent)) {\n          this.audioEl = new Audio();\n          this.audioEl.setAttribute(\"autoplay\", \"autoplay\");\n          this.audioEl.setAttribute(\"playsinline\", \"playsinline\");\n          this.audioEl.srcObject = newStream;\n          this.audioEl.volume = 0; // we don't actually want to hear audio from this element\n        }\n\n        var soundSource = this.sound.context.createMediaStreamSource(newStream);\n        this.sound.setNodeSource(soundSource);\n        this.el.emit('sound-source-set', {\n          soundSource: soundSource\n        });\n      }\n\n      this.stream = newStream;\n    }\n  },\n  _setPannerProperties: function _setPannerProperties() {\n    if (this.sound && this.data.positional) {\n      this.sound.setDistanceModel(this.data.distanceModel);\n      this.sound.setMaxDistance(this.data.maxDistance);\n      this.sound.setRefDistance(this.data.refDistance);\n      this.sound.setRolloffFactor(this.data.rolloffFactor);\n    }\n  },\n  remove: function remove() {\n    if (!this.sound) return;\n    this.el.removeObject3D(this.attrName);\n\n    if (this.stream) {\n      this.sound.disconnect();\n    }\n  },\n  setupSound: function setupSound() {\n    var el = this.el;\n    var sceneEl = el.sceneEl;\n\n    if (this.sound) {\n      el.removeObject3D(this.attrName);\n    }\n\n    if (!sceneEl.audioListener) {\n      sceneEl.audioListener = new THREE.AudioListener();\n      sceneEl.camera && sceneEl.camera.add(sceneEl.audioListener);\n      sceneEl.addEventListener('camera-set-active', function (evt) {\n        evt.detail.cameraEl.getObject3D('camera').add(sceneEl.audioListener);\n      });\n    }\n\n    this.listener = sceneEl.audioListener;\n    this.sound = this.data.positional ? new THREE.PositionalAudio(this.listener) : new THREE.Audio(this.listener);\n    el.setObject3D(this.attrName, this.sound);\n\n    this._setPannerProperties();\n  }\n});\n\n//# sourceURL=webpack:///./src/components/networked-audio-source.js?");

/***/ }),

/***/ "./src/components/networked-scene.js":
/*!*******************************************!*\
  !*** ./src/components/networked-scene.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global AFRAME, NAF */\nAFRAME.registerComponent('networked-scene', {\n  schema: {\n    serverURL: {\n      \"default\": '/'\n    },\n    app: {\n      \"default\": 'default'\n    },\n    room: {\n      \"default\": 'default'\n    },\n    connectOnLoad: {\n      \"default\": true\n    },\n    onConnect: {\n      \"default\": 'onConnect'\n    },\n    adapter: {\n      \"default\": 'socketio'\n    },\n    // See https://github.com/networked-aframe/networked-aframe#adapters for list of adapters\n    audio: {\n      \"default\": false\n    },\n    // Only if adapter supports audio\n    debug: {\n      \"default\": false\n    }\n  },\n  init: function init() {\n    var el = this.el;\n    this.connect = this.connect.bind(this);\n    el.addEventListener('connect', this.connect);\n\n    if (this.data.connectOnLoad) {\n      el.emit('connect', null, false);\n    }\n  },\n\n  /**\n   * Connect to signalling server and begin connecting to other clients\n   */\n  connect: function connect() {\n    NAF.log.setDebug(this.data.debug);\n    NAF.log.write('Networked-Aframe Connecting...');\n    this.checkDeprecatedProperties();\n    this.setupNetworkAdapter();\n\n    if (this.hasOnConnectFunction()) {\n      this.callOnConnect();\n    }\n\n    return NAF.connection.connect(this.data.serverURL, this.data.app, this.data.room, this.data.audio);\n  },\n  checkDeprecatedProperties: function checkDeprecatedProperties() {// No current\n  },\n  setupNetworkAdapter: function setupNetworkAdapter() {\n    var adapterName = this.data.adapter;\n    var adapter = NAF.adapters.make(adapterName);\n    NAF.connection.setNetworkAdapter(adapter);\n    this.el.emit('adapter-ready', adapter, false);\n  },\n  hasOnConnectFunction: function hasOnConnectFunction() {\n    return this.data.onConnect != '' && window[this.data.onConnect];\n  },\n  callOnConnect: function callOnConnect() {\n    NAF.connection.onConnect(window[this.data.onConnect]);\n  },\n  remove: function remove() {\n    NAF.log.write('networked-scene disconnected');\n    this.el.removeEventListener('connect', this.connect);\n    NAF.connection.disconnect();\n  }\n});\n\n//# sourceURL=webpack:///./src/components/networked-scene.js?");

/***/ }),

/***/ "./src/components/networked.js":
/*!*************************************!*\
  !*** ./src/components/networked.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global AFRAME, NAF, THREE */\nvar deepEqual = __webpack_require__(/*! ../DeepEquals */ \"./src/DeepEquals.js\");\n\nvar InterpolationBuffer = __webpack_require__(/*! buffered-interpolation */ \"./node_modules/buffered-interpolation/dist/buffered-interpolation.js\");\n\nvar DEG2RAD = THREE.Math.DEG2RAD;\nvar OBJECT3D_COMPONENTS = ['position', 'rotation', 'scale'];\n\nfunction defaultRequiresUpdate() {\n  var cachedData = null;\n  return function (newData) {\n    if (cachedData === null || !deepEqual(cachedData, newData)) {\n      cachedData = AFRAME.utils.clone(newData);\n      return true;\n    }\n\n    return false;\n  };\n}\n\nAFRAME.registerSystem(\"networked\", {\n  init: function init() {\n    this.components = [];\n    this.nextSyncTime = 0;\n  },\n  register: function register(component) {\n    this.components.push(component);\n  },\n  deregister: function deregister(component) {\n    var idx = this.components.indexOf(component);\n\n    if (idx > -1) {\n      this.components.splice(idx, 1);\n    }\n  },\n  tick: function () {\n    return function () {\n      if (!NAF.connection.adapter) return;\n      if (this.el.clock.elapsedTime < this.nextSyncTime) return;\n      var data = {\n        d: []\n      };\n\n      for (var i = 0, l = this.components.length; i < l; i++) {\n        var c = this.components[i];\n        if (!c.isMine()) continue;\n\n        if (!c.el.parentElement) {\n          NAF.log.error(\"entity registered with system despite being removed\"); //TODO: Find out why tick is still being called\n\n          return;\n        }\n\n        var syncData = this.components[i].syncDirty();\n        if (!syncData) continue;\n        data.d.push(syncData);\n      }\n\n      if (data.d.length > 0) {\n        NAF.connection.broadcastData('um', data);\n      }\n\n      this.updateNextSyncTime();\n    };\n  }(),\n  updateNextSyncTime: function updateNextSyncTime() {\n    this.nextSyncTime = this.el.clock.elapsedTime + 1 / NAF.options.updateRate;\n  }\n});\nAFRAME.registerComponent('networked', {\n  schema: {\n    template: {\n      \"default\": ''\n    },\n    attachTemplateToLocal: {\n      \"default\": true\n    },\n    persistent: {\n      \"default\": false\n    },\n    networkId: {\n      \"default\": ''\n    },\n    owner: {\n      \"default\": ''\n    },\n    creator: {\n      \"default\": ''\n    }\n  },\n  init: function init() {\n    this.OWNERSHIP_GAINED = 'ownership-gained';\n    this.OWNERSHIP_CHANGED = 'ownership-changed';\n    this.OWNERSHIP_LOST = 'ownership-lost';\n    this.onOwnershipGainedEvent = {\n      el: this.el\n    };\n    this.onOwnershipChangedEvent = {\n      el: this.el\n    };\n    this.onOwnershipLostEvent = {\n      el: this.el\n    };\n    this.conversionEuler = new THREE.Euler();\n    this.conversionEuler.order = \"YXZ\";\n    this.bufferInfos = [];\n    this.bufferPosition = new THREE.Vector3();\n    this.bufferQuaternion = new THREE.Quaternion();\n    this.bufferScale = new THREE.Vector3();\n    var wasCreatedByNetwork = this.wasCreatedByNetwork();\n    this.onConnected = this.onConnected.bind(this);\n    this.syncData = {};\n    this.componentSchemas = NAF.schemas.getComponents(this.data.template);\n    this.cachedElements = new Array(this.componentSchemas.length);\n    this.networkUpdatePredicates = this.componentSchemas.map(function (x) {\n      return x.requiresNetworkUpdate && x.requiresNetworkUpdate() || defaultRequiresUpdate();\n    }); // Fill cachedElements array with null elements\n\n    this.invalidateCachedElements();\n    this.initNetworkParent();\n\n    if (this.data.networkId === '') {\n      this.el.setAttribute(this.name, {\n        networkId: NAF.utils.createNetworkId()\n      });\n    }\n\n    if (wasCreatedByNetwork) {\n      this.firstUpdate();\n    } else {\n      if (this.data.attachTemplateToLocal) {\n        this.attachTemplateToLocal();\n      }\n\n      this.registerEntity(this.data.networkId);\n    }\n\n    this.lastOwnerTime = -1;\n\n    if (NAF.clientId) {\n      this.onConnected();\n    } else {\n      document.body.addEventListener('connected', this.onConnected, false);\n    }\n\n    document.body.dispatchEvent(this.entityCreatedEvent());\n    this.el.dispatchEvent(new CustomEvent('instantiated', {\n      detail: {\n        el: this.el\n      }\n    }));\n    this.el.sceneEl.systems.networked.register(this);\n  },\n  attachTemplateToLocal: function attachTemplateToLocal() {\n    var template = NAF.schemas.getCachedTemplate(this.data.template);\n    var elAttrs = template.attributes; // Merge root element attributes with this entity\n\n    for (var attrIdx = 0; attrIdx < elAttrs.length; attrIdx++) {\n      this.el.setAttribute(elAttrs[attrIdx].name, elAttrs[attrIdx].value);\n    } // Append all child elements\n\n\n    while (template.firstElementChild) {\n      this.el.appendChild(template.firstElementChild);\n    }\n  },\n  takeOwnership: function takeOwnership() {\n    var owner = this.data.owner;\n    var lastOwnerTime = this.lastOwnerTime;\n    var now = NAF.connection.getServerTime();\n\n    if (owner && !this.isMine() && lastOwnerTime < now) {\n      this.lastOwnerTime = now;\n      this.removeLerp();\n      this.el.setAttribute('networked', {\n        owner: NAF.clientId\n      });\n      this.syncAll();\n      this.onOwnershipGainedEvent.oldOwner = owner;\n      this.el.emit(this.OWNERSHIP_GAINED, this.onOwnershipGainedEvent);\n      this.onOwnershipChangedEvent.oldOwner = owner;\n      this.onOwnershipChangedEvent.newOwner = NAF.clientId;\n      this.el.emit(this.OWNERSHIP_CHANGED, this.onOwnershipChangedEvent);\n      return true;\n    }\n\n    return false;\n  },\n  wasCreatedByNetwork: function wasCreatedByNetwork() {\n    return !!this.el.firstUpdateData;\n  },\n  initNetworkParent: function initNetworkParent() {\n    var parentEl = this.el.parentElement;\n\n    if (parentEl['components'] && parentEl.components['networked']) {\n      this.parent = parentEl;\n    } else {\n      this.parent = null;\n    }\n  },\n  registerEntity: function registerEntity(networkId) {\n    NAF.entities.registerEntity(networkId, this.el);\n  },\n  applyPersistentFirstSync: function applyPersistentFirstSync() {\n    var networkId = this.data.networkId;\n    var persistentFirstSync = NAF.entities.getPersistentFirstSync(networkId);\n\n    if (persistentFirstSync) {\n      this.networkUpdate(persistentFirstSync);\n      NAF.entities.forgetPersistentFirstSync(networkId);\n    }\n  },\n  firstUpdate: function firstUpdate() {\n    var entityData = this.el.firstUpdateData;\n    this.networkUpdate(entityData);\n  },\n  onConnected: function onConnected() {\n    var _this = this;\n\n    if (this.data.owner === '') {\n      this.lastOwnerTime = NAF.connection.getServerTime();\n      this.el.setAttribute(this.name, {\n        owner: NAF.clientId,\n        creator: NAF.clientId\n      });\n      setTimeout(function () {\n        //a-primitives attach their components on the next frame; wait for components to be attached before calling syncAll\n        if (!_this.el.parentNode) {\n          NAF.log.warn(\"Networked element was removed before ever getting the chance to syncAll\");\n          return;\n        }\n\n        _this.syncAll(undefined, true);\n      }, 0);\n    }\n\n    document.body.removeEventListener('connected', this.onConnected, false);\n  },\n  isMine: function isMine() {\n    return this.data.owner === NAF.clientId;\n  },\n  createdByMe: function createdByMe() {\n    return this.data.creator === NAF.clientId;\n  },\n  tick: function tick(time, dt) {\n    if (!this.isMine() && NAF.options.useLerp) {\n      for (var i = 0; i < this.bufferInfos.length; i++) {\n        var bufferInfo = this.bufferInfos[i];\n        var buffer = bufferInfo.buffer;\n        var object3D = bufferInfo.object3D;\n        var componentNames = bufferInfo.componentNames;\n        buffer.update(dt);\n\n        if (componentNames.includes('position')) {\n          object3D.position.copy(buffer.getPosition());\n        }\n\n        if (componentNames.includes('rotation')) {\n          object3D.quaternion.copy(buffer.getQuaternion());\n        }\n\n        if (componentNames.includes('scale')) {\n          object3D.scale.copy(buffer.getScale());\n        }\n      }\n    }\n  },\n\n  /* Sending updates */\n  syncAll: function syncAll(targetClientId, isFirstSync) {\n    if (!this.canSync()) {\n      return;\n    }\n\n    var components = this.gatherComponentsData(true);\n    var syncData = this.createSyncData(components, isFirstSync);\n\n    if (targetClientId) {\n      NAF.connection.sendDataGuaranteed(targetClientId, 'u', syncData);\n    } else {\n      NAF.connection.broadcastDataGuaranteed('u', syncData);\n    }\n  },\n  syncDirty: function syncDirty() {\n    if (!this.canSync()) {\n      return;\n    }\n\n    var components = this.gatherComponentsData(false);\n\n    if (components === null) {\n      return;\n    }\n\n    return this.createSyncData(components);\n  },\n  getCachedElement: function getCachedElement(componentSchemaIndex) {\n    var cachedElement = this.cachedElements[componentSchemaIndex];\n\n    if (cachedElement) {\n      return cachedElement;\n    }\n\n    var componentSchema = this.componentSchemas[componentSchemaIndex];\n\n    if (componentSchema.selector) {\n      return this.cachedElements[componentSchemaIndex] = this.el.querySelector(componentSchema.selector);\n    } else {\n      return this.cachedElements[componentSchemaIndex] = this.el;\n    }\n  },\n  invalidateCachedElements: function invalidateCachedElements() {\n    for (var i = 0; i < this.cachedElements.length; i++) {\n      this.cachedElements[i] = null;\n    }\n  },\n  gatherComponentsData: function gatherComponentsData(fullSync) {\n    var componentsData = null;\n\n    for (var i = 0; i < this.componentSchemas.length; i++) {\n      var componentSchema = this.componentSchemas[i];\n      var componentElement = this.getCachedElement(i);\n\n      if (!componentElement) {\n        if (fullSync) {\n          componentsData = componentsData || {};\n          componentsData[i] = null;\n        }\n\n        continue;\n      }\n\n      var componentName = componentSchema.component ? componentSchema.component : componentSchema;\n      var componentData = componentElement.getAttribute(componentName);\n\n      if (componentData === null) {\n        if (fullSync) {\n          componentsData = componentsData || {};\n          componentsData[i] = null;\n        }\n\n        continue;\n      }\n\n      var syncedComponentData = componentSchema.property ? componentData[componentSchema.property] : componentData; // Use networkUpdatePredicate to check if the component needs to be updated.\n      // Call networkUpdatePredicate first so that it can update any cached values in the event of a fullSync.\n\n      if (this.networkUpdatePredicates[i](syncedComponentData) || fullSync) {\n        componentsData = componentsData || {};\n        componentsData[i] = syncedComponentData;\n      }\n    }\n\n    return componentsData;\n  },\n  createSyncData: function createSyncData(components, isFirstSync) {\n    var syncData = this.syncData,\n        data = this.data;\n    syncData.networkId = data.networkId;\n    syncData.owner = data.owner;\n    syncData.creator = data.creator;\n    syncData.lastOwnerTime = this.lastOwnerTime;\n    syncData.template = data.template;\n    syncData.persistent = data.persistent;\n    syncData.parent = this.getParentId();\n    syncData.components = components;\n    syncData.isFirstSync = !!isFirstSync;\n    return syncData;\n  },\n  canSync: function canSync() {\n    // This client will send a sync if:\n    //\n    // - The client is the owner\n    // - The client is the creator, and the owner is not in the room.\n    //\n    // The reason for the latter case is so the object will still be\n    // properly instantiated if the owner leaves. (Since the object lifetime\n    // is tied to the creator.)\n    if (this.data.owner && this.isMine()) return true;\n    if (!this.createdByMe()) return false;\n    var clients = NAF.connection.getConnectedClients();\n\n    for (var clientId in clients) {\n      if (clientId === this.data.owner) return false;\n    }\n\n    return true;\n  },\n  getParentId: function getParentId() {\n    this.initNetworkParent(); // TODO fix calling this each network tick\n\n    if (!this.parent) {\n      return null;\n    }\n\n    var netComp = this.parent.getAttribute('networked');\n    return netComp.networkId;\n  },\n\n  /* Receiving updates */\n  networkUpdate: function networkUpdate(entityData) {\n    // Avoid updating components if the entity data received did not come from the current owner.\n    if (entityData.lastOwnerTime < this.lastOwnerTime || this.lastOwnerTime === entityData.lastOwnerTime && this.data.owner > entityData.owner) {\n      return;\n    } // Hack to solve this bug: https://github.com/networked-aframe/networked-aframe/issues/200\n\n\n    if (this.data === undefined) {\n      return;\n    }\n\n    if (this.data.owner !== entityData.owner) {\n      var wasMine = this.isMine();\n      this.lastOwnerTime = entityData.lastOwnerTime;\n      var oldOwner = this.data.owner;\n      var newOwner = entityData.owner;\n      this.el.setAttribute('networked', {\n        owner: entityData.owner\n      });\n\n      if (wasMine) {\n        this.onOwnershipLostEvent.newOwner = newOwner;\n        this.el.emit(this.OWNERSHIP_LOST, this.onOwnershipLostEvent);\n      }\n\n      this.onOwnershipChangedEvent.oldOwner = oldOwner;\n      this.onOwnershipChangedEvent.newOwner = newOwner;\n      this.el.emit(this.OWNERSHIP_CHANGED, this.onOwnershipChangedEvent);\n    }\n\n    if (this.data.persistent !== entityData.persistent) {\n      this.el.setAttribute('networked', {\n        persistent: entityData.persistent\n      });\n    }\n\n    this.updateNetworkedComponents(entityData.components);\n  },\n  updateNetworkedComponents: function updateNetworkedComponents(components) {\n    for (var componentIndex = 0, l = this.componentSchemas.length; componentIndex < l; componentIndex++) {\n      var componentData = components[componentIndex];\n      var componentSchema = this.componentSchemas[componentIndex];\n      var componentElement = this.getCachedElement(componentIndex);\n\n      if (componentElement === null || componentData === null || componentData === undefined) {\n        continue;\n      }\n\n      if (componentSchema.component) {\n        if (componentSchema.property) {\n          this.updateNetworkedComponent(componentElement, componentSchema.component, componentSchema.property, componentData);\n        } else {\n          this.updateNetworkedComponent(componentElement, componentSchema.component, componentData);\n        }\n      } else {\n        this.updateNetworkedComponent(componentElement, componentSchema, componentData);\n      }\n    }\n  },\n  updateNetworkedComponent: function updateNetworkedComponent(el, componentName, data, value) {\n    if (!NAF.options.useLerp || !OBJECT3D_COMPONENTS.includes(componentName)) {\n      if (value === undefined) {\n        el.setAttribute(componentName, data);\n      } else {\n        el.setAttribute(componentName, data, value);\n      }\n\n      return;\n    }\n\n    var bufferInfo;\n\n    for (var i = 0, l = this.bufferInfos.length; i < l; i++) {\n      var info = this.bufferInfos[i];\n\n      if (info.object3D === el.object3D) {\n        bufferInfo = info;\n        break;\n      }\n    }\n\n    if (!bufferInfo) {\n      bufferInfo = {\n        buffer: new InterpolationBuffer(InterpolationBuffer.MODE_LERP, 0.1),\n        object3D: el.object3D,\n        componentNames: [componentName]\n      };\n      this.bufferInfos.push(bufferInfo);\n    } else {\n      var componentNames = bufferInfo.componentNames;\n\n      if (!componentNames.includes(componentName)) {\n        componentNames.push(componentName);\n      }\n    }\n\n    var buffer = bufferInfo.buffer;\n\n    switch (componentName) {\n      case 'position':\n        buffer.setPosition(this.bufferPosition.set(data.x, data.y, data.z));\n        return;\n\n      case 'rotation':\n        this.conversionEuler.set(DEG2RAD * data.x, DEG2RAD * data.y, DEG2RAD * data.z);\n        buffer.setQuaternion(this.bufferQuaternion.setFromEuler(this.conversionEuler));\n        return;\n\n      case 'scale':\n        buffer.setScale(this.bufferScale.set(data.x, data.y, data.z));\n        return;\n    }\n\n    NAF.log.error('Could not set value in interpolation buffer.', el, componentName, data, bufferInfo);\n  },\n  removeLerp: function removeLerp() {\n    this.bufferInfos = [];\n  },\n  remove: function remove() {\n    if (this.isMine() && NAF.connection.isConnected()) {\n      var syncData = {\n        networkId: this.data.networkId\n      };\n\n      if (NAF.entities.hasEntity(this.data.networkId)) {\n        NAF.connection.broadcastDataGuaranteed('r', syncData);\n      } else {\n        NAF.log.error(\"Removing networked entity that is not in entities array.\");\n      }\n    }\n\n    NAF.entities.forgetEntity(this.data.networkId);\n    document.body.dispatchEvent(this.entityRemovedEvent(this.data.networkId));\n    this.el.sceneEl.systems.networked.deregister(this);\n  },\n  entityCreatedEvent: function entityCreatedEvent() {\n    return new CustomEvent('entityCreated', {\n      detail: {\n        el: this.el\n      }\n    });\n  },\n  entityRemovedEvent: function entityRemovedEvent(networkId) {\n    return new CustomEvent('entityRemoved', {\n      detail: {\n        networkId: networkId\n      }\n    });\n  }\n});\n\n//# sourceURL=webpack:///./src/components/networked.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Global vars and functions\n__webpack_require__(/*! ./NafIndex.js */ \"./src/NafIndex.js\"); // Network components\n\n\n__webpack_require__(/*! ./components/networked-scene */ \"./src/components/networked-scene.js\");\n\n__webpack_require__(/*! ./components/networked */ \"./src/components/networked.js\");\n\n__webpack_require__(/*! ./components/networked-audio-source */ \"./src/components/networked-audio-source.js\");\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/options.js":
/*!************************!*\
  !*** ./src/options.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar options = {\n  debug: false,\n  updateRate: 15,\n  // How often network components call `sync`\n  useLerp: true,\n  // lerp position, rotation, and scale components on networked entities.\n  firstSyncSource: null,\n  // If specified, only allow first syncs from this source.\n  syncSource: null // If specified, only allow syncs from this source.\n\n};\nmodule.exports = options;\n\n//# sourceURL=webpack:///./src/options.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global NAF */\nmodule.exports.whenEntityLoaded = function (entity, callback) {\n  if (entity.hasLoaded) {\n    callback();\n  }\n\n  entity.addEventListener('loaded', function () {\n    callback();\n  });\n};\n\nmodule.exports.createHtmlNodeFromString = function (str) {\n  var div = document.createElement('div');\n  div.innerHTML = str;\n  var child = div.firstChild;\n  return child;\n};\n\nmodule.exports.getCreator = function (el) {\n  var components = el.components;\n\n  if (components['networked']) {\n    return components['networked'].data.creator;\n  }\n\n  return null;\n};\n\nmodule.exports.getNetworkOwner = function (el) {\n  var components = el.components;\n\n  if (components['networked']) {\n    return components['networked'].data.owner;\n  }\n\n  return null;\n};\n\nmodule.exports.getNetworkId = function (el) {\n  var components = el.components;\n\n  if (components['networked']) {\n    return components['networked'].data.networkId;\n  }\n\n  return null;\n};\n\nmodule.exports.now = function () {\n  return Date.now();\n};\n\nmodule.exports.createNetworkId = function () {\n  return Math.random().toString(36).substring(2, 9);\n};\n/**\n * Find the closest ancestor (including the passed in entity) that has a `networked` component\n * @param {ANode} entity - Entity to begin the search on\n * @returns {Promise<ANode>} An promise that resolves to an entity with a `networked` component\n */\n\n\nfunction getNetworkedEntity(entity) {\n  return new Promise(function (resolve, reject) {\n    var curEntity = entity;\n\n    while (curEntity && curEntity.components && !curEntity.components.networked) {\n      curEntity = curEntity.parentNode;\n    }\n\n    if (!curEntity || !curEntity.components || !curEntity.components.networked) {\n      return reject(\"Entity does not have and is not a child of an entity with the [networked] component \");\n    }\n\n    if (curEntity.hasLoaded) {\n      resolve(curEntity);\n    } else {\n      curEntity.addEventListener(\"instantiated\", function () {\n        resolve(curEntity);\n      }, {\n        once: true\n      });\n    }\n  });\n}\n\nmodule.exports.getNetworkedEntity = getNetworkedEntity;\n\nmodule.exports.takeOwnership = function (entity) {\n  var curEntity = entity;\n\n  while (curEntity && curEntity.components && !curEntity.components.networked) {\n    curEntity = curEntity.parentNode;\n  }\n\n  if (!curEntity || !curEntity.components || !curEntity.components.networked) {\n    throw new Error(\"Entity does not have and is not a child of an entity with the [networked] component \");\n  }\n\n  return curEntity.components.networked.takeOwnership();\n};\n\nmodule.exports.isMine = function (entity) {\n  var curEntity = entity;\n\n  while (curEntity && curEntity.components && !curEntity.components.networked) {\n    curEntity = curEntity.parentNode;\n  }\n\n  if (!curEntity || !curEntity.components || !curEntity.components.networked) {\n    throw new Error(\"Entity does not have and is not a child of an entity with the [networked] component \");\n  }\n\n  return curEntity.components.networked.data.owner === NAF.clientId;\n};\n\nmodule.exports.almostEqualVec3 = function (u, v, epsilon) {\n  return Math.abs(u.x - v.x) < epsilon && Math.abs(u.y - v.y) < epsilon && Math.abs(u.z - v.z) < epsilon;\n};\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });